
----- FILE: SUMMARY.md -----

### OMM Pricer Context Pack
Generated on: Fri  3 Oct 2025 21:57:36 BST
Git: branch=ai/setup-ai-patch-workflow, commit=8b95d27 AI: bootstrap patch-based workflow (tools + CI + PR template)

---

## ğŸ”¹ Context Summary

We are building the **OMM pricer backend** in TypeScript/Node with a single â€œcalculusâ€ that ties together:
- **Core curve (CC)** â€” fair value surface (SVI-based).
- **Pricing curve (PC)** â€” CC plus inventory/trader adjustments.
- **Widths (bid/ask)** â€” function of factor exposure and inventory pressure.
- **Propagation** â€” change one thing (fills, nudges, F, time) â†’ consistent shifts across the book.

**Key types**
- Factors (Î¸): `[L0, S0, C0, S_neg, S_pos, F]`
- Factor greeks gáµ¢(strike, T, F) = âˆ‚Price/âˆ‚Î¸áµ¢
- Costs Î»áµ¢ (ticks per unit factor exposure)
- Inventory Iáµ¢ (aggregate exposure along each factor)

**Core identities**
- `PC_mid = CC_mid + dot(Î», g)`
- `width = w0 + Î±Â·|dot(Î», g)| + Î²Â·invPressure(I)`
- Trade update: `I â† I + q Â· g` (q>0 long)
- Propagation (nudge): `Î”P â‰ˆ G Â· Î”Î¸`, where `G` is Jacobian over grid

---

## ğŸ—ºï¸ Minimal Roadmap (weeks)

**W1**: factor greeks (finite diff), Î»/I wiring, PC/width from Î»Â·g, logging, limits skeleton  
**W2**: close-form SVI partials, smoothing Î», latency trims  
**W3**: backtest 7â€“30D, fit Î» via ridge to realized slippage, fee model, guards  
**W4**: surface visualizer, param sweeps, runbook

---

## âœ… Immediate Tasks (implemented/ready to scaffold)
1) Add factor calculus scaffolding (, ) with finite-difference gáµ¢.
2) Store Î» and I per symbol in volModelService. Update I on trade. Expose via .
3) Compute PC mid, width via Î»Â·g (keep sanity clamps).
4) Observability: log {F,K,T, ccMid, pcMid, Î»Â·g, width, I, bucket}.
5) Limits: soft/hard on Iáµ¢ â†’ widen/stop/emit-hedge-signal.



----- FILE: apps/server/src/volModels/factors/FactorSpace.ts (PROPOSED) -----

/**
 * FactorSpace â€” types + helpers for factor calculus
 * Factors: [L0, S0, C0, S_neg, S_pos, F]
 */
export type FactorVec = [number, number, number, number, number, number];
export const ZeroFactors: FactorVec = [0,0,0,0,0,0];

export function dot(a: FactorVec, b: FactorVec): number {
  let s = 0;
  for (let i=0;i<6;i++) s += a[i]*b[i];
  return s;
}
export function axpy(y: FactorVec, a: number, x: FactorVec): FactorVec {
  return [
    y[0] + a*x[0],
    y[1] + a*x[1],
    y[2] + a*x[2],
    y[3] + a*x[3],
    y[4] + a*x[4],
    y[5] + a*x[5],
  ];
}
export function norm1(a: FactorVec): number {
  return Math.abs(a[0])+Math.abs(a[1])+Math.abs(a[2])+Math.abs(a[3])+Math.abs(a[4])+Math.abs(a[5]);
}


----- FILE: apps/server/src/volModels/factors/factorGreeks.ts (PROPOSED) -----

/**
 * Finite-difference factor greeks g_i = âˆ‚P/âˆ‚Î¸_i
 * Safe, slow prototype; replace with closed-form SVI partials later.
 */
import { FactorVec } from "./FactorSpace";
import { SVI, SVIParams } from "../dualSurfaceModel";
import { black76Greeks } from "../../risk";

type PriceFn = (params: {cc: SVIParams; strike:number; T:number; F:number; isCall:boolean}) => number;

const EPS: FactorVec = [1e-4, 1e-4, 1e-3, 1e-4, 1e-4, 1e-6];

export function factorGreeksFiniteDiff(
  cc: SVIParams,
  strike: number,
  T: number,
  F: number,
  isCall: boolean,
  priceFromSVI: PriceFn
): FactorVec {
  // Base price from CC
  const base = priceFromSVI({ cc, strike, T, F, isCall });

  // Map factor â†’ small transform in metric space
  const m0 = SVI.toMetrics(cc);

  function bump(i: number): number {
    const m = { ...m0 };
    switch (i) {
      case 0: m.L0   += EPS[0]; break;
      case 1: m.S0   += EPS[1]; break;
      case 2: m.C0   += EPS[2]; break;
      case 3: m.S_neg+= EPS[3]; break;
      case 4: m.S_pos+= EPS[4]; break;
      case 5: /*F*/   return priceFromSVI({ cc, strike, T, F: F+EPS[5], isCall }) - base;
    }
    const bumped = SVI.fromMetrics(m, {
      bMin: 0, sigmaMin: 1e-6, rhoMax: 0.999, sMax: 5, c0Min: 0.01,
      buckets: [], edgeParams: new Map(), rbfWidth: 0, ridgeLambda: 0, maxL0Move: 0, maxS0Move: 0, maxC0Move: 0
    });
    return priceFromSVI({ cc: bumped, strike, T, F, isCall }) - base;
  }

  const g0 = bump(0)/EPS[0];
  const g1 = bump(1)/EPS[1];
  const g2 = bump(2)/EPS[2];
  const g3 = bump(3)/EPS[3];
  const g4 = bump(4)/EPS[4];
  const g5 = bump(5)/EPS[5];

  return [g0,g1,g2,g3,g4,g5];
}


----- FILE: apps/server/config/risk.factors.yaml (PROPOSED) -----

BTC:
  lambda:        # ticks (or price units) per unit factor exposure
    L0:   0.50
    S0:   0.20
    C0:   0.10
    Sneg: 0.15
    Spos: 0.10
    F:    0.30
  widths:
    w0:    2.0
    alpha: 1.0
    beta:  0.0
  limits:
    soft:
      L0:   5000
      S0:   3000
      C0:   2000
      Sneg: 3000
      Spos: 3000
      F:    10000
    hard:
      L0:   10000
      S0:   6000
      C0:   4000
      Sneg: 6000
      Spos: 6000
      F:    20000


----- FILE: apps/server/src/volModels/factors/README.md (PROPOSED) -----

# Factor calculus quick notes

- Factors Î¸ = [L0, S0, C0, S_neg, S_pos, F]
- g_i(K,T,F) = âˆ‚P/âˆ‚Î¸_i via finite-diff (for now)
- PC mid = CC mid + Î»Â·g
- width  = w0 + Î±Â·|Î»Â·g| + Î²Â·invPressure(I)
- On trade of size q (customer sign):
  - inventory I â† I + q * g
  - PC moves instantly by Î»Â·(Î”g) if F/T move; otherwise same timestamp: g unchanged, mid unchanged (only inventory and Î»Â·g matter for next quotes)

Swap the finite-diff with closed forms when ready (less noise, faster).


----- FILE: API-SKETCH.md (PROPOSED) -----

# Minimal API sketch

GET  /risk/factors
  -> { symbol, lambda, inventory, lambdaDotInventory, limits }

POST /surface/nudge
  { symbol, dTheta: { L0?:number, S0?:number, C0?:number, Sneg?:number, Spos?:number, F?:number } }
  -> applies Î”Î¸_trader with smoothness penalty, returns new snapshot ({pc-cc} across grid)

POST /forward/update
  { symbol, forward }  -> already exists, ensure it triggers PC recompute

POST /trade/execute
  -> unchanged; path updates inventory I using factor greeks

