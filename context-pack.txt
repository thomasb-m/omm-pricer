===== OMM PRICER CONTEXT PACK =====
Generated: 2025-10-08T14:05:03Z
Repo root: /Users/bryonybamford/Projects/Tom/omm-pricer
Total tracked files:      140

Included source files (76):
 - apps/server/apps/server/src/logging/tradeLog.ts (863 bytes)
 - apps/server/src/__tests__/golden.test.ts (7420 bytes)
 - apps/server/src/api/routes/http.ts (8313 bytes)
 - apps/server/src/api/routes/pnl.ts (796 bytes)
 - apps/server/src/api/routes/risk.ts (526 bytes)
 - apps/server/src/config/index.ts (7492 bytes)
 - apps/server/src/engine/PriceCalculus.ts (3527 bytes)
 - apps/server/src/engine/QuoteEngine.ts (7536 bytes)
 - apps/server/src/exchange/SimAdapter.ts (3048 bytes)
 - apps/server/src/logging/tradeLog.ts (657 bytes)
 - apps/server/src/pricing/eventTable.ts (1068 bytes)
 - apps/server/src/pricing/seasonality.ts (2382 bytes)
 - apps/server/src/pricing/totalVariance.ts (920 bytes)
 - apps/server/src/replay/backtester.ts (7648 bytes)
 - apps/server/src/replay/marketRecorder.ts (4071 bytes)
 - apps/server/src/replay/replayEngine.ts (6096 bytes)
 - apps/server/src/replay/testDataSeed.ts (807 bytes)
 - apps/server/src/risk/FactorRisk.ts (7240 bytes)
 - apps/server/src/risk/FactorSpace.ts (2732 bytes)
 - apps/server/src/risk/SigmaService.ts (8790 bytes)
 - apps/server/src/risk/factorGreeksLoader.ts (4192 bytes)
 - apps/server/src/risk/factors.ts (3856 bytes)
 - apps/server/src/scripts/mm_sandbox.ts (7230 bytes)
 - apps/server/src/utils/linalg.ts (5924 bytes)
 - apps/server/src/utils/numeric.ts (2419 bytes)
 - apps/server/src/utils/time.test.ts (495 bytes)
 - apps/server/src/utils/time.ts (194 bytes)
 - apps/server/src/volModels/ParametricSurface.ts (3429 bytes)
 - apps/server/src/volModels/config/modelConfig.ts (4608 bytes)
 - apps/server/src/volModels/controllers/inventoryController.ts (12927 bytes)
 - apps/server/src/volModels/correctedAdapter.ts (3138 bytes)
 - apps/server/src/volModels/diagnostics.ts (3312 bytes)
 - apps/server/src/volModels/dualSurfaceModel.ts (16556 bytes)
 - apps/server/src/volModels/edgeDiagnostic.ts (3182 bytes)
 - apps/server/src/volModels/factors/FactorSpace.ts (778 bytes)
 - apps/server/src/volModels/factors/factorGreeks.ts (4062 bytes)
 - apps/server/src/volModels/integratedModel.ts (15227 bytes)
 - apps/server/src/volModels/integratedSmileModel.ts (12192 bytes)
 - apps/server/src/volModels/integration/basicIntegration.ts (358 bytes)
 - apps/server/src/volModels/integration/volModelService.ts (7330 bytes)
 - apps/server/src/volModels/invariants.ts (666 bytes)
 - apps/server/src/volModels/marketScenarios.ts (5306 bytes)
 - apps/server/src/volModels/multiTradeTest.ts (6454 bytes)
 - apps/server/src/volModels/pricing/blackScholes.ts (5149 bytes)
 - apps/server/src/volModels/quoteEngineAdapter.ts (8486 bytes)
 - apps/server/src/volModels/runTests.ts (219 bytes)
 - apps/server/src/volModels/simpleAdapter.ts (3031 bytes)
 - apps/server/src/volModels/simpleDiagnostic.ts (2606 bytes)
 - apps/server/src/volModels/simpleMultiTrade.ts (3761 bytes)
 - apps/server/src/volModels/smileAdjuster.ts (7149 bytes)
 - apps/server/src/volModels/smileInventoryController.ts (5833 bytes)
 - apps/server/src/volModels/sviMapping.ts (1237 bytes)
 - apps/server/src/volModels/testInventory.ts (5138 bytes)
 - apps/server/src/volModels/testQuoteAdapter.ts (1761 bytes)
 - apps/server/src/volModels/testSmileSimple.ts (2435 bytes)
 - apps/server/src/volModels/tests/bs.test.ts (1240 bytes)
 - apps/server/src/volModels/tests/bucket.test.ts (456 bytes)
 - apps/server/src/volModels/tests/integratedSmileModel.test.ts (1498 bytes)
 - apps/server/src/volModels/tests/smokeQuoteTrade.test.ts (980 bytes)
 - apps/server/src/volModels/tests/testDualSurface.ts (7739 bytes)
 - apps/server/src/volModels/tests/volModelService.test.ts (636 bytes)
 - apps/server/src/volModels/types.ts (598 bytes)
 - src/components/VolController.jsx (10613 bytes)
 - src/components/ui/button.jsx (1435 bytes)
 - src/components/ui/card.jsx (1501 bytes)
 - src/components/ui/input.jsx (686 bytes)
 - src/components/ui/label.jsx (373 bytes)
 - src/components/ui/slider.jsx (385 bytes)
 - src/lib/utils.js (85 bytes)
 - src/screens/PnL.jsx (15990 bytes)
 - src/screens/QuoteModel.jsx (13096 bytes)
 - src/screens/Risk.jsx (15692 bytes)
 - src/screens/TestSimulation.jsx (15591 bytes)
 - src/screens/VolModel.jsx (1096 bytes)
 - src/types/index.ts (6243 bytes)
 - src/utils/pricing.ts (9147 bytes)

===== BEGIN FILE CONTENTS =====

---------- BEGIN apps/server/apps/server/src/logging/tradeLog.ts (bytes=863) ----------
import fs from "fs";
import path from "path";

const LOG_DIR = path.resolve("data");
const LOG_FILE = path.join(LOG_DIR, "trades.jsonl");

export type TradeRow = {
  ts: number;
  symbol: string;
  F: number;
  K: number;
  expiryMs: number;
  side: "BUY" | "SELL";
  qty: number;
  ccMid: number;
  pcMid: number;
  tradePx: number;
  dotLamG?: number;
  I_before?: number[];
  I_after?: number[];
  lambda?: number[];
  pnl_est: number;
  signal_tags?: string[];
};

export class TradeLog {
  static write(row: TradeRow) {
    // Create directory if it doesn't exist
    if (!fs.existsSync(LOG_DIR)) {
      fs.mkdirSync(LOG_DIR, { recursive: true });
    }
    
    // Append trade as JSON line
    fs.appendFileSync(LOG_FILE, JSON.stringify(row) + "\n");
  }
  
  static clear() {
    if (fs.existsSync(LOG_FILE)) {
      fs.unlinkSync(LOG_FILE);
    }
  }
}

---------- END apps/server/apps/server/src/logging/tradeLog.ts ----------

---------- BEGIN apps/server/src/__tests__/golden.test.ts (bytes=7420) ----------
// apps/server/src/__tests__/golden.test.ts
/**
 * Phase 1: Golden snapshot tests for deterministic backtests
 * 
 * These tests ensure:
 * 1. Backtest results are deterministic
 * 2. Code changes don't silently change PnL
 * 3. All numeric operations are stable
 */

import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

// Import your backtest runner (adjust path)
// import { runBacktest } from '../backtest';

type BacktestResult = {
  finalPnL: number;
  numTrades: number;
  numQuotes: number;
  maxInventoryUtil: number;
  avgSpread: number;
  factorVersion: number;
  configHash: string;
};

/**
 * Compute deterministic hash of backtest results
 */
function hashBacktestResult(result: BacktestResult): string {
  // Sort keys for determinism
  const sorted: any = {};
  Object.keys(result).sort().forEach(key => {
    sorted[key] = (result as any)[key];
  });
  
  const json = JSON.stringify(sorted, null, 2);
  return crypto.createHash('sha256').update(json).digest('hex');
}

/**
 * Serialize backtest for human-readable diff
 */
function serializeBacktest(result: BacktestResult): string {
  return [
    `Factor Version: ${result.factorVersion}`,
    `Config Hash: ${result.configHash}`,
    `Final PnL: ${result.finalPnL.toFixed(2)}`,
    `Trades: ${result.numTrades}`,
    `Quotes: ${result.numQuotes}`,
    `Max Inventory Util: ${result.maxInventoryUtil.toFixed(4)}`,
    `Avg Spread: ${result.avgSpread.toFixed(4)}`,
  ].join('\n');
}

/**
 * Load golden snapshot from disk
 */
function loadGolden(name: string): { hash: string; content: string } | null {
  const dir = path.join(__dirname, '../../data/golden');
  const hashPath = path.join(dir, `${name}.sha256`);
  const contentPath = path.join(dir, `${name}.txt`);
  
  if (!fs.existsSync(hashPath) || !fs.existsSync(contentPath)) {
    return null;
  }
  
  return {
    hash: fs.readFileSync(hashPath, 'utf8').trim(),
    content: fs.readFileSync(contentPath, 'utf8'),
  };
}

/**
 * Save golden snapshot to disk
 */
function saveGolden(name: string, hash: string, content: string): void {
  const dir = path.join(__dirname, '../../data/golden');
  
  // Create directory if it doesn't exist
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
  
  fs.writeFileSync(path.join(dir, `${name}.sha256`), hash);
  fs.writeFileSync(path.join(dir, `${name}.txt`), content);
}

describe('Golden Backtest Tests', () => {
  describe('Determinism', () => {
    it('should produce identical results across runs', () => {
      // Run backtest twice with same seed
      // const result1 = runBacktest({ seed: 42, days: 1 });
      // const result2 = runBacktest({ seed: 42, days: 1 });
      
      // Placeholder for now
      const result1: BacktestResult = {
        finalPnL: 1234.56,
        numTrades: 42,
        numQuotes: 1000,
        maxInventoryUtil: 0.75,
        avgSpread: 0.0025,
        factorVersion: 1,
        configHash: 'abc123',
      };
      
      const result2 = { ...result1 };
      
      const hash1 = hashBacktestResult(result1);
      const hash2 = hashBacktestResult(result2);
      
      expect(hash1).toBe(hash2);
    });
  });
  
  describe('Golden Snapshot', () => {
    const TEST_NAME = 'backtest_1day_seed42';
    
    it('should match golden snapshot', () => {
      // Run backtest
      // const result = runBacktest({ seed: 42, days: 1 });
      
      // Placeholder
      const result: BacktestResult = {
        finalPnL: 1234.56,
        numTrades: 42,
        numQuotes: 1000,
        maxInventoryUtil: 0.75,
        avgSpread: 0.0025,
        factorVersion: 1,
        configHash: 'abc123',
      };
      
      const hash = hashBacktestResult(result);
      const content = serializeBacktest(result);
      
      const golden = loadGolden(TEST_NAME);
      
      if (!golden) {
        // First run - save golden
        console.log(`[Golden] Creating new snapshot: ${TEST_NAME}`);
        saveGolden(TEST_NAME, hash, content);
        
        // Mark test as pending so it doesn't pass on first run
        console.warn('Golden snapshot created. Run tests again to validate.');
        return;
      }
      
      // Compare hash
      if (hash !== golden.hash) {
        console.log('=== Expected ===');
        console.log(golden.content);
        console.log('\n=== Actual ===');
        console.log(content);
        console.log('\n=== Hash Mismatch ===');
        console.log(`Expected: ${golden.hash}`);
        console.log(`Actual:   ${hash}`);
        
        throw new Error(
          `Golden snapshot mismatch for ${TEST_NAME}. ` +
          `If this change is intentional, delete the golden file and re-run tests.`
        );
      }
      
      expect(hash).toBe(golden.hash);
    });
  });
  
  describe('Numeric Stability', () => {
    it('should handle extreme inventory without NaN', () => {
      // Test with large inventory vector
      const largeInventory = new Array(6).fill(1000);
      
      // Should not produce NaN in any calculation
      // const result = computeRisk(largeInventory, ...);
      // expect(Number.isFinite(result.skew)).toBe(true);
      // expect(Number.isFinite(result.spread)).toBe(true);
      
      expect(true).toBe(true); // Placeholder
    });
    
    it('should handle tiny spreads without division by zero', () => {
      // Test with near-zero greeks
      const tinyGreeks = new Array(6).fill(1e-10);
      
      // Should not crash or produce Infinity
      // const size = computeSize(tinyGreeks, ...);
      // expect(Number.isFinite(size)).toBe(true);
      // expect(size).toBeLessThanOrEqual(qMax);
      
      expect(true).toBe(true); // Placeholder
    });
    
    it('should be deterministic with sorted accumulation', () => {
      const values = { c: 3, a: 1, b: 2 };
      
      // Deterministic sum (sorted keys)
      const keys = Object.keys(values).sort();
      const sum = keys.reduce((acc, k) => acc + values[k], 0);
      
      expect(sum).toBe(6);
      
      // Should be same regardless of insertion order
      const values2 = { b: 2, c: 3, a: 1 };
      const keys2 = Object.keys(values2).sort();
      const sum2 = keys2.reduce((acc, k) => acc + values2[k], 0);
      
      expect(sum2).toBe(sum);
    });
  });
  
  describe('Factor Registry Validation', () => {
    it('should have consistent dimension', () => {
      // Import your registry
      // import { d, FACTORS, FACTOR_LABELS } from '../risk/factors';
      
      const d = 6; // Placeholder
      const FACTOR_LABELS = ['F', 'Gamma', 'VegaATM', 'Skew', 'Wing', 'Term'];
      
      expect(FACTOR_LABELS.length).toBe(d);
    });
    
    it('should have unique labels', () => {
      const labels = ['F', 'Gamma', 'VegaATM', 'Skew', 'Wing', 'Term'];
      const unique = new Set(labels);
      
      expect(unique.size).toBe(labels.length);
    });
  });
});

/**
 * CI Integration:
 * 
 * Add to package.json:
 * {
 *   "scripts": {
 *     "test:golden": "jest golden.test.ts",
 *     "verify": "npm ci && npm run test:golden"
 *   }
 * }
 * 
 * Add to .github/workflows/ci.yml:
 * 
 * - name: Run golden tests
 *   run: npm run test:golden
 * 
 * - name: Check golden artifacts
 *   run: |
 *     git diff --exit-code data/golden/
 *     if [ $? -ne 0 ]; then
 *       echo "Golden artifacts changed! Review changes and commit if intentional."
 *       exit 1
 *     fi
 */
---------- END apps/server/src/__tests__/golden.test.ts ----------

---------- BEGIN apps/server/src/api/routes/http.ts (bytes=8313) ----------
// apps/server/src/api/http.ts
/**
 * Phase 2: HTTP and WebSocket API endpoints
 * 
 * Routes:
 * - GET  /quotes       - Current quote state
 * - GET  /positions    - Current inventory
 * - GET  /pnl          - PnL breakdown
 * - GET  /risk         - Risk diagnostics (Σ, Λ, condition numbers)
 * - GET  /events       - Recent events/warnings
 * - WS   /stream       - Real-time updates
 */

import express, { Request, Response } from 'express';
import { WebSocketServer, WebSocket } from 'ws';
import { Server } from 'http';

// Import your services (adjust paths as needed)
import { SigmaService } from '../risk/SigmaService';
import { FactorRisk } from '../risk/FactorRisk';
import { FACTORS, FACTOR_LABELS, d } from '../risk/factors';

// Placeholder types - replace with your actual types
type QuoteState = {
  ts: number;
  quotes: Array<{
    symbol: string;
    bid: number;
    ask: number;
    sizeBid: number;
    sizeAsk: number;
    spread: number;
    skew: number;
    invUtil: number;
  }>;
};

type PositionState = {
  ts: number;
  positions: Array<{
    symbol: string;
    qty: number;
    notional: number;
    vega: number;
    gamma: number;
  }>;
  inventory: {
    labels: string[];
    values: number[];
  };
  lambda: {
    labels: string[];
    values: number[];
  };
  utilization: number;
};

type PnLState = {
  ts: number;
  realized: number;
  unrealized: number;
  total: number;
  breakdown: {
    edge: number;
    carry: number;
    fees: number;
    slippage: number;
    residual: number;
  };
};

type RiskState = {
  ts: number;
  factorVersion: number;
  sigma: {
    labels: string[];
    matrix: number[][];
    trace: number;
    conditionNumber: number;
    isPD: boolean;
    eigenvalues?: number[];
  };
  lambda: {
    conditionNumber: number;
    maxNorm: number;
  };
  config: {
    gamma: number;
    z: number;
    eta: number;
    kappa: number;
    L: number;
  };
};

type EventRecord = {
  ts: number;
  level: string;
  code: string;
  message: string;
  meta?: any;
};

/**
 * API Service - manages state and exposes endpoints
 */
export class APIService {
  private app: express.Application;
  private wss: WebSocketServer | null = null;
  private clients: Set<WebSocket> = new Set();
  
  // Service dependencies (inject these)
  private sigmaService: SigmaService;
  private factorRisk: FactorRisk;
  
  // In-memory state (replace with your actual state management)
  private currentQuotes: QuoteState;
  private currentPositions: PositionState;
  private currentPnL: PnLState;
  private recentEvents: EventRecord[] = [];
  
  constructor(
    sigmaService: SigmaService,
    factorRisk: FactorRisk
  ) {
    this.sigmaService = sigmaService;
    this.factorRisk = factorRisk;
    
    this.app = express();
    this.app.use(express.json());
    
    // Initialize empty state
    this.currentQuotes = { ts: Date.now(), quotes: [] };
    this.currentPositions = {
      ts: Date.now(),
      positions: [],
      inventory: { labels: [], values: [] },
      lambda: { labels: [], values: [] },
      utilization: 0,
    };
    this.currentPnL = {
      ts: Date.now(),
      realized: 0,
      unrealized: 0,
      total: 0,
      breakdown: { edge: 0, carry: 0, fees: 0, slippage: 0, residual: 0 },
    };
    
    this.setupRoutes();
  }
  
  private setupRoutes(): void {
    // Health check
    this.app.get('/health', (req: Request, res: Response) => {
      res.json({ status: 'ok', ts: Date.now() });
    });
    
    // Quotes
    this.app.get('/quotes', (req: Request, res: Response) => {
      res.json(this.currentQuotes);
    });
    
    // Positions
    this.app.get('/positions', (req: Request, res: Response) => {
      res.json(this.currentPositions);
    });
    
    // PnL
    this.app.get('/pnl', (req: Request, res: Response) => {
      res.json(this.currentPnL);
    });
    
    // Risk diagnostics
    this.app.get('/risk', (req: Request, res: Response) => {
      const risk = this.getRiskState();
      res.json(risk);
    });
    
    // Events
    this.app.get('/events', (req: Request, res: Response) => {
      const limit = parseInt(req.query.limit as string) || 100;
      const level = req.query.level as string | undefined;
      
      let events = this.recentEvents;
      if (level) {
        events = events.filter(e => e.level === level);
      }
      
      res.json({
        ts: Date.now(),
        events: events.slice(-limit),
      });
    });
    
    // Factor registry info
    this.app.get('/factors', (req: Request, res: Response) => {
      res.json({
        version: FACTORS.version,
        dimension: d,
        factors: FACTORS.specs.map(s => ({
          label: s.label,
          unit: s.unit,
          description: s.description,
          enabled: s.enabled ?? true,
        })),
      });
    });
  }
  
  /**
   * Start HTTP server
   */
  start(port: number): Server {
    const server = this.app.listen(port, () => {
      console.log(`[API] HTTP server listening on port ${port}`);
    });
    
    // Setup WebSocket
    this.wss = new WebSocketServer({ server });
    this.wss.on('connection', (ws: WebSocket) => {
      console.log('[API] WebSocket client connected');
      this.clients.add(ws);
      
      // Send initial state
      ws.send(JSON.stringify({
        type: 'snapshot',
        quotes: this.currentQuotes,
        positions: this.currentPositions,
        pnl: this.currentPnL,
      }));
      
      ws.on('close', () => {
        console.log('[API] WebSocket client disconnected');
        this.clients.delete(ws);
      });
      
      ws.on('error', (err) => {
        console.error('[API] WebSocket error:', err);
        this.clients.delete(ws);
      });
    });
    
    return server;
  }
  
  /**
   * Update state and broadcast to clients
   */
  updateQuotes(quotes: QuoteState): void {
    this.currentQuotes = quotes;
    this.broadcast({ type: 'quotes', data: quotes });
  }
  
  updatePositions(positions: PositionState): void {
    this.currentPositions = positions;
    this.broadcast({ type: 'positions', data: positions });
  }
  
  updatePnL(pnl: PnLState): void {
    this.currentPnL = pnl;
    this.broadcast({ type: 'pnl', data: pnl });
  }
  
  addEvent(event: EventRecord): void {
    this.recentEvents.push(event);
    
    // Keep only last 1000 events in memory
    if (this.recentEvents.length > 1000) {
      this.recentEvents = this.recentEvents.slice(-1000);
    }
    
    this.broadcast({ type: 'event', data: event });
  }
  
  private broadcast(message: any): void {
    const payload = JSON.stringify(message);
    for (const client of this.clients) {
      if (client.readyState === WebSocket.OPEN) {
        client.send(payload);
      }
    }
  }
  
  private getRiskState(): RiskState {
    const sigmaStats = this.sigmaService.getStats();
    const sigma = this.sigmaService.getSigma();
    const Lambda = this.factorRisk.getLambda();
    
    let lambdaCondition = 1;
    let lambdaMaxNorm = 0;
    if (Lambda) {
      // Compute Lambda diagnostics (simplified)
      lambdaCondition = sigmaStats.conditionNumber; // Approximation
      for (let i = 0; i < d; i++) {
        lambdaMaxNorm = Math.max(lambdaMaxNorm, Lambda[i][i]);
      }
    }
    
    return {
      ts: Date.now(),
      factorVersion: FACTORS.version,
      sigma: {
        labels: [...FACTOR_LABELS],
        matrix: sigma.matrix,
        trace: sigmaStats.traceValue,
        conditionNumber: sigmaStats.conditionNumber,
        isPD: sigmaStats.isPD,
      },
      lambda: {
        conditionNumber: lambdaCondition,
        maxNorm: lambdaMaxNorm,
      },
      config: {
        gamma: 1.0, // TODO: Get from config
        z: 1.0,
        eta: 1.0,
        kappa: 0.5,
        L: 1.0,
      },
    };
  }
}

/**
 * Example usage:
 * 
 * const sigmaService = new SigmaService(sigmaConfig);
 * const factorRisk = new FactorRisk(riskConfig);
 * const api = new APIService(sigmaService, factorRisk);
 * 
 * api.start(3000);
 * 
 * // In your main loop:
 * api.updateQuotes({ ts: Date.now(), quotes: [...] });
 * api.updatePositions({ ts: Date.now(), positions: [...], ... });
 * api.updatePnL({ ts: Date.now(), realized: 100, ... });
 * api.addEvent({ ts: Date.now(), level: 'warn', code: 'SIGMA_ILL_CONDITIONED', message: '...' });
 */
---------- END apps/server/src/api/routes/http.ts ----------

---------- BEGIN apps/server/src/api/routes/pnl.ts (bytes=796) ----------
import { FastifyInstance } from "fastify";
import fs from "fs";
import path from "path";

export async function pnlRoutes(f: FastifyInstance) {
  f.get("/pnl/summary", async (_req, _rep) => {
    const file = path.resolve("data/trades.jsonl");
    if (!fs.existsSync(file)) {
      return { count: 0, totalEdge: 0, avgEdge: 0 };
    }
    
    const lines = fs.readFileSync(file, "utf8").trim().split("\n");
    let totalEdge = 0;
    
    for (const ln of lines) {
      try {
        const r = JSON.parse(ln);
        totalEdge += r.pnl_est ?? 0;
      } catch {}
    }
    
    return {
      count: lines.length,
      totalEdge: parseFloat(totalEdge.toFixed(2)),
      avgEdge: lines.length ? parseFloat((totalEdge / lines.length).toFixed(4)) : 0,
      timestamp: Date.now()
    };
  });
}

---------- END apps/server/src/api/routes/pnl.ts ----------

---------- BEGIN apps/server/src/api/routes/risk.ts (bytes=526) ----------
import { FastifyInstance } from "fastify";
import { volService } from "../../volModels/integration/volModelService";

export async function riskRoutes(f: FastifyInstance) {
  f.get("/risk/factors", async (req, rep) => {
    const { symbol = "BTC" } = (req.query as any) ?? {};
    const factors = volService.getFactorInventory(symbol);
    return {
      symbol,
      inventory: factors.inventory,
      lambda: factors.lambda,
      lambdaDotInventory: factors.lambdaDotInventory,
      timestamp: Date.now()
    };
  });
}

---------- END apps/server/src/api/routes/risk.ts ----------

---------- BEGIN apps/server/src/config/index.ts (bytes=7492) ----------
// apps/server/src/config/index.ts
/**
 * Centralized configuration with validation and hashing
 * 
 * Safe defaults for Phase 2 Week 1 (conservative risk)
 * Tuning knobs exposed for Week 2
 */

import * as crypto from 'crypto';
import { SigmaConfig } from '../risk/SigmaService';
import { RiskConfig } from '../risk/FactorRisk';

export type AppConfig = {
  // Environment
  env: 'development' | 'staging' | 'production';
  apiPort: number;
  
  // Logging
  logLevel: 'debug' | 'info' | 'warn' | 'error';
  logToFile: boolean;
  logPath?: string;
  
  // Database
  databaseUrl: string;
  
  // Risk parameters (FactorRisk)
  risk: RiskConfig;
  
  // Covariance estimation (SigmaService)
  sigma: SigmaConfig;
  
  // Quote engine
  quoting: {
    symbols: string[];
    tickMs: number;              // How often to requote
    
    // Microstructure vol per symbol (will be computed online)
    sigmaMD: Record<string, number>;
  };
  
  // Simulation (if using SimAdapter)
  simulation?: {
    enabled: boolean;
    seed: number;
    initialF: number;
    ouMean: number;
    ouTheta: number;
    ouSigma: number;
    tickMs: number;
    fillProbBase: number;
    fillProbSpreadDecay: number;
    fillProbSizeDecay: number;
    slippageBps: number;
    
    // Shock tests
    shockSchedule?: Array<{
      timeMs: number;
      deltaF?: number;
      deltaSkew?: number;
    }>;
  };
};

/**
 * Phase 2 Week 1: Safe defaults
 * - γ=1.0 (adjust after observing PnL vol)
 * - z=0, η=0, κ=0 (no model/noise/inv spreads yet)
 * - Day 6: turn on z=1.0, η=1.0, κ=0.5
 */
export const SAFE_DEFAULTS: AppConfig = {
  env: 'development',
  apiPort: 3000,
  
  logLevel: 'info',
  logToFile: false,
  
  databaseUrl: process.env.DATABASE_URL || 'postgresql://localhost:5432/optionmm',
  
  risk: {
    gamma: 1.0,                // Week 1 Day 1-5
    z: 0.0,                    // Turn to 1.0 on Day 6
    eta: 0.0,                  // Turn to 1.0 on Day 6
    kappa: 0.0,                // Turn to 0.5 on Day 6
    L: 1.0,                    // Inventory limit (Λ-norm)
    ridgeEpsilon: 1e-5,
    feeBuffer: 0.50,           // $0.50 per contract + 1 tick
    qMax: 10,                  // Max 10 contracts per side
    minEdge: 0.10,             // Min $0.10 edge before quoting
  },
  
  sigma: {
    horizonMs: 1000,           // 1s factor shocks
    alpha: 0.05,               // EWMA decay
    ridgeEpsilon: 1e-5,
    minSamples: 50,            // Need 50 samples before Σ is "ready"
    
    // Multi-horizon blending (optional, Day 9)
    // blendHorizons: [
    //   { horizonMs: 250, weight: 0.5 },
    //   { horizonMs: 2000, weight: 0.5 },
    // ],
  },
  
  quoting: {
    symbols: [
      'BTC-25DEC25-50000-C',
      'BTC-25DEC25-50000-P',
      // Add more as needed
    ],
    tickMs: 1000,              // Requote every 1s
    sigmaMD: {
      'BTC-25DEC25-50000-C': 0.002,  // 20 bps microstructure vol
      'BTC-25DEC25-50000-P': 0.002,
    },
  },
  
  simulation: {
    enabled: true,
    seed: 42,
    initialF: 50000,
    ouMean: 50000,
    ouTheta: 0.1,
    ouSigma: 0.02,
    tickMs: 1000,
    fillProbBase: 0.1,
    fillProbSpreadDecay: 0.5,
    fillProbSizeDecay: 0.3,
    slippageBps: 1.0,
  },
};

/**
 * Phase 2 Week 2: Tuned config (after calibration)
 * Use this as a template after Day 8 γ calibration
 */
export const WEEK2_TUNED: Partial<AppConfig> = {
  risk: {
    gamma: 2.0,                // Adjusted after PnL vol calibration
    z: 1.0,                    // Model spread ON
    eta: 1.0,                  // Microstructure spread ON
    kappa: 0.5,                // Inventory widening ON
    L: 1.0,
    ridgeEpsilon: 1e-5,
    feeBuffer: 0.50,
    qMax: 10,
    minEdge: 0.10,
  },
  
  sigma: {
    horizonMs: 1000,
    alpha: 0.05,
    ridgeEpsilon: 1e-5,
    minSamples: 50,
    
    // Multi-horizon blending (Day 9)
    blendHorizons: [
      { horizonMs: 250, weight: 0.5 },
      { horizonMs: 2000, weight: 0.5 },
    ],
  },
};

/**
 * Compute deterministic hash of config
 * Used for golden tests and run tracking
 */
export function hashConfig(config: AppConfig): string {
  // Sort keys recursively
  const sortObj = (obj: any): any => {
    if (Array.isArray(obj)) {
      return obj.map(sortObj);
    }
    if (obj !== null && typeof obj === 'object') {
      return Object.keys(obj)
        .sort()
        .reduce((result, key) => {
          result[key] = sortObj(obj[key]);
          return result;
        }, {} as any);
    }
    return obj;
  };
  
  const sorted = sortObj(config);
  const json = JSON.stringify(sorted);
  return crypto.createHash('sha256').update(json).digest('hex').slice(0, 16);
}

/**
 * Validate config (throws on invalid)
 */
export function validateConfig(config: AppConfig): void {
  // Risk validation
  if (config.risk.gamma <= 0) {
    throw new Error('risk.gamma must be positive');
  }
  if (config.risk.z < 0 || config.risk.eta < 0 || config.risk.kappa < 0) {
    throw new Error('risk.z, eta, kappa must be non-negative');
  }
  if (config.risk.L <= 0) {
    throw new Error('risk.L must be positive');
  }
  if (config.risk.qMax <= 0) {
    throw new Error('risk.qMax must be positive');
  }
  
  // Sigma validation
  if (config.sigma.horizonMs <= 0) {
    throw new Error('sigma.horizonMs must be positive');
  }
  if (config.sigma.alpha <= 0 || config.sigma.alpha >= 1) {
    throw new Error('sigma.alpha must be in (0, 1)');
  }
  if (config.sigma.minSamples < 1) {
    throw new Error('sigma.minSamples must be at least 1');
  }
  
  // Blending validation
  if (config.sigma.blendHorizons) {
    const totalWeight = config.sigma.blendHorizons.reduce((s, h) => s + h.weight, 0);
    if (Math.abs(totalWeight - 1.0) > 1e-6) {
      throw new Error(`sigma.blendHorizons weights must sum to 1.0, got ${totalWeight}`);
    }
  }
  
  // Quoting validation
  if (config.quoting.symbols.length === 0) {
    throw new Error('quoting.symbols must not be empty');
  }
  if (config.quoting.tickMs <= 0) {
    throw new Error('quoting.tickMs must be positive');
  }
}

/**
 * Load config from environment and merge with defaults
 */
export function loadConfig(): AppConfig {
  const config: AppConfig = {
    ...SAFE_DEFAULTS,
    
    // Override from env
    env: (process.env.NODE_ENV as any) || 'development',
    apiPort: parseInt(process.env.API_PORT || '3000'),
    databaseUrl: process.env.DATABASE_URL || SAFE_DEFAULTS.databaseUrl,
    
    // Allow override of key risk params via env (for testing)
    risk: {
      ...SAFE_DEFAULTS.risk,
      gamma: parseFloat(process.env.RISK_GAMMA || String(SAFE_DEFAULTS.risk.gamma)),
      z: parseFloat(process.env.RISK_Z || String(SAFE_DEFAULTS.risk.z)),
      eta: parseFloat(process.env.RISK_ETA || String(SAFE_DEFAULTS.risk.eta)),
      kappa: parseFloat(process.env.RISK_KAPPA || String(SAFE_DEFAULTS.risk.kappa)),
    },
  };
  
  validateConfig(config);
  
  return config;
}

/**
 * Config evolution schedule (for systematic tuning)
 * 
 * Week 1:
 * - Day 1-5: SAFE_DEFAULTS (γ=1.0, z=0, η=0, κ=0)
 * - Day 6-7: Turn on z=1.0, η=1.0, κ=0.5
 * 
 * Week 2:
 * - Day 8: Calibrate γ to target PnL vol
 * - Day 9: Add multi-horizon blending
 * - Day 10: Run shock tests
 */
export const CONFIG_SCHEDULE = {
  week1: {
    day1to5: SAFE_DEFAULTS,
    day6to7: {
      ...SAFE_DEFAULTS,
      risk: {
        ...SAFE_DEFAULTS.risk,
        z: 1.0,
        eta: 1.0,
        kappa: 0.5,
      },
    },
  },
  week2: WEEK2_TUNED,
};
---------- END apps/server/src/config/index.ts ----------

---------- BEGIN apps/server/src/engine/PriceCalculus.ts (bytes=3527) ----------
// server/src/engine/PriceCalculus.ts
//
// Unifying calculus for PC mid and widths: pcMid = ccMid + dot(lambda, g)
// width = w0 + alpha * |dot(lambda, g)| (+ optional inventory pressure)
// Produces bid/ask; logs useful diagnostics.

import fs from "fs";
import path from "path";
import * as yaml from "js-yaml";
import {
  FactorIndex,
  Theta,
  PriceFn,
  finiteDiffGreeks,
  dot,
} from "../risk/FactorSpace";

export type Instrument = {
  symbol: string;
  strike: number;
  expiryMs: number;
  optionType: "C" | "P";
};

type RiskConfig = {
  lambda: Partial<Record<keyof typeof FactorIndex | string, number>> | number[];
  widths: { w0: number; alpha: number; beta?: number };
};

type SymbolRiskConfig = Record<string, RiskConfig>;

function loadRiskConfig(): SymbolRiskConfig {
  const p = path.resolve(process.cwd(), "src/config/risk.factors.yaml");
  if (!fs.existsSync(p)) {
    // default fallback config (BTC only)
    return {
      BTC: {
        lambda: [0.5, 0.2, 0.1, 0.15, 0.1, 0.3],
        widths: { w0: 2.0, alpha: 1.0, beta: 0.0 },
      },
    };
  }
  const doc = yaml.load(fs.readFileSync(p, "utf8")) as any;
  return doc as SymbolRiskConfig;
}

const RISK = loadRiskConfig();

function symbolLambda(symbol: string): number[] {
  const s = RISK[symbol];
  if (!s) return [0.5, 0.2, 0.1, 0.15, 0.1, 0.3];
  if (Array.isArray(s.lambda)) return s.lambda as number[];
  // allow object mapping, e.g. { L0: 0.5, S0: 0.2, ... }
  const m = s.lambda as Record<string, number>;
  const arr = new Array(6).fill(0);
  arr[FactorIndex.L0] = m.L0 ?? m["0"] ?? 0.5;
  arr[FactorIndex.S0] = m.S0 ?? m["1"] ?? 0.2;
  arr[FactorIndex.C0] = m.C0 ?? m["2"] ?? 0.1;
  arr[FactorIndex.Sneg] = m.Sneg ?? m["3"] ?? 0.15;
  arr[FactorIndex.Spos] = m.Spos ?? m["4"] ?? 0.1;
  arr[FactorIndex.F] = m.F ?? m["5"] ?? 0.3;
  return arr;
}

function symbolWidths(symbol: string) {
  const s = RISK[symbol];
  return s?.widths ?? { w0: 2.0, alpha: 1.0, beta: 0.0 };
}

export type PcQuote = {
  ccMid: number;
  pcMid: number;
  width: number;
  bid: number;
  ask: number;
  g: number[];
  dotLambdaG: number;
};

export type PricingDeps<I> = {
  // Return the *core* mid (CC) at current thetaCC for instrument
  ccMid: (inst: I) => number;
  // Price with arbitrary theta (for finite diffs). You adapt this to your model.
  priceWithTheta: PriceFn<I>;
  // Current θ for CC: [L0,S0,C0,Sneg,Spos,F]
  thetaCC: () => Theta;
  // Optional: return a scalar inventory pressure in [0, +∞) to widen spreads
  inventoryPenalty?: () => number; // start with () => 0
};

/**
 * Main entry: given an instrument and the deps (adapters to your CC model),
 * compute pcMid, width, bid, ask, and diagnostics.
 */
export function computePcQuote<I extends Instrument>(
  inst: I,
  deps: PricingDeps<I>
): PcQuote {
  const lambda = symbolLambda(inst.symbol);
  const widths = symbolWidths(inst.symbol);

  const theta = deps.thetaCC();
  const ccMid = deps.ccMid(inst);

  // factor greeks via finite-diff around CC theta
  const g = finiteDiffGreeks(deps.priceWithTheta, theta, inst);
  const lg = dot(lambda, g);

  // pricing curve mid
  const pcMid = ccMid + lg;

  // width = base + priced risk + optional inventory penalty
  const invPen = Math.max(0, deps.inventoryPenalty?.() ?? 0);
  const width = Math.max(0, widths.w0 + widths.alpha * Math.abs(lg) + invPen);

  const bid = Math.max(0, pcMid - width);
  const ask = pcMid + width;

  return {
    ccMid,
    pcMid,
    width,
    bid,
    ask,
    g,
    dotLambdaG: lg,
  };
}

---------- END apps/server/src/engine/PriceCalculus.ts ----------

---------- BEGIN apps/server/src/engine/QuoteEngine.ts (bytes=7536) ----------
// apps/server/src/engine/QuoteEngine.ts
/**
 * Phase 2 Week 1 Day 3: QuoteEngine integration with FactorRisk
 * 
 * Orchestrates:
 * 1. Factor greeks computation
 * 2. Risk calculations (skew, spread, size)
 * 3. Quote generation
 */

import { d, FactorVector } from '../risk/factors';
import { FactorRisk, QuoteParams } from '../risk/FactorRisk';
import { SigmaService } from '../risk/SigmaService';
import { factorGreeksFor, Instrument, MarketContext } from '../risk/factorGreeksLoader';

export type QuoteEngineConfig = {
  symbols: string[];           // Which instruments to quote
  
  // Microstructure vol per symbol (σ_md)
  // You'll compute this via EWMA of mid returns @ 100-300ms
  sigmaMD: Record<string, number>;
  
  // Edge targets per instrument type
  edgeTargets: {
    atm: number;               // e.g. 0.5 per lot
    otm: number;               // e.g. 1.0 per lot
    wing: number;              // e.g. 1.5 per lot
  };
};

export type QuoteOutput = {
  symbol: string;
  strike: number;
  expiryMs: number;
  
  // Prices
  theoRaw: number;
  theoInv: number;
  bid: number;
  ask: number;
  
  // Sizes
  sizeBid: number;
  sizeAsk: number;
  
  // Diagnostics
  skew: number;
  spread: number;
  spreadComponents: {
    fee: number;
    noise: number;
    model: number;
    inventory: number;
  };
  
  // Risk
  gLambdaG: number;
  invUtil: number;
  
  // Metadata
  g: number[];               // Factor greeks
  factorContributions?: number[];
};

export class QuoteEngine {
  private config: QuoteEngineConfig;
  private factorRisk: FactorRisk;
  private sigmaService: SigmaService;
  
  // Current portfolio state
  private inventory: number[];  // I vector (d-dimensional)
  
  constructor(
    config: QuoteEngineConfig,
    factorRisk: FactorRisk,
    sigmaService: SigmaService
  ) {
    this.config = config;
    this.factorRisk = factorRisk;
    this.sigmaService = sigmaService;
    
    // Initialize zero inventory
    this.inventory = new Array(d).fill(0);
  }
  
  /**
   * Update inventory (call after each trade)
   */
  updateInventory(inventory: number[]): void {
    if (inventory.length !== d) {
      throw new Error(`Inventory dimension mismatch: expected ${d}, got ${inventory.length}`);
    }
    this.inventory = [...inventory];
  }
  
  /**
   * Main entry point: compute all quotes
   * 
   * @param instruments - List of instruments to quote
   * @param ctx - Market context (spot, vol surface, etc.)
   * @param theos - Pre-computed theoretical values per instrument
   * @param mids - Current market mids per instrument
   * @returns Array of quotes
   */
  computeQuotes(
    instruments: Instrument[],
    ctx: MarketContext,
    theos: Map<string, number>,
    mids: Map<string, number>
  ): QuoteOutput[] {
    // Update risk state with current Σ and I
    const Sigma = this.sigmaService.getSigmaRaw();
    this.factorRisk.updateState(Sigma, this.inventory);
    
    const quotes: QuoteOutput[] = [];
    
    for (const instr of instruments) {
      // Skip if not in our universe
      if (!this.config.symbols.includes(instr.symbol)) continue;
      
      // Get theoretical mid
      const theoRaw = theos.get(instr.symbol);
      if (theoRaw === undefined) continue;
      
      // Get current market mid
      const mid = mids.get(instr.symbol) ?? theoRaw;
      
      // Compute factor greeks
      const g = factorGreeksFor(instr, ctx);
      
      // Get microstructure vol
      const sigmaMD = this.config.sigmaMD[instr.symbol] ?? 0.001;
      
      // Compute quote params via FactorRisk
      const params = this.factorRisk.computeQuote(g, theoRaw, sigmaMD, mid);
      
      // Package output
      quotes.push({
        symbol: instr.symbol,
        strike: instr.strike,
        expiryMs: instr.expiryMs,
        
        theoRaw: params.theoRaw,
        theoInv: params.theoInv,
        bid: params.bid,
        ask: params.ask,
        
        sizeBid: params.sizeBid,
        sizeAsk: params.sizeAsk,
        
        skew: params.skew,
        spread: params.spreadComponents.total,
        spreadComponents: {
          fee: params.spreadComponents.fee,
          noise: params.spreadComponents.noise,
          model: params.spreadComponents.model,
          inventory: params.spreadComponents.inventory,
        },
        
        gLambdaG: params.gLambdaG,
        invUtil: params.inventoryUtilization,
        
        g,
        factorContributions: params.factorContributions,
      });
    }
    
    return quotes;
  }
  
  /**
   * Get current inventory utilization
   */
  getInventoryUtilization(): number {
    return this.factorRisk.getInventoryUtilization();
  }
  
  /**
   * Update config (e.g. adjust sigmaMD online)
   */
  updateConfig(partial: Partial<QuoteEngineConfig>): void {
    this.config = { ...this.config, ...partial };
  }
}

/**
 * Example integration into main loop
 */

/*
// Initialization
const sigmaService = new SigmaService({
  horizonMs: 1000,
  alpha: 0.05,
  ridgeEpsilon: 1e-5,
  minSamples: 50,
});

const factorRisk = new FactorRisk({
  gamma: 1.0,
  z: 1.0,
  eta: 1.0,
  kappa: 0.5,
  L: 1.0,
  ridgeEpsilon: 1e-5,
  feeBuffer: 0.50,
  qMax: 10,
  minEdge: 0.1,
});

const quoteEngine = new QuoteEngine(
  {
    symbols: ['BTC-25DEC25-50000-C', 'BTC-25DEC25-50000-P'],
    sigmaMD: {
      'BTC-25DEC25-50000-C': 0.002,
      'BTC-25DEC25-50000-P': 0.002,
    },
    edgeTargets: {
      atm: 0.5,
      otm: 1.0,
      wing: 1.5,
    },
  },
  factorRisk,
  sigmaService
);

const simAdapter = new SimAdapter({
  initialF: 50000,
  ouMean: 50000,
  ouTheta: 0.1,
  ouSigma: 0.02,
  tickMs: 1000,
  fillProbBase: 0.1,
  fillProbSpreadDecay: 0.5,
  fillProbSizeDecay: 0.3,
  slippageBps: 1.0,
}, 42);

const apiService = new APIService(sigmaService, factorRisk);
apiService.start(3000);

// Main loop (1Hz)
setInterval(() => {
  // 1. Tick market data
  const md = simAdapter.tick();
  
  // 2. Update Σ with current factors
  const portfolioFactors = computePortfolioFactors(md); // Your impl
  sigmaService.update(portfolioFactors, Date.now());
  
  // 3. Compute theos for all instruments
  const instruments = getInstruments(); // Your impl
  const theos = new Map<string, number>();
  const mids = new Map<string, number>();
  
  for (const instr of instruments) {
    const theo = computeTheo(instr, md); // Your impl
    theos.set(instr.symbol, theo);
    mids.set(instr.symbol, md.F); // Simplified
  }
  
  // 4. Generate quotes
  const marketCtx: MarketContext = {
    F: md.F,
    atmIV: md.atmIV,
    skew: md.skew,
    t: 0.25, // Example: 3 months
    r: 0.05,
  };
  
  const quotes = quoteEngine.computeQuotes(instruments, marketCtx, theos, mids);
  
  // 5. Try to fill
  const simQuotes = quotes.map(q => ({
    symbol: q.symbol,
    bid: q.bid,
    ask: q.ask,
    sizeBid: q.sizeBid,
    sizeAsk: q.sizeAsk,
  }));
  
  const fills = simAdapter.tryFill(simQuotes);
  
  // 6. Update inventory
  for (const fill of fills) {
    updateInventoryFromFill(fill); // Your impl
  }
  
  // 7. Broadcast state via API
  apiService.updateQuotes({
    ts: Date.now(),
    quotes: quotes.map(q => ({
      symbol: q.symbol,
      bid: q.bid,
      ask: q.ask,
      sizeBid: q.sizeBid,
      sizeAsk: q.sizeAsk,
      spread: q.spread,
      skew: q.skew,
      invUtil: q.invUtil,
    })),
  });
  
  // 8. Log to DB (every N ticks)
  if (shouldLog()) {
    logQuotesToDB(quotes);
    logInventoryToDB(inventory);
    logRiskMetricsToDB(sigmaService.getStats());
  }
  
}, 1000);
*/
---------- END apps/server/src/engine/QuoteEngine.ts ----------

---------- BEGIN apps/server/src/exchange/SimAdapter.ts (bytes=3048) ----------
// apps/server/src/exchange/SimAdapter.ts
/**
 * SimAdapter: Simulates exchange behavior for testing
 * 
 * Responsibilities:
 * - Generate synthetic market data (F, IV, skew)
 * - Simulate fills based on quotes
 * - Prevent dust fills (< minFillQty)
 */

import { SimConfig } from '../config/featureFlags';

export interface MarketData {
  ts: number;
  F: number;      // Forward price
  atmIV: number;  // ATM implied volatility
  skew: number;   // Volatility skew
}

export interface Quote {
  symbol: string;
  bid: number;
  ask: number;
  sizeBid: number;
  sizeAsk: number;
}

export interface Fill {
  symbol: string;
  side: 'buy' | 'sell';
  qty: number;
  price: number;
}

export class SimAdapter {
  private tickCount = 0;
  private rng: () => number;
  
  constructor(
    private config: SimConfig,
    seed?: number
  ) {
    // Simple seeded RNG for reproducibility
    let s = seed ?? Math.floor(Math.random() * 1e9);
    this.rng = () => {
      s = (s * 9301 + 49297) % 233280;
      return s / 233280;
    };
  }
  
  /**
   * Generate next market data point
   */
  tick(): MarketData {
    this.tickCount++;
    
    // Simulate mean-reverting forward price
    const F = 50000 + Math.sin(this.tickCount / 10) * 100 + (this.rng() - 0.5) * 50;
    
    // Simulate mean-reverting IV
    const atmIV = 0.10 + Math.sin(this.tickCount / 7) * 0.04 + (this.rng() - 0.5) * 0.01;
    
    // Simulate mean-reverting skew
    const skew = -0.05 + Math.sin(this.tickCount / 5) * 0.08 + (this.rng() - 0.5) * 0.02;
    
    return {
      ts: Date.now() + this.tickCount * 1000,
      F,
      atmIV,
      skew,
    };
  }
  
  /**
   * Simulate fills based on quotes
   * 
   * NEW: Filters out dust fills (< minFillQty)
   */
  tryFill(quotes: Quote[]): Fill[] {
    const fills: Fill[] = [];
    
    for (const quote of quotes) {
      // Random chance to fill
      if (this.rng() > this.config.fillProbability) {
        continue;
      }
      
      // Random side
      const side = this.rng() < 0.5 ? 'buy' : 'sell';
      
      // Random quantity from available size
      const maxSize = side === 'buy' ? quote.sizeAsk : quote.sizeBid;
      const fillQty = maxSize * (0.1 + this.rng() * 0.9); // 10-100% of size
      
      // ================================================================
      // 🚨 FIX: Prevent dust fills
      // ================================================================
      if (fillQty < this.config.minFillQty) {
        continue; // Skip fills smaller than minimum
      }
      
      // Fill at quoted price
      const price = side === 'buy' ? quote.ask : quote.bid;
      
      fills.push({
        symbol: quote.symbol,
        side,
        qty: fillQty,
        price,
      });
    }
    
    return fills;
  }
  
  /**
   * Reset simulation state
   */
  reset(seed?: number): void {
    this.tickCount = 0;
    if (seed !== undefined) {
      let s = seed;
      this.rng = () => {
        s = (s * 9301 + 49297) % 233280;
        return s / 233280;
      };
    }
  }
}
---------- END apps/server/src/exchange/SimAdapter.ts ----------

---------- BEGIN apps/server/src/logging/tradeLog.ts (bytes=657) ----------
import fs from "fs";
import path from "path";

const LOG_DIR = path.resolve("data");
const LOG_FILE = path.join(LOG_DIR, "trades.jsonl");

export type TradeRow = {
  ts: number;
  symbol: string;
  F: number;
  K: number;
  expiryMs: number;
  side: "BUY" | "SELL";
  qty: number;
  ccMid: number;
  pcMid: number;
  tradePx: number;
  dotLamG?: number;
  I_before?: number[];
  I_after?: number[];
  lambda?: number[];
  pnl_est: number;
};

export class TradeLog {
  static write(row: TradeRow) {
    if (!fs.existsSync(LOG_DIR)) {
      fs.mkdirSync(LOG_DIR, { recursive: true });
    }
    fs.appendFileSync(LOG_FILE, JSON.stringify(row) + "\n");
  }
}

---------- END apps/server/src/logging/tradeLog.ts ----------

---------- BEGIN apps/server/src/pricing/eventTable.ts (bytes=1068) ----------
import fs from "fs";
import path from "path";
import * as yaml from "js-yaml";

type EventRow = { t_event_ms: number; omega_event: number };
type EventMap = Record<string, EventRow[]>;

const cfgPath = path.join(__dirname, "..", "..", "..", "..", "config", "events.yaml");

if (!fs.existsSync(cfgPath)) {
  throw new Error(`[eventTable] Missing config at ${cfgPath}`);
}

let tbl: EventMap = {};
try {
  const raw = fs.readFileSync(cfgPath, "utf8");
  const parsed = yaml.load(raw);
  if (parsed && typeof parsed === "object") {
    tbl = parsed as EventMap;
  }
} catch (e) {
  throw new Error(`[eventTable] Failed to load ${cfgPath}: ${(e as Error).message}`);
}

export function eventMasses(symbol: string, startMs: number, endMs: number): number {
  if (endMs <= startMs) return 0;
  const rows = tbl[symbol] ?? [];
  let w = 0;

  for (const r of rows) {
    if (!Number.isFinite(r.t_event_ms) || !Number.isFinite(r.omega_event)) continue;
    if (r.t_event_ms >= startMs && r.t_event_ms <= endMs) {
      w += Math.max(0, r.omega_event);
    }
  }
  return w;
}

---------- END apps/server/src/pricing/eventTable.ts ----------

---------- BEGIN apps/server/src/pricing/seasonality.ts (bytes=2382) ----------
import fs from "fs";
import path from "path";

function minuteOfDayInTZ(tMs: number, timeZone: string): number {
  const d = new Date(tMs);
  const parts = new Intl.DateTimeFormat("en-GB", {
    hour: "2-digit",
    minute: "2-digit",
    hour12: false,
    timeZone,
  }).formatToParts(d);

  const hh = Number(parts.find(p => p.type === "hour")?.value ?? "0");
  const mm = Number(parts.find(p => p.type === "minute")?.value ?? "0");
  return hh * 60 + mm;
}

type SeasonalityCfg = {
  timezone: string;
  gridMinutes: number;
  profile: { mod: number; s: number }[];
  overnightOmega: { weekday: number; weekend: number };
};

const cfgPath = path.join(__dirname, "..", "..", "..", "..", "config", "seasonality.json");

if (!fs.existsSync(cfgPath)) {
  throw new Error(`[seasonality] Missing config at ${cfgPath}`);
}

let cfg: SeasonalityCfg;
try {
  cfg = JSON.parse(fs.readFileSync(cfgPath, "utf8"));
} catch (e) {
  throw new Error(`[seasonality] Failed to parse ${cfgPath}: ${(e as Error).message}`);
}

function scaleForMinute(minOfDay: number): number {
  let best = cfg.profile[0];
  let bestDist = Math.abs(cfg.profile[0].mod - minOfDay);
  for (let i = 1; i < cfg.profile.length; i++) {
    const p = cfg.profile[i];
    const dist = Math.abs(p.mod - minOfDay);
    if (dist < bestDist) {
      best = p;
      bestDist = dist;
    }
  }
  return Math.max(0, best.s);
}

export function tauIntegral(startMs: number, endMs: number): number {
  if (endMs <= startMs) return 0;

  const step = Math.max(1, Math.floor(cfg.gridMinutes)) * 60 * 1000;
  let t = startMs;
  let acc = 0;

  while (t < endMs) {
    const tNext = Math.min(t + step, endMs);
    const minOfDay = minuteOfDayInTZ(t, cfg.timezone);
    const s = scaleForMinute(minOfDay);
    acc += s * (tNext - t);
    t = tNext;
  }

  const YEAR_MS = 365.25 * 24 * 3600 * 1000;
  return acc / YEAR_MS;
}

export function overnightMasses(startMs: number, endMs: number): number {
  if (endMs <= startMs) return 0;
  
  let w = 0;
  const d0 = new Date(startMs);
  let day = Date.UTC(d0.getUTCFullYear(), d0.getUTCMonth(), d0.getUTCDate() + 1);
  
  while (day < endMs) {
    const weekday = new Date(day).getUTCDay();
    const isWeekend = weekday === 0 || weekday === 6;
    w += isWeekend ? cfg.overnightOmega.weekend : cfg.overnightOmega.weekday;
    day += 24 * 3600 * 1000;
  }
  
  return Math.max(0, w);
}

---------- END apps/server/src/pricing/seasonality.ts ----------

---------- BEGIN apps/server/src/pricing/totalVariance.ts (bytes=920) ----------
import { tauIntegral, overnightMasses } from "./seasonality";
import { eventMasses } from "./eventTable";

export function totalVariance(params: {
  symbol: string;
  baseSigma: number;
  startMs: number;
  endMs: number;
}): number {
  const { symbol, baseSigma, startMs, endMs } = params;

  if (!Number.isFinite(baseSigma) || baseSigma < 0) return 0;
  if (endMs <= startMs) return 0;

  const tau = tauIntegral(startMs, endMs);
  const wDiff = baseSigma * baseSigma * tau;
  const wON = overnightMasses(startMs, endMs);
  const wEvt = eventMasses(symbol, startMs, endMs);
  
  const total = Math.max(0, wDiff + wON + wEvt);
  
  // Debug: log breakdown (comment out in prod)
  if (Math.random() < 0.01) { // 1% sample rate
    console.log(`[totalVariance] ${symbol}: τ=${tau.toFixed(6)}, wDiff=${wDiff.toFixed(6)}, wON=${wON.toFixed(6)}, wEvt=${wEvt.toFixed(6)}, total=${total.toFixed(6)}`);
  }

  return total;
}

---------- END apps/server/src/pricing/totalVariance.ts ----------

---------- BEGIN apps/server/src/replay/backtester.ts (bytes=7648) ----------
import { PrismaClient } from "@prisma/client";
import { quoteEngine } from "../quoteEngine";
import { volService } from "../volModels/integration/volModelService";
import { TradeLog } from "../logging/tradeLog";


export type Side = "BUY" | "SELL";
export type OptionType = "C" | "P";

export type BacktestResult = {
  trades: number;
  totalEdgeUSD: number;
  avgEdgePerContractUSD: number;
  winRatePct: number;
  byTrade: Trade[];
  inventory: Record<number, { qty: number; avgPrice: number; totalEdge: number }>;
};

export type Trade = {
  ts: number;
  strike: number;
  expiryMs: number;
  side: Side;
  optionType: OptionType;
  price: number;
  ccMid: number;
  edgeUSD: number;
  bucket?: string;
};

export interface Strategy {
  name: string;
  decide(q: QuoteLike, context: TickContext): Side | null;
  size(q: QuoteLike, context: TickContext): number;
}

type QuoteLike = {
  bid: number;
  ask: number;
  bidSize: number;
  askSize: number;
  mid: number;
  spread: number;
  ccMid?: number;
  pcMid?: number;
  bucket?: string;
};

type TickContext = {
  ts: number;
  symbol: string;
  strike: number;
  expiryMs: number;
  optionType: OptionType;
};

function strikeGrid(F: number): number[] {
  const low = Math.floor(F * 0.97 / 1000) * 1000;
  const high = Math.ceil(F * 1.03 / 1000) * 1000;
  const strikes: number[] = [];
  for (let k = low; k <= high; k += 1000) strikes.push(k);
  return strikes;
}


function tradeEdgeUSD(side: Side, ccMid: number, bid: number, ask: number): number {
  return side === "SELL" ? ask - ccMid : ccMid - bid;
}

export class PassiveMMStrategy implements Strategy {
  name = "Passive Market Making";
  constructor(private maxSpreadUSD = 5000, private blockSize = 1) {}

  decide(q: QuoteLike): Side | null {
    if (!Number.isFinite(q.bid) || !Number.isFinite(q.ask)) return null;
    if (q.ask <= 0 || q.bid < 0) return null;
    if (q.spread > this.maxSpreadUSD) return null;
    if ((q.askSize || 0) >= this.blockSize) return "SELL";
    if ((q.bidSize || 0) >= this.blockSize) return "BUY";
    return null;
  }
  size(): number { return this.blockSize; }
}

export class InventoryAwareStrategy implements Strategy {
  name = "Inventory-Aware MM";
  constructor(private maxSpreadUSD = 5000, private blockSize = 1) {}

  decide(q: QuoteLike): Side | null {
    if (!Number.isFinite(q.bid) || !Number.isFinite(q.ask)) return null;
    if (q.spread > this.maxSpreadUSD) return null;
    if ((q.askSize || 0) >= this.blockSize) return "SELL";
    if ((q.bidSize || 0) >= this.blockSize) return "BUY";
    // fallback: just sell if nothing else
    return "SELL";
  }
  size(): number { return this.blockSize; }
}

export class Backtester {
  constructor(private prisma: PrismaClient) {}

  async runBacktest(
    strat: Strategy,
    symbol: string,
    startTime: number,
    endTime: number,
    optionType: OptionType = "P"
  ): Promise<{ strategy: string; summary: BacktestResult }> {
    // Seed deterministic test data
    const { seedTestData } = await import("./testDataSeed");
    await seedTestData(this.prisma);
    // Clear vol service state for determinism
    const { quoteEngine } = await import("../quoteEngine");
    quoteEngine.resetAllState();
    const beats = await this.prisma.ticker.findMany({
      where: { instrument: "BTC-PERPETUAL", tsMs: { gte: BigInt(startTime), lte: BigInt(endTime) } },
      orderBy: { tsMs: "asc" },
      select: { tsMs: true, markPrice: true, underlying: true }
    });
    if (beats.length === 0) {
      return { strategy: strat.name, summary: { trades: 0, totalEdgeUSD: 0, avgEdgePerContractUSD: 0, winRatePct: 0, byTrade: [], inventory: {} } };
    }

    const byTrade: Trade[] = [];
    const inventory: Record<number, { qty: number; avgPrice: number; totalEdge: number }> = {};
    let trades = 0, totalEdgeUSD = 0, wins = 0;

    for (const b of beats) {
      const ts = Number(b.tsMs);
      const F = Number(b.markPrice ?? b.underlying ?? 0);
      if (!Number.isFinite(F) || F <= 0) continue;
      const expiryMs = ts + Math.round(14 * 24 * 3600 * 1000);
    
      // Estimate ATM IV from recent market (simple heuristic: 30-80 vol in BTC terms)
      const atmIV = 0.35; // Placeholder - should come from market data
    
      for (const strike of strikeGrid(F)) {
        const q = quoteEngine.getQuote({ 
          symbol, strike, expiryMs, optionType, 
          marketIV: atmIV  // Use dynamic IV here
        });
        
        const side = strat.decide(q, { ts, symbol, strike, expiryMs, optionType });
        if (!side) continue;
        const size = strat.size(q, { ts, symbol, strike, expiryMs, optionType });
        if (size <= 0) continue;
    
        const ccMid = q.ccMid ?? q.mid;
        const edge = tradeEdgeUSD(side, ccMid, q.bid, q.ask);
    
        trades += size;
        totalEdgeUSD += edge * size;
        if (edge > 0) wins += size;
    
        // update inventory
        const inv = inventory[strike] || { qty: 0, avgPrice: 0, totalEdge: 0 };
        if (side === "SELL") inv.qty -= size; else inv.qty += size;
        inv.totalEdge += edge * size;
        inv.avgPrice = (inv.avgPrice * Math.abs(inv.qty) + (side === "SELL" ? q.ask : q.bid) * size) / (Math.abs(inv.qty) + size);
        inventory[strike] = inv;
    
        const tradePx = side === "SELL" ? q.ask : q.bid;
        
        // Get factor inventory before trade
        const factorsBefore = quoteEngine.getFactorInventory(symbol);
        
        byTrade.push({ 
          ts, strike, expiryMs, side, optionType, 
          price: tradePx, 
          ccMid, edgeUSD: edge, bucket: q.bucket 
        });
        
        // Execute trade
        quoteEngine.executeTrade({ 
          symbol, strike, expiryMs, optionType, side, size, 
          price: tradePx, 
          timestamp: ts,
          marketIV: atmIV
        });
        
        /// Get factor inventory after trade
        const factorsAfter = quoteEngine.getFactorInventory(symbol);
        
        // Log trade with factor attribution
        TradeLog.write({
          ts,
          symbol,
          F,
          K: strike,
          expiryMs,
          side,
          qty: size,
          ccMid,
          pcMid: q.pcMid ?? q.mid,
          tradePx,
          dotLamG: factorsAfter.lambdaDotInventory,
          I_before: factorsBefore.inventory,
          I_after: factorsAfter.inventory,
          lambda: factorsAfter.lambda,
          pnl_est: edge * size
        });
      }
    }

    const avg = trades ? totalEdgeUSD / trades : 0;
    const winRatePct = trades ? (wins / trades) * 100 : 0;
    const summary: BacktestResult = { trades, totalEdgeUSD, avgEdgePerContractUSD: avg, winRatePct, byTrade, inventory };

    this.printSummary(strat.name, summary);
    return { strategy: strat.name, summary };
  }

  private printSummary(name: string, s: BacktestResult) {
    console.log("\n--------------------------------------------------------------------------------");
    console.log(`Results Summary — ${name}`);
    console.log(`Trades executed:  ${s.trades}`);
    console.log(`Total edge:       $${s.totalEdgeUSD.toFixed(2)}`);
    console.log(`Avg edge/contract:$${s.avgEdgePerContractUSD.toFixed(4)}`);
    console.log(`Win rate:         ${s.winRatePct.toFixed(1)}%`);
    console.log("\nNet Inventory by Strike:");
    console.log("Strike    Qty   AvgPx   Edge");
    for (const k of Object.keys(s.inventory).sort((a,b)=>+a - +b)) {
      const inv = s.inventory[+k];
      console.log(`${k.padEnd(8)} ${inv.qty.toString().padStart(5)}   ${inv.avgPrice.toFixed(2).padStart(6)}   ${inv.totalEdge.toFixed(2).padStart(6)}`);
    }
  }
}

---------- END apps/server/src/replay/backtester.ts ----------

---------- BEGIN apps/server/src/replay/marketRecorder.ts (bytes=4071) ----------
// apps/server/src/replay/marketRecorder.ts

import { PrismaClient } from "@prisma/client";

export interface OptionSnapshot {
  instrument: string;
  strike: number;
  expiry: string;
  bid: number;
  ask: number;
  bidSize: number;
  askSize: number;
  bidIv: number;
  askIv: number;
  markIv: number;
  markPrice: number;
  volume24h: number;
  openInterest: number;
  underlying: number;
}

export interface MarketSnapshot {
  timestamp: number;
  symbol: string;
  spot: number;
  forward: number;
  options: OptionSnapshot[];
}

export class MarketRecorder {
  private recording: boolean = false;
  private intervalId?: NodeJS.Timeout;

  constructor(private prisma: PrismaClient) {}

  async captureSnapshot(symbol: string = "BTC"): Promise<MarketSnapshot> {
    const perp = await this.prisma.ticker.findFirst({
      where: { instrument: `${symbol}-PERPETUAL` },
      orderBy: { tsMs: "desc" },
    });

    const index = await this.prisma.tickIndex.findFirst({
      where: { indexName: `${symbol.toLowerCase()}_usd` },
      orderBy: { tsMs: "desc" },
    });

    const rawOptions = await this.prisma.ticker.findMany({
      where: {
        instrument: { startsWith: `${symbol}-` },
        NOT: { instrument: { endsWith: "PERPETUAL" } },
      },
      orderBy: { tsMs: "desc" },
    });

    const optionMap = new Map<string, any>();
    for (const opt of rawOptions) {
      if (!optionMap.has(opt.instrument)) {
        optionMap.set(opt.instrument, opt);
      }
    }

    const forward = perp?.markPrice || 45000;
    const SCALE_FACTOR = 1;
    const DEFAULT_SIZE = 10; // CRITICAL FIX: hardcode sizes

    const options: OptionSnapshot[] = Array.from(optionMap.values()).map((opt) => {
      const parts = opt.instrument.split("-");
      
      return {
        instrument: opt.instrument,
        strike: parseInt(parts[2]) || 0,
        expiry: parts[1] || "",
        bid: (opt.bestBid || 0) * forward,
        ask: (opt.bestAsk || 0) * forward,
        // FIXED: Use default size instead of database values
        bidSize: DEFAULT_SIZE,
        askSize: DEFAULT_SIZE,
        bidIv: opt.bidIv || 0,
        askIv: opt.askIv || 0,
        markIv: opt.markIv || 0,
        markPrice: (opt.markPrice || 0) * forward,
        volume24h: parseFloat(opt.stats24h?.volume || "0"),
        openInterest: opt.openInterest || 0,
        underlying: forward,
      };
    });

    return {
      timestamp: Date.now(),
      symbol,
      spot: index?.price || 0,
      forward: perp?.markPrice || 0,
      options: options.filter((o) => o.strike > 0),
    };
  }

  async saveSnapshot(snapshot: MarketSnapshot): Promise<void> {
    await this.prisma.marketSnapshot.create({
      data: {
        timestamp: snapshot.timestamp,
        symbol: snapshot.symbol,
        data: JSON.stringify(snapshot),
      },
    });
  }

  async loadSnapshots(
    symbol: string,
    startTime: number,
    endTime: number
  ): Promise<MarketSnapshot[]> {
    const rows = await this.prisma.marketSnapshot.findMany({
      where: {
        symbol,
        timestamp: { gte: startTime, lte: endTime },
      },
      orderBy: { timestamp: "asc" },
    });

    return rows.map((row) => JSON.parse(row.data));
  }

  startRecording(symbol: string = "BTC", intervalMs: number = 60000): void {
    if (this.recording) return;

    this.recording = true;
    console.log(`Started recording ${symbol} snapshots every ${intervalMs}ms`);

    this.intervalId = setInterval(async () => {
      try {
        const snapshot = await this.captureSnapshot(symbol);
        await this.saveSnapshot(snapshot);
        console.log(
          `Recorded snapshot: ${snapshot.options.length} options, forward=${snapshot.forward}`
        );
      } catch (err) {
        console.error("Failed to record snapshot:", err);
      }
    }, intervalMs);
  }

  stopRecording(): void {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.recording = false;
      console.log("Stopped recording");
    }
  }

  isRecording(): boolean {
    return this.recording;
  }
}
---------- END apps/server/src/replay/marketRecorder.ts ----------

---------- BEGIN apps/server/src/replay/replayEngine.ts (bytes=6096) ----------
// apps/server/src/replay/replayEngine.ts

import { MarketSnapshot, OptionSnapshot } from "./marketRecorder";
import { quoteEngine } from "../quoteEngine";
import { timeToExpiryYears } from "../utils/time";

export interface Trade {
  timestamp: number;
  strike: number;
  expiry: string;
  side: "BUY" | "SELL";
  size: number;
  ourPrice: number;
  marketBid: number;
  marketAsk: number;
  marketMid: number;
  edge: number;
  inventory: number;
}

export interface ReplayStats {
  trades: Trade[];
  totalEdge: number;
  totalVolume: number;
  avgEdge: number;
  winRate: number;
  maxInventory: number;
  finalInventory: number;
}

export class ReplayEngine {
  private snapshots: MarketSnapshot[] = [];
  private currentIndex: number = 0;
  private trades: Trade[] = [];
  private currentInventory: number = 0;

  async loadSnapshots(snapshots: MarketSnapshot[]): Promise<void> {
    this.snapshots = snapshots;
    this.currentIndex = 0;
    console.log(`Loaded ${snapshots.length} snapshots for replay`);
  }

  getCurrentSnapshot(): MarketSnapshot | null {
    return this.snapshots[this.currentIndex] || null;
  }

  getCurrentTime(): number {
    const snap = this.getCurrentSnapshot();
    return snap ? snap.timestamp : 0;
  }

  hasNext(): boolean {
    return this.currentIndex < this.snapshots.length - 1;
  }

  step(): void {
    if (this.hasNext()) {
      this.currentIndex++;
      const snapshot = this.snapshots[this.currentIndex];
      // Keep the engine's forward synced with snapshot
      quoteEngine.updateForward("BTC", snapshot.forward);
    }
  }

  // Find option in current snapshot
  private findOption(strike: number, expiry: string): OptionSnapshot | null {
    const snapshot = this.getCurrentSnapshot();
    if (!snapshot) return null;
    return (
      snapshot.options.find((o) => o.strike === strike && o.expiry === expiry) ||
      null
    );
  }

  // Parse "28JUN24" -> absolute expiry (ms since epoch)
  private parseExpiryMs(expiryStr: string): number {
    const day = parseInt(expiryStr.slice(0, 2), 10);
    const monthMap: Record<string, number> = {
      JAN: 0, FEB: 1, MAR: 2, APR: 3, MAY: 4, JUN: 5,
      JUL: 6, AUG: 7, SEP: 8, OCT: 9, NOV: 10, DEC: 11,
    };
    const month = monthMap[expiryStr.slice(2, 5)];
    const year = 2000 + parseInt(expiryStr.slice(5, 7), 10);
    // 08:00 local like before
    const d = new Date(year, month, day, 8, 0, 0);
    return d.getTime();
  }

  // If you want T (years) for diagnostics
  private timeToExpiryYearsFromStr(expiryStr: string, nowMs: number): number {
    const expiryMs = this.parseExpiryMs(expiryStr);
    return Math.max(0.001, timeToExpiryYears(expiryMs, nowMs));
  }

  private inferOptionType(opt: OptionSnapshot): "C" | "P" {
    if ((opt as any).optionType === "C" || (opt as any).optionType === "P") {
      return (opt as any).optionType;
    }
    const name = (opt as any).instrument || "";
    return name.includes("-C") ? "C" : "P";
  }

  // Simulate a trade at current market
  simulateTrade(
    strike: number,
    expiry: string,
    side: "BUY" | "SELL",
    size: number
  ): Trade | null {
    const snapshot = this.getCurrentSnapshot();
    if (!snapshot) return null;

    const option = this.findOption(strike, expiry);
    if (!option) return null;

    // Skip if market is too illiquid
    if (option.bid === 0 || option.ask === 0) return null;
    if (option.ask - option.bid > option.markPrice * 0.5) return null; // Spread > 50%

    const expiryMs = this.parseExpiryMs(expiry);
    const optionType = this.inferOptionType(option);

    // Use market IV for calibration if present (decimal)
    const marketIV = option.markIv > 0 ? option.markIv / 100 : undefined;

    // Ask engine for a quote (forward is maintained inside quoteEngine)
    const quote = quoteEngine.getQuote({
      symbol: "BTC",
      strike,
      expiryMs,
      optionType,
      side,
      size,
      marketIV,
    });

    // Simulate fill at our quote
    const ourPrice = side === "BUY" ? quote.ask : quote.bid;
    const marketMid = (option.bid + option.ask) / 2;

    // Edge (positive = we made money vs mid)
    const edge =
      side === "SELL"
        ? (ourPrice - marketMid) * size
        : (marketMid - ourPrice) * size;

    // Inventory update (customer BUY => we SELL)
    const inventoryChange = side === "BUY" ? -size : size;
    this.currentInventory += inventoryChange;

    const trade: Trade = {
      timestamp: snapshot.timestamp,
      strike,
      expiry,
      side,
      size,
      ourPrice,
      marketBid: option.bid,
      marketAsk: option.ask,
      marketMid,
      edge,
      inventory: this.currentInventory,
    };

    this.trades.push(trade);

    // Inform the engine (will update inventory/PC)
    quoteEngine.executeTrade({
      symbol: "BTC",
      strike,
      side,
      size,
      price: ourPrice,
      timestamp: snapshot.timestamp,
      expiryMs,
      optionType,
    } as any);

    return trade;
  }

  getStats(): ReplayStats {
    const totalEdge = this.trades.reduce((sum, t) => sum + t.edge, 0);
    const totalVolume = this.trades.reduce((sum, t) => sum + t.size, 0);
    const avgEdge = totalVolume > 0 ? totalEdge / totalVolume : 0;
    const winningTrades = this.trades.filter((t) => t.edge > 0).length;
    const winRate = this.trades.length > 0 ? winningTrades / this.trades.length : 0;
    const maxInventory = Math.max(...this.trades.map((t) => Math.abs(t.inventory)), 0);

    return {
      trades: this.trades,
      totalEdge,
      totalVolume,
      avgEdge,
      winRate,
      maxInventory,
      finalInventory: this.currentInventory,
    };
  }

  reset(): void {
    this.currentIndex = 0;
    this.trades = [];
    this.currentInventory = 0;
  }

  // Get all available strikes for current snapshot
  getAvailableStrikes(minVolume: number = 0): number[] {
    const snapshot = this.getCurrentSnapshot();
    if (!snapshot) return [];
    return Array.from(
      new Set(snapshot.options.filter((o) => o.volume24h >= minVolume).map((o) => o.strike))
    ).sort((a, b) => a - b);
  }
}

---------- END apps/server/src/replay/replayEngine.ts ----------

---------- BEGIN apps/server/src/replay/testDataSeed.ts (bytes=807) ----------
import { PrismaClient } from "@prisma/client";

export async function seedTestData(prisma: PrismaClient) {
  // Clear existing test data
  await prisma.ticker.deleteMany({
    where: { 
      instrument: "BTC-PERPETUAL",
      tsMs: { gte: BigInt(1759752130000), lte: BigInt(1759752131000) }
    }
  });

  // Insert fixed test ticks
  const testTicks = [
    { tsMs: BigInt(1759752130999), markPrice: 100000.0, underlying: 100000.0 },
  ];

  await prisma.ticker.createMany({
    data: testTicks.map(t => ({
      instrument: "BTC-PERPETUAL",
      tsMs: t.tsMs,
      markPrice: t.markPrice,
      markIv: 0.35,
      bestBid: t.markPrice * 0.9999,
      bestAsk: t.markPrice * 1.0001,
      underlying: t.underlying
    }))
  });

  console.log(`[testDataSeed] Seeded ${testTicks.length} test ticks`);
}

---------- END apps/server/src/replay/testDataSeed.ts ----------

---------- BEGIN apps/server/src/risk/FactorRisk.ts (bytes=7240) ----------
// apps/server/src/risk/FactorRisk.ts
/**
 * Phase 2: Core quadratic risk model
 * 
 * Inputs: g (greeks), I (inventory), Σ (covariance)
 * Outputs: skew, halfSpread, size
 * 
 * Formulas:
 * - Λ = γ(Σ + ε·(trΣ/d)I)
 * - λ = ΛI (inventory price vector)
 * - skew = λ·g
 * - s_model = z√(gᵀΣg)
 * - s_inv = κ·min(1, ||I||_Λ / L)·s_model
 * - q* = clamp((edge - s_buffers)/(gᵀΛg), 0, q_max)
 */

import { d, FactorVector, validateVector } from './factors';
import { num, clamp } from '../utils/numeric';
import {
  matVec,
  dot,
  quadForm,
  normMahalanobis,
  scaleMatrix,
  addRidge,
} from '../utils/linalg';

export type RiskConfig = {
  gamma: number;               // Risk aversion (scales Λ)
  z: number;                   // Model uncertainty spread multiplier
  eta: number;                 // Microstructure noise multiplier
  kappa: number;               // Inventory widening multiplier
  L: number;                   // Inventory limit in Λ-norm
  ridgeEpsilon: number;        // Ridge on Λ (same as Σ typically)
  feeBuffer: number;           // Fee + tick cushion ($ per contract)
  
  // Size parameters
  qMax: number;                // Max size per side
  minEdge: number;             // Min edge before quoting ($ per contract)
};

export type SpreadComponents = {
  fee: number;                 // Fees + tick cushion
  noise: number;               // Microstructure (η·σ_md)
  model: number;               // Model uncertainty (z·√(gᵀΣg))
  inventory: number;           // Inventory widening (κ·...)
  total: number;               // Sum of above
};

export type QuoteParams = {
  theoRaw: number;             // Unadjusted theoretical mid
  theoInv: number;             // Inventory-adjusted mid (theoRaw - skew)
  skew: number;                // λ·g (inventory price)
  spreadComponents: SpreadComponents;
  bid: number;                 // theoInv - s_total
  ask: number;                 // theoInv + s_total
  sizeBid: number;             // Optimal size (bid side)
  sizeAsk: number;             // Optimal size (ask side)
  
  // Diagnostics
  gLambdaG: number;            // gᵀΛg (quadratic penalty)
  inventoryUtilization: number; // ||I||_Λ / L
  factorContributions?: number[]; // (Λg) .* g element-wise
};

export class FactorRisk {
  private config: RiskConfig;
  private Lambda: number[][] | null = null; // Cached Λ = γ(Σ + ridge)
  private lambdaVec: number[] | null = null; // Cached λ = ΛI
  private inventoryNorm: number = 0;         // Cached ||I||_Λ
  
  constructor(config: RiskConfig) {
    this.config = config;
    this.validateConfig();
  }
  
  private validateConfig(): void {
    if (this.config.gamma <= 0) throw new Error('gamma must be positive');
    if (this.config.z < 0) throw new Error('z must be non-negative');
    if (this.config.eta < 0) throw new Error('eta must be non-negative');
    if (this.config.kappa < 0) throw new Error('kappa must be non-negative');
    if (this.config.L <= 0) throw new Error('L must be positive');
    if (this.config.qMax <= 0) throw new Error('qMax must be positive');
  }
  
  /**
   * Update risk state with new Σ and inventory
   * Call this whenever Σ or I changes (typically once per tick)
   */
  updateState(Sigma: number[][], inventory: number[]): void {
    if (Sigma.length !== d || inventory.length !== d) {
      throw new Error(`Dimension mismatch: expected ${d}`);
    }
    
    // Compute Λ = γ(Σ + ε·(trΣ/d)I)
    const SigmaRidged = addRidge(Sigma, this.config.ridgeEpsilon);
    this.Lambda = scaleMatrix(SigmaRidged, this.config.gamma);
    
    // Compute λ = ΛI
    this.lambdaVec = matVec(this.Lambda, inventory);
    
    // Compute ||I||_Λ = √(IᵀΛI)
    this.inventoryNorm = normMahalanobis(inventory, this.Lambda);
  }
  
  /**
   * Compute quote parameters for a given instrument
   * 
   * @param g - Factor greeks of instrument
   * @param theoRaw - Unadjusted theoretical mid
   * @param sigmaMD - Microstructure volatility (mid returns @ 100-300ms)
   * @param mid - Current market mid (for edge calculation)
   * @returns Complete quote parameters
   */
  computeQuote(
    g: number[],
    theoRaw: number,
    sigmaMD: number,
    mid: number
  ): QuoteParams {
    if (!this.Lambda || !this.lambdaVec) {
      throw new Error('Must call updateState() before computeQuote()');
    }
    
    if (g.length !== d) {
      throw new Error(`Greeks dimension mismatch: expected ${d}, got ${g.length}`);
    }
    
    // A) Skew (inventory price): λ·g
    const skew = num(dot(this.lambdaVec, g), 'skew');
    
    // B) Inventory-adjusted theo
    const theoInv = num(theoRaw - skew, 'theoInv');
    
    // C) Spread components
    const s_fee = this.config.feeBuffer;
    const s_noise = num(this.config.eta * sigmaMD, 's_noise');
    const s_model = num(
      this.config.z * Math.sqrt(Math.max(0, quadForm(this.Lambda, g) / this.config.gamma)),
      's_model'
    );
    
    // Inventory widening: κ·min(1, ||I||_Λ / L)·s_model
    const utilization = this.inventoryNorm / this.config.L;
    const s_inv = num(
      this.config.kappa * Math.min(1, utilization) * s_model,
      's_inv'
    );
    
    const s_total = s_fee + s_noise + s_model + s_inv;
    
    const spreadComponents: SpreadComponents = {
      fee: s_fee,
      noise: s_noise,
      model: s_model,
      inventory: s_inv,
      total: s_total,
    };
    
    // D) Firm quotes
    const bid = theoInv - s_total;
    const ask = theoInv + s_total;
    
    // E) Optimal size: q* = (edge - s_buffers) / (gᵀΛg)
    const gLambdaG = num(quadForm(this.Lambda, g), 'gLambdaG');
    const denom = Math.max(gLambdaG, 1e-12); // Floor to avoid division by zero
    
    const edgeBid = Math.abs(theoInv - Math.max(bid, mid));
    const edgeAsk = Math.abs(theoInv - Math.min(ask, mid));
    
    const s_buffers = s_fee + s_noise;
    
    const sizeBid = clamp(
      (edgeBid - s_buffers) / denom,
      0,
      this.config.qMax
    );
    
    const sizeAsk = clamp(
      (edgeAsk - s_buffers) / denom,
      0,
      this.config.qMax
    );
    
    // F) Diagnostics: factor contributions (Λg) .* g
    const Lambdag = matVec(this.Lambda, g);
    const factorContributions = g.map((gi, i) => 
      num(gi, 'g') * num(Lambdag[i], 'Lambdag')
    );
    
    return {
      theoRaw,
      theoInv,
      skew,
      spreadComponents,
      bid,
      ask,
      sizeBid,
      sizeAsk,
      gLambdaG,
      inventoryUtilization: utilization,
      factorContributions,
    };
  }
  
  /**
   * Get current inventory utilization (for monitoring)
   */
  getInventoryUtilization(): number {
    return this.inventoryNorm / this.config.L;
  }
  
  /**
   * Get current Lambda matrix (for diagnostics)
   */
  getLambda(): number[][] | null {
    return this.Lambda ? this.Lambda.map(row => [...row]) : null;
  }
  
  /**
   * Get current lambda vector (for diagnostics)
   */
  getLambdaVec(): number[] | null {
    return this.lambdaVec ? [...this.lambdaVec] : null;
  }
  
  /**
   * Update config (e.g. for online tuning)
   */
  updateConfig(partial: Partial<RiskConfig>): void {
    this.config = { ...this.config, ...partial };
    this.validateConfig();
  }
}
---------- END apps/server/src/risk/FactorRisk.ts ----------

---------- BEGIN apps/server/src/risk/FactorSpace.ts (bytes=2732) ----------
// server/src/risk/FactorSpace.ts
//
// Factor basis + tiny vector ops + finite-diff factor greeks.
// This is agnostic to your internal CC model. You pass a priceFn.

export enum FactorIndex {
    L0 = 0,     // level
    S0 = 1,     // skew
    C0 = 2,     // curvature
    Sneg = 3,   // left wing
    Spos = 4,   // right wing
    F = 5,      // forward
  }
  
  export type Theta = [number, number, number, number, number, number]; // [L0,S0,C0,Sneg,Spos,F]
  export type Vec = number[];
  export type Mat = number[][];
  
  export const factorNames: Record<FactorIndex, string> = {
    [FactorIndex.L0]: "L0",
    [FactorIndex.S0]: "S0",
    [FactorIndex.C0]: "C0",
    [FactorIndex.Sneg]: "Sneg",
    [FactorIndex.Spos]: "Spos",
    [FactorIndex.F]: "F",
  };
  
  export const defaultEpsilons: Theta = [
    1e-4,   // L0
    1e-4,   // S0
    5e-4,   // C0
    5e-4,   // Sneg
    5e-4,   // Spos
    1e-2,   // F (in underlying price units)
  ];
  
  export function dot(a: Vec, b: Vec): number {
    let s = 0;
    const n = Math.min(a.length, b.length);
    for (let i = 0; i < n; i++) s += a[i] * b[i];
    return s;
  }
  
  export function add(a: Vec, b: Vec): Vec {
    const n = Math.min(a.length, b.length);
    const o = new Array(n);
    for (let i = 0; i < n; i++) o[i] = a[i] + b[i];
    return o;
  }
  
  export function scale(a: Vec, k: number): Vec {
    const o = new Array(a.length);
    for (let i = 0; i < a.length; i++) o[i] = a[i] * k;
    return o;
  }
  
  export function cloneTheta(t: Theta): Theta {
    return [t[0], t[1], t[2], t[3], t[4], t[5]];
  }
  
  // PriceFn signature: given (theta, instrument), return Black-76 price (or mid) in USD per contract.
  export type PriceFn<I> = (theta: Theta, inst: I) => number;
  
  /**
   * Central finite difference for factor greeks g_i = ∂P/∂θ
   * Safe defaults; replace later with analytic partials for speed/noise.
   */
  export function finiteDiffGreeks<I>(
    priceFn: PriceFn<I>,
    theta: Theta,
    inst: I,
    eps: Theta = defaultEpsilons
  ): number[] {
    const base = priceFn(theta, inst);
    const g = new Array(6).fill(0);
    for (let k = 0; k < 6; k++) {
      const h = eps[k];
      if (!isFinite(h) || h <= 0) continue;
      const thPlus = cloneTheta(theta);
      const thMinus = cloneTheta(theta);
      thPlus[k] += h;
      thMinus[k] -= h;
      const pPlus = priceFn(thPlus, inst);
      const pMinus = priceFn(thMinus, inst);
      g[k] = (pPlus - pMinus) / (2 * h);
      // gentle fallback if something blew up
      if (!isFinite(g[k])) g[k] = 0;
    }
    // ensure base is sane too (useful for callers)
    if (!isFinite(base)) throw new Error("finiteDiffGreeks: base price NaN/Inf");
    return g;
  }
  
---------- END apps/server/src/risk/FactorSpace.ts ----------

---------- BEGIN apps/server/src/risk/SigmaService.ts (bytes=8790) ----------
// apps/server/src/risk/SigmaService.ts
/**
 * Phase 2: Covariance matrix estimation via EWMA on factor shocks
 * 
 * Maintains rolling Σ = Cov(Δf) where Δf = f_t - f_{t-h}
 * Adds ridge regularization and PD enforcement
 */

import { FACTORS, d, FACTOR_LABELS, FactorMatrix, validateMatrix } from './factors';
import { num } from '../utils/numeric';
import {
  outerProduct,
  addMatrix,
  scaleMatrix,
  addRidge,
  trace,
  conditionNumber,
  isPDHeuristic,
} from '../utils/linalg';

export type SigmaConfig = {
  horizonMs: number;           // Time window for Δf (e.g. 1000ms)
  alpha: number;               // EWMA decay: Σ ← α·ΔfΔfᵀ + (1-α)·Σ
  ridgeEpsilon: number;        // Ridge: ε·(tr(Σ)/d)·I
  minSamples: number;          // Min samples before Σ is "ready"
  
  // Multi-horizon blending (optional, Phase 2 Week 2)
  blendHorizons?: {
    horizonMs: number;
    weight: number;
  }[];
};

export type SigmaStats = {
  sampleCount: number;
  traceValue: number;
  conditionNumber: number;
  isPD: boolean;
  minDiagonal: number;
  maxDiagonal: number;
  lastUpdateMs: number;
};

export class SigmaService {
  private config: SigmaConfig;
  private Sigma: number[][];           // Current covariance matrix
  private lastFactorVector: number[] | null = null;
  private lastUpdateTime: number = 0;
  private sampleCount: number = 0;
  
  // Multi-horizon state (if enabled)
  private horizonStates: Map<number, {
    Sigma: number[][];
    lastVector: number[] | null;
    lastUpdate: number;
    samples: number;
  }> = new Map();
  
  constructor(config: SigmaConfig) {
    this.config = config;
    
    // Initialize Σ to small diagonal (prior)
    this.Sigma = this.initializePrior();
    
    // Initialize multi-horizon if configured
    if (config.blendHorizons) {
      for (const h of config.blendHorizons) {
        this.horizonStates.set(h.horizonMs, {
          Sigma: this.initializePrior(),
          lastVector: null,
          lastUpdate: 0,
          samples: 0,
        });
      }
    }
    
    this.validateConfig();
  }
  
  private validateConfig(): void {
    if (this.config.horizonMs <= 0) {
      throw new Error('horizonMs must be positive');
    }
    if (this.config.alpha <= 0 || this.config.alpha >= 1) {
      throw new Error('alpha must be in (0, 1)');
    }
    if (this.config.ridgeEpsilon < 0) {
      throw new Error('ridgeEpsilon must be non-negative');
    }
    
    if (this.config.blendHorizons) {
      const totalWeight = this.config.blendHorizons.reduce((s, h) => s + h.weight, 0);
      if (Math.abs(totalWeight - 1.0) > 1e-6) {
        throw new Error(`blendHorizons weights must sum to 1.0, got ${totalWeight}`);
      }
    }
  }
  
  private initializePrior(): number[][] {
    // Start with small diagonal prior (uncorrelated factors)
    const prior: number[][] = [];
    for (let i = 0; i < d; i++) {
      const row: number[] = new Array(d).fill(0);
      row[i] = 1e-4; // Small variance prior
      prior.push(row);
    }
    return prior;
  }
  
  /**
   * Update Σ with new factor vector
   * Call this every time you recompute portfolio factors (e.g. every tick)
   */
  update(factorVector: number[], timestampMs: number): void {
    if (factorVector.length !== d) {
      throw new Error(`Factor vector dimension mismatch: expected ${d}, got ${factorVector.length}`);
    }
    
    // Primary horizon update
    this.updateHorizon(
      factorVector,
      timestampMs,
      this.config.horizonMs,
      this.config.alpha
    );
    
    // Multi-horizon updates
    if (this.config.blendHorizons) {
      for (const h of this.config.blendHorizons) {
        const state = this.horizonStates.get(h.horizonMs)!;
        if (timestampMs - state.lastUpdate >= h.horizonMs) {
          this.updateSingleHorizon(
            state,
            factorVector,
            timestampMs,
            h.horizonMs,
            this.config.alpha
          );
        }
      }
      
      // Blend horizons into primary Σ
      this.blendHorizons();
    }
  }
  
  private updateHorizon(
    factorVector: number[],
    timestampMs: number,
    horizonMs: number,
    alpha: number
  ): void {
    // Check if enough time has passed
    if (this.lastUpdateTime > 0 && timestampMs - this.lastUpdateTime < horizonMs) {
      // Update last vector but don't compute Δf yet
      this.lastFactorVector = factorVector;
      return;
    }
    
    // Compute Δf if we have a previous vector
    if (this.lastFactorVector !== null) {
      const deltaF: number[] = [];
      for (let i = 0; i < d; i++) {
        const df = num(factorVector[i], `f[${i}]`) - num(this.lastFactorVector[i], `f_prev[${i}]`);
        deltaF.push(df);
      }
      
      // EWMA update: Σ ← α·ΔfΔfᵀ + (1-α)·Σ
      const deltaFOuter = outerProduct(deltaF, deltaF);
      const scaledOuter = scaleMatrix(deltaFOuter, alpha);
      const scaledSigma = scaleMatrix(this.Sigma, 1 - alpha);
      this.Sigma = addMatrix(scaledOuter, scaledSigma);
      
      // Add ridge: Σ ← Σ + ε·(tr(Σ)/d)·I
      this.Sigma = addRidge(this.Sigma, this.config.ridgeEpsilon);
      
      // Enforce PD (clip negative diagonal if needed)
      this.enforcePD();
      
      this.sampleCount++;
    }
    
    this.lastFactorVector = factorVector;
    this.lastUpdateTime = timestampMs;
  }
  
  private updateSingleHorizon(
    state: { Sigma: number[][], lastVector: number[] | null, lastUpdate: number, samples: number },
    factorVector: number[],
    timestampMs: number,
    horizonMs: number,
    alpha: number
  ): void {
    if (state.lastVector !== null) {
      const deltaF: number[] = [];
      for (let i = 0; i < d; i++) {
        const df = num(factorVector[i], `f[${i}]`) - num(state.lastVector[i], `f_prev[${i}]`);
        deltaF.push(df);
      }
      
      const deltaFOuter = outerProduct(deltaF, deltaF);
      const scaledOuter = scaleMatrix(deltaFOuter, alpha);
      const scaledSigma = scaleMatrix(state.Sigma, 1 - alpha);
      state.Sigma = addMatrix(scaledOuter, scaledSigma);
      state.Sigma = addRidge(state.Sigma, this.config.ridgeEpsilon);
      
      state.samples++;
    }
    
    state.lastVector = factorVector;
    state.lastUpdate = timestampMs;
  }
  
  private blendHorizons(): void {
    if (!this.config.blendHorizons) return;
    
    // Weighted average: Σ = Σ w_i Σ_i
    const blended: number[][] = [];
    for (let i = 0; i < d; i++) {
      blended.push(new Array(d).fill(0));
    }
    
    for (const h of this.config.blendHorizons) {
      const state = this.horizonStates.get(h.horizonMs);
      if (!state || state.samples < this.config.minSamples) continue;
      
      const weighted = scaleMatrix(state.Sigma, h.weight);
      for (let i = 0; i < d; i++) {
        for (let j = 0; j < d; j++) {
          blended[i][j] += weighted[i][j];
        }
      }
    }
    
    this.Sigma = blended;
  }
  
  private enforcePD(): void {
    // Simple approach: ensure all diagonal elements are positive
    // Clip to small positive value if negative
    for (let i = 0; i < d; i++) {
      if (this.Sigma[i][i] < 1e-8) {
        this.Sigma[i][i] = 1e-8;
      }
    }
  }
  
  /**
   * Get current covariance matrix (with metadata)
   */
  getSigma(): FactorMatrix {
    return {
      version: FACTORS.version,
      labels: [...FACTOR_LABELS],
      matrix: this.Sigma.map(row => [...row]), // deep copy
    };
  }
  
  /**
   * Get raw matrix (for fast math)
   */
  getSigmaRaw(): number[][] {
    return this.Sigma;
  }
  
  /**
   * Check if Σ is ready (enough samples)
   */
  isReady(): boolean {
    return this.sampleCount >= this.config.minSamples;
  }
  
  /**
   * Get diagnostics
   */
  getStats(): SigmaStats {
    const tr = trace(this.Sigma);
    const kappa = conditionNumber(this.Sigma);
    const pd = isPDHeuristic(this.Sigma);
    
    let minDiag = Infinity;
    let maxDiag = -Infinity;
    for (let i = 0; i < d; i++) {
      minDiag = Math.min(minDiag, this.Sigma[i][i]);
      maxDiag = Math.max(maxDiag, this.Sigma[i][i]);
    }
    
    return {
      sampleCount: this.sampleCount,
      traceValue: tr,
      conditionNumber: kappa,
      isPD: pd,
      minDiagonal: minDiag,
      maxDiagonal: maxDiag,
      lastUpdateMs: this.lastUpdateTime,
    };
  }
  
  /**
   * Reset state (e.g. for new trading session)
   */
  reset(): void {
    this.Sigma = this.initializePrior();
    this.lastFactorVector = null;
    this.lastUpdateTime = 0;
    this.sampleCount = 0;
    
    if (this.config.blendHorizons) {
      for (const [horizonMs, state] of this.horizonStates) {
        state.Sigma = this.initializePrior();
        state.lastVector = null;
        state.lastUpdate = 0;
        state.samples = 0;
      }
    }
  }
}
---------- END apps/server/src/risk/SigmaService.ts ----------

---------- BEGIN apps/server/src/risk/factorGreeksLoader.ts (bytes=4192) ----------
// apps/server/src/risk/factorGreeksLoader.ts
/**
 * Bridge between existing FactorSpace and new factor registry system
 * 
 * Version 2: Now returns 7 factors [F, Gamma, L0, S0, C0, Sneg, Spos]
 * Gamma is computed via finite-diff on F (second derivative)
 */

import { FACTORS, d, FACTOR_LABELS, FactorVector } from './factors';
import { 
  finiteDiffGreeks, 
  PriceFn, 
  Theta,
  defaultEpsilons,
  cloneTheta
} from './FactorSpace';

// Export your existing types so other modules can use them
export type { Theta, PriceFn } from './FactorSpace';

/**
 * Your instrument type - adjust if needed
 */
export type Instrument = {
  symbol: string;
  strike: number;
  expiryMs: number;
  isCall: boolean;
};

/**
 * Market context wraps the theta vector
 */
export type MarketContext = {
  theta: Theta;  // [L0, S0, C0, Sneg, Spos, F] (from FactorSpace)
};

/**
 * Compute Gamma via finite difference on F (second derivative)
 * Gamma = d²P/dF² ≈ (P(F+h) - 2P(F) + P(F-h)) / h²
 */
function computeGamma(
  priceFn: PriceFn<Instrument>,
  theta: Theta,
  inst: Instrument,
  h: number = 10  // Bump size in underlying price units (e.g., $10 for BTC)
): number {
  // F is at index 5 in your FactorSpace theta
  const thetaPlus = cloneTheta(theta);
  const thetaMinus = cloneTheta(theta);
  const thetaBase = theta;
  
  thetaPlus[5] += h;
  thetaMinus[5] -= h;
  
  const pPlus = priceFn(thetaPlus, inst);
  const pBase = priceFn(thetaBase, inst);
  const pMinus = priceFn(thetaMinus, inst);
  
  // Second derivative
  const gamma = (pPlus - 2 * pBase + pMinus) / (h * h);
  
  return isFinite(gamma) ? gamma : 0;
}

/**
 * Compute factor greeks: [F, Gamma, L0, S0, C0, Sneg, Spos]
 * 
 * Your FactorSpace returns: [L0, S0, C0, Sneg, Spos, F]
 * We reorder and add Gamma to match the new registry
 * 
 * @param instr - Option instrument
 * @param ctx - Market context containing theta
 * @param priceFn - Your pricing function
 * @param eps - Optional bump sizes (defaults to defaultEpsilons)
 * @returns Factor greeks in registry order [F, Gamma, L0, S0, C0, Sneg, Spos]
 */
export function factorGreeksFor(
    instr: Instrument,
    ctx: MarketContext,
    priceFn: PriceFn<Instrument>,
    eps?: Theta
  ): number[] {
    // Get base greeks from FactorSpace
    const baseGreeks = finiteDiffGreeks(priceFn, ctx.theta, instr, eps);
    const gamma = computeGamma(priceFn, ctx.theta, instr);
    
    // Get current price for normalization
    const basePrice = priceFn(ctx.theta, instr);
    
    // Normalize greeks: express as "fraction of contract value per factor unit"
    // This makes them comparable across strikes and maturities
    const normalize = (g: number) => {
      return basePrice > 0 ? g / basePrice : 0;
    };
    
    // Reorder to registry and normalize
    const raw = [
      baseGreeks[5],  // F
      gamma,          // Gamma
      baseGreeks[0],  // L0
      baseGreeks[1],  // S0
      baseGreeks[2],  // C0
      baseGreeks[3],  // Sneg
      baseGreeks[4],  // Spos
    ];
    
    // Additional scaling for each factor type
    const typeScales = [
        1.0,     // F
        0.0001,  // Gamma
        0.001,   // L0
        0.01,    // S0 ← 10x smaller (was 0.1, now 0.01)
        0.1,     // C0
        0.1,     // Sneg
        0.1,     // Spos
      ];
    
    return raw.map((g, i) => normalize(g) * typeScales[i]);
  }
/**
 * Get factor greeks with metadata (for logging to DB)
 */
export function factorGreeksWithMetadata(
  instr: Instrument,
  ctx: MarketContext,
  priceFn: PriceFn<Instrument>,
  eps?: Theta
): FactorVector {
  return {
    version: FACTORS.version,
    labels: [...FACTOR_LABELS],
    values: factorGreeksFor(instr, ctx, priceFn, eps),
  };
}

/**
 * Validate that computed greeks are sane
 */
export function validateGreeks(g: number[], symbol: string): void {
  if (g.length !== d) {
    throw new Error(
      `Greeks dimension mismatch for ${symbol}: expected ${d}, got ${g.length}`
    );
  }
  
  for (let i = 0; i < d; i++) {
    if (!isFinite(g[i])) {
      console.warn(
        `Non-finite greek for ${symbol} at factor ${FACTOR_LABELS[i]}: ${g[i]}`
      );
      g[i] = 0; // Safe fallback
    }
  }
}
---------- END apps/server/src/risk/factorGreeksLoader.ts ----------

---------- BEGIN apps/server/src/risk/factors.ts (bytes=3856) ----------
// apps/server/src/risk/factors.ts
/**
 * Factor Registry - Central definition of all risk factors
 * 
 * Version 2: Added Gamma factor
 * Order: [F, Gamma, L0, S0, C0, Sneg, Spos]
 */

export type FactorLabel =
  | "F"           // Forward/Delta
  | "Gamma"       // Convexity
  | "L0"          // Level (ATM vol)
  | "S0"          // Skew
  | "C0"          // Curvature
  | "Sneg"        // Left wing
  | "Spos"        // Right wing
  ;

export type FactorSpec = {
  label: FactorLabel;
  unit: string;
  description: string;
  enabled?: boolean;
  priorVariance?: number;
};

export type FactorRegistry = {
  version: number;
  specs: FactorSpec[];
};

// SINGLE SOURCE OF TRUTH
export const FACTORS: FactorRegistry = {
  version: 2,  // ← Bumped from 1 to 2
  specs: [
    {
      label: "F",
      unit: "$/Δ",
      description: "Forward price sensitivity (delta-like)",
    },
    {
      label: "Gamma",
      unit: "$/Γ",
      description: "Convexity exposure to underlying moves",
    },
    {
      label: "L0",
      unit: "$/L0",
      description: "ATM vol level sensitivity",
    },
    {
      label: "S0",
      unit: "$/S0",
      description: "Skew parameter sensitivity",
    },
    {
      label: "C0",
      unit: "$/C0",
      description: "Curvature sensitivity",
    },
    {
      label: "Sneg",
      unit: "$/Sneg",
      description: "Left wing sensitivity",
    },
    {
      label: "Spos",
      unit: "$/Spos",
      description: "Right wing sensitivity",
    },
  ],
};

// Derived constants
export const ENABLED_FACTORS = FACTORS.specs.filter(s => s.enabled ?? true);
export const d = ENABLED_FACTORS.length;
export const FACTOR_LABELS = ENABLED_FACTORS.map(s => s.label);

// Runtime validation
if (d < 2) {
  throw new Error(`Factor registry needs ≥2 enabled factors, got ${d}`);
}
if (d > 32) {
  throw new Error(`Factor dimension ${d} too large (max 32). Use block-diagonal Λ.`);
}

// ============================================================================
// Vector/Matrix Types (with metadata)
// ============================================================================

export type FactorVector = {
  version: number;
  labels: FactorLabel[];
  values: number[];
};

export type FactorMatrix = {
  version: number;
  labels: FactorLabel[];
  matrix: number[][];
};

// Helper: create zero vector
export function zeroVector(): FactorVector {
  return {
    version: FACTORS.version,
    labels: [...FACTOR_LABELS],
    values: new Array(d).fill(0),
  };
}

// Helper: create identity matrix
export function identityMatrix(): FactorMatrix {
  const mat: number[][] = [];
  for (let i = 0; i < d; i++) {
    const row = new Array(d).fill(0);
    row[i] = 1;
    mat.push(row);
  }
  return {
    version: FACTORS.version,
    labels: [...FACTOR_LABELS],
    matrix: mat,
  };
}

// Helper: validate vector shape
export function validateVector(v: FactorVector): void {
  if (v.labels.length !== d || v.values.length !== d) {
    throw new Error(
      `Vector dimension mismatch: expected ${d}, got labels=${v.labels.length} values=${v.values.length}`
    );
  }
  if (v.version !== FACTORS.version) {
    console.warn(
      `Vector version mismatch: registry=${FACTORS.version}, data=${v.version}`
    );
  }
}

// Helper: validate matrix shape
export function validateMatrix(m: FactorMatrix): void {
  if (m.labels.length !== d || m.matrix.length !== d) {
    throw new Error(
      `Matrix dimension mismatch: expected ${d}×${d}, got ${m.matrix.length}×${m.matrix[0]?.length}`
    );
  }
  for (const row of m.matrix) {
    if (row.length !== d) {
      throw new Error(`Matrix row length mismatch: expected ${d}, got ${row.length}`);
    }
  }
  if (m.version !== FACTORS.version) {
    console.warn(
      `Matrix version mismatch: registry=${FACTORS.version}, data=${m.version}`
    );
  }
}
---------- END apps/server/src/risk/factors.ts ----------

---------- BEGIN apps/server/src/scripts/mm_sandbox.ts (bytes=7230) ----------
/**
 * Minimal MM sandbox:
 * - reads ticks from Prisma (your mock feed)
 * - builds a strike grid around the first forward
 * - each market beat, requests quotes from quoteEngine for each strike
 * - randomly fills a few quotes, updates inventory and cash P&L
 * - prints a compact summary + inventory by strike at the end
 *
 * Run:
 *   npx ts-node --transpile-only src/scripts/mm_sandbox.ts \
 *     --symbol BTC --minutes 5 --tenorDays 7 --edgeUSD 2 --fillProb 0.15
 */

import { PrismaClient } from "@prisma/client";
import yargs from "yargs";
import { hideBin } from "yargs/helpers";
import { quoteEngine } from "../quoteEngine";

type Side = "BUY" | "SELL";
type OptionType = "C" | "P";

type InvRow = {
  qty: number;      // + long, - short
  cash: number;     // realized cash from trades at our price
  lastMid: number;  // last seen ccMid to mark-to-market
  lastTs: number;
  avgPx: number;    // |cash| / |qty| when open
};

function strikeGrid(F: number, pct: number, step: number): number[] {
  const low = Math.floor((F * (1 - pct)) / step) * step;
  const high = Math.ceil((F * (1 + pct)) / step) * step;
  const out: number[] = [];
  for (let k = low; k <= high; k += step) out.push(k);
  return out;
}

function rand() { return Math.random(); }

(async () => {
  const argv = await yargs(hideBin(process.argv))
    .option("symbol", { type: "string", default: "BTC" })
    .option("minutes", { type: "number", default: 5, desc: "lookback minutes" })
    .option("tenorDays", { type: "number", default: 7 })
    .option("optionType", { type: "string", default: "P", choices: ["P","C"] })
    .option("gridPct", { type: "number", default: 0.10, desc: "±% around ATM" })
    .option("gridStep", { type: "number", default: 100 })
    .option("blockSize", { type: "number", default: 1 })
    .option("edgeUSD", { type: "number", default: 2, desc: "target quote edge in USD (informational)" })
    .option("fillProb", { type: "number", default: 0.15, desc: "chance a quote fills" })
    .option("maxPerBeat", { type: "number", default: 5, desc: "max fills per tick" })
    .help()
    .parse();

  const {
    symbol, minutes, tenorDays, optionType,
    gridPct, gridStep, blockSize, fillProb, maxPerBeat
  } = argv as any;

  const prisma = new PrismaClient();

  try {
    const endTime = Date.now();
    const startTime = endTime - Math.max(1, minutes) * 60 * 1000;

    const beats = await prisma.ticker.findMany({
      where: { instrument: "BTC-PERPETUAL", tsMs: { gte: BigInt(startTime), lte: BigInt(endTime) } },
      orderBy: { tsMs: "asc" },
      select: { tsMs: true, markPrice: true, underlying: true }
    });

    if (beats.length === 0) {
      console.log("No ticks found in the selected window. Is MOCK ingest running?");
      process.exit(0);
    }

    // anchor grid on first forward so the set of strikes is stable
    const F0 = Number(beats[0].markPrice ?? beats[0].underlying ?? 0);
    if (!Number.isFinite(F0) || F0 <= 0) {
      console.log("Invalid initial forward.");
      process.exit(1);
    }
    const strikes = strikeGrid(F0, gridPct, gridStep);
    const inventory: Record<number, InvRow> = {};
    let fills = 0;
    let cash = 0;

    // simple market IV (use your engine default if it ignores this)
    const marketIV = 0.35;

    for (const b of beats) {
      const ts = Number(b.tsMs);
      const F = Number(b.markPrice ?? b.underlying ?? 0);
      if (!Number.isFinite(F) || F <= 0) continue;

      const expiryMs = ts + Math.round(tenorDays * 24 * 3600 * 1000);
      let filledThisBeat = 0;

      for (const k of strikes) {
        if (filledThisBeat >= maxPerBeat) break;

        const q = quoteEngine.getQuote({
          symbol,
          strike: k,
          expiryMs,
          optionType: optionType as OptionType,
          marketIV
        });

        // Decide a side: sell wings, buy near ATM — extremely simple heuristic
        const rel = Math.abs(k - F) / F;
        const side: Side = rel > 0.03 ? "SELL" : "BUY";

        // stochastic fill
        if (rand() > fillProb) {
          // still record last mid for MtM even if no trade
          const mid = q.ccMid ?? q.mid ?? (q.bid + q.ask) / 2;
          const inv = inventory[k] ?? { qty: 0, cash: 0, lastMid: mid, lastTs: 0, avgPx: 0 };
          inv.lastMid = mid;
          inv.lastTs = ts;
          inventory[k] = inv;
          continue;
        }

        const px = side === "SELL" ? q.ask : q.bid;
        const mid = q.ccMid ?? q.mid ?? (q.bid + q.ask) / 2;

        if (!Number.isFinite(px) || !Number.isFinite(mid)) continue;

        // apply trade
        const inv = inventory[k] ?? { qty: 0, cash: 0, lastMid: mid, lastTs: 0, avgPx: 0 };
        const signedCash = (side === "SELL" ? +1 : -1) * px * blockSize;
        inv.cash += signedCash;
        inv.qty += (side === "SELL" ? -1 : +1) * blockSize;
        inv.lastMid = mid;
        inv.lastTs = ts;
        inv.avgPx = Math.abs(inv.qty) > 0 ? Math.abs(inv.cash) / Math.abs(inv.qty) : 0;
        inventory[k] = inv;

        cash += signedCash;
        fills += 1;
        filledThisBeat += 1;

        // (optional) tell the engine about the fill
        quoteEngine.executeTrade({
          symbol,
          strike: k,
          expiryMs,
          optionType,
          side,
          size: blockSize,
          price: px,
          timestamp: ts
        } as any);
      }
    }

    // mark-to-market close (using lastMid per strike)
    let mtmClose = 0;
    let netContracts = 0;
    for (const k of Object.keys(inventory)) {
      const inv = inventory[+k];
      mtmClose += -inv.qty * inv.lastMid;
      netContracts += inv.qty;
    }

    // --------- PRINT SUMMARY ----------
    const pad = (n: number) => n.toLocaleString(undefined, { maximumFractionDigits: 6 });
    console.log("\n--------------------------------------------------------------------------------");
    console.log(`MM Sandbox — ${symbol}`);
    console.log(`Beats:            ${beats.length}`);
    console.log(`Strikes quoted:   ${strikes.length}`);
    console.log(`Fills:            ${fills}`);
    console.log(`P&L (cash):       $${pad(cash)}`);
    console.log(`P&L (MtM open):   $${pad(mtmClose)}`);
    console.log(`P&L (total):      $${pad(cash + mtmClose)}`);
    console.log(`Net contracts:    ${netContracts}`);
    console.log("--------------------------------------------------------------------------------");

    console.log("Strike    Qty   AvgPx    LastMid   Cash       MtMClose   TotPnL");
    const ks = Object.keys(inventory).map(Number).sort((a, b) => a - b);
    for (const k of ks) {
      const inv = inventory[k];
      const mtm = -inv.qty * inv.lastMid;
      const tot = inv.cash + mtm;
      console.log(
        `${String(k).padEnd(8)} ${String(inv.qty).padStart(5)}   ${inv.avgPx.toFixed(3).padStart(6)}   ${inv.lastMid.toFixed(3).padStart(8)}   ${inv.cash.toFixed(2).padStart(9)}   ${mtm.toFixed(2).padStart(9)}   ${tot.toFixed(2).padStart(9)}`
      );
    }
    console.log("--------------------------------------------------------------------------------");

    await prisma.$disconnect();
  } catch (err) {
    await prisma.$disconnect();
    console.error(err);
    process.exit(1);
  }
})();

---------- END apps/server/src/scripts/mm_sandbox.ts ----------

---------- BEGIN apps/server/src/utils/linalg.ts (bytes=5924) ----------
// apps/server/src/utils/linalg.ts
/**
 * Lightweight linear algebra for factor risk math
 * No external dependencies - plain JS for d ≤ 32
 */

import { num } from './numeric';

// ============================================================================
// Vector operations
// ============================================================================

export function dot(a: number[], b: number[]): number {
  if (a.length !== b.length) {
    throw new Error(`dot: dimension mismatch ${a.length} vs ${b.length}`);
  }
  let sum = 0;
  for (let i = 0; i < a.length; i++) {
    sum += num(a[i], 'dot.a') * num(b[i], 'dot.b');
  }
  return sum;
}

export function norm2(v: number[]): number {
  return Math.sqrt(dot(v, v));
}

export function scale(v: number[], scalar: number): number[] {
  return v.map(x => num(x, 'scale.v') * scalar);
}

export function add(a: number[], b: number[]): number[] {
  if (a.length !== b.length) {
    throw new Error(`add: dimension mismatch ${a.length} vs ${b.length}`);
  }
  return a.map((x, i) => num(x, 'add.a') + num(b[i], 'add.b'));
}

export function subtract(a: number[], b: number[]): number[] {
  if (a.length !== b.length) {
    throw new Error(`subtract: dimension mismatch ${a.length} vs ${b.length}`);
  }
  return a.map((x, i) => num(x, 'sub.a') - num(b[i], 'sub.b'));
}

// ============================================================================
// Matrix operations
// ============================================================================

/**
 * Matrix-vector product: M * v
 */
export function matVec(M: number[][], v: number[]): number[] {
  const d = M.length;
  if (d === 0) throw new Error('matVec: empty matrix');
  if (M[0].length !== v.length) {
    throw new Error(`matVec: dimension mismatch ${M[0].length} vs ${v.length}`);
  }
  
  const result: number[] = new Array(d);
  for (let i = 0; i < d; i++) {
    result[i] = dot(M[i], v);
  }
  return result;
}

/**
 * Quadratic form: vᵀ M v
 */
export function quadForm(M: number[][], v: number[]): number {
  const Mv = matVec(M, v);
  return num(dot(v, Mv), 'quadForm');
}

/**
 * Mahalanobis norm: √(vᵀ M v)
 */
export function normMahalanobis(v: number[], M: number[][]): number {
  return Math.sqrt(Math.max(0, quadForm(M, v)));
}

/**
 * Matrix trace: sum of diagonal
 */
export function trace(M: number[][]): number {
  let sum = 0;
  for (let i = 0; i < M.length; i++) {
    sum += num(M[i][i], `trace[${i}]`);
  }
  return sum;
}

/**
 * Scale matrix by scalar: α * M
 */
export function scaleMatrix(M: number[][], alpha: number): number[][] {
  return M.map(row => row.map(x => num(x, 'scaleMatrix') * alpha));
}

/**
 * Add matrices: A + B
 */
export function addMatrix(A: number[][], B: number[][]): number[][] {
  if (A.length !== B.length) {
    throw new Error(`addMatrix: dimension mismatch`);
  }
  return A.map((row, i) => 
    row.map((x, j) => num(x, 'addMat.A') + num(B[i][j], 'addMat.B'))
  );
}

/**
 * Add ridge regularization: M + ε * (tr(M)/d) * I
 */
export function addRidge(M: number[][], epsilon: number): number[][] {
  const d = M.length;
  const tr = trace(M);
  const ridgeScale = epsilon * (tr / d);
  
  return M.map((row, i) => 
    row.map((x, j) => 
      i === j ? num(x, 'ridge') + ridgeScale : num(x, 'ridge')
    )
  );
}

/**
 * Outer product: u ⊗ v (returns u * vᵀ)
 */
export function outerProduct(u: number[], v: number[]): number[][] {
  const result: number[][] = [];
  for (let i = 0; i < u.length; i++) {
    const row: number[] = [];
    for (let j = 0; j < v.length; j++) {
      row.push(num(u[i], 'outer.u') * num(v[j], 'outer.v'));
    }
    result.push(row);
  }
  return result;
}

// ============================================================================
// Eigenvalue utilities (simplified - for diagnostics only)
// ============================================================================

/**
 * Power iteration to find largest eigenvalue (for condition number)
 * Not production-grade, but good enough for monitoring
 */
export function largestEigenvalue(M: number[][], maxIter = 100): number {
  const d = M.length;
  let v = new Array(d).fill(1 / Math.sqrt(d)); // normalized random start
  
  for (let iter = 0; iter < maxIter; iter++) {
    const Mv = matVec(M, v);
    const lambda = dot(v, Mv);
    const norm = norm2(Mv);
    
    if (norm < 1e-12) return 0; // degenerate
    v = scale(Mv, 1 / norm);
    
    // Check convergence
    if (iter > 10 && Math.abs(lambda - dot(v, matVec(M, v))) < 1e-9) {
      return lambda;
    }
  }
  
  return dot(v, matVec(M, v));
}

/**
 * Estimate smallest eigenvalue via inverse iteration
 * (Very rough - just for monitoring)
 */
export function smallestEigenvalue(M: number[][], maxIter = 50): number {
  // Add tiny ridge to avoid singularity in inverse iteration
  const Mreg = addRidge(M, 1e-10);
  
  // This is a hack - in production you'd use proper eigendecomposition
  // For now, just return min diagonal element as lower bound
  let minDiag = Infinity;
  for (let i = 0; i < M.length; i++) {
    minDiag = Math.min(minDiag, M[i][i]);
  }
  return Math.max(0, minDiag * 0.1); // very conservative estimate
}

/**
 * Condition number: max(eigval) / min(eigval)
 */
export function conditionNumber(M: number[][]): number {
  const maxEig = largestEigenvalue(M);
  const minEig = smallestEigenvalue(M);
  if (minEig < 1e-12) return Infinity;
  return maxEig / minEig;
}

/**
 * Check if matrix is positive definite (diagonal dominant heuristic)
 * Not rigorous, but fast screening
 */
export function isPDHeuristic(M: number[][]): boolean {
  const d = M.length;
  for (let i = 0; i < d; i++) {
    if (M[i][i] <= 0) return false;
    
    let offDiagSum = 0;
    for (let j = 0; j < d; j++) {
      if (i !== j) offDiagSum += Math.abs(M[i][j]);
    }
    
    // Diagonal dominance check
    if (M[i][i] < offDiagSum) return false;
  }
  return true;
}
---------- END apps/server/src/utils/linalg.ts ----------

---------- BEGIN apps/server/src/utils/numeric.ts (bytes=2419) ----------
// apps/server/src/utils/numeric.ts
/**
 * Phase 1: Numeric safety guards and deterministic operations
 */

const WARNED_TAGS = new Set<string>();

/**
 * Guard against NaN/Infinity with once-per-tag warning
 * Returns 0 if invalid, otherwise returns x unchanged
 */
export function num(x: number, tag: string): number {
  if (Number.isFinite(x)) return x;
  
  if (!WARNED_TAGS.has(tag)) {
    console.warn(`[numeric] Non-finite value at "${tag}": ${x}`);
    WARNED_TAGS.add(tag);
  }
  
  return 0;
}

/**
 * Clamp value to [min, max]
 */
export function clamp(x: number, min: number, max: number): number {
  return Math.max(min, Math.min(max, num(x, 'clamp')));
}

/**
 * Deterministic sum over object values (sorted keys)
 */
export function deterministicSum(obj: Record<string, number>): number {
  const keys = Object.keys(obj).sort();
  let sum = 0;
  for (const k of keys) {
    sum += num(obj[k], `sum[${k}]`);
  }
  return sum;
}

/**
 * Deterministic sum over Map (sorted keys)
 */
export function deterministicMapSum(map: Map<string, number>): number {
  const keys = Array.from(map.keys()).sort();
  let sum = 0;
  for (const k of keys) {
    sum += num(map.get(k)!, `map[${k}]`);
  }
  return sum;
}

/**
 * Seeded PRNG (for deterministic fills in SimAdapter)
 * Simple LCG: x_n+1 = (a * x_n + c) mod m
 */
export class SeededRandom {
  private state: number;
  
  constructor(seed: number) {
    this.state = seed % 2147483647;
    if (this.state <= 0) this.state += 2147483646;
  }
  
  /**
   * Returns [0, 1)
   */
  next(): number {
    this.state = (this.state * 48271) % 2147483647;
    return (this.state - 1) / 2147483646;
  }
  
  /**
   * Returns normally distributed value (Box-Muller)
   */
  nextGaussian(): number {
    const u1 = this.next();
    const u2 = this.next();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
}

/**
 * Hash string to 32-bit integer (for seeding)
 */
export function hashString(str: string): number {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  return Math.abs(hash);
}

/**
 * Create deterministic RNG from timestamp + symbol
 */
export function createDeterministicRNG(ts: number, symbol: string): SeededRandom {
  const seed = ts ^ hashString(symbol);
  return new SeededRandom(seed);
}
---------- END apps/server/src/utils/numeric.ts ----------

---------- BEGIN apps/server/src/utils/time.test.ts (bytes=495) ----------
import { timeToExpiryYears } from "./time";

describe("timeToExpiryYears", () => {
  test("converts ~30 days to ~0.082 years", () => {
    const now = Date.now();
    const ms30 = 30 * 24 * 3600 * 1000;
    const T = timeToExpiryYears(now + ms30, now);
    expect(T).toBeGreaterThan(0.08 - 0.005);
    expect(T).toBeLessThan(0.09 + 0.005);
  });

  test("non-negative clamp", () => {
    const now = Date.now();
    const T = timeToExpiryYears(now - 1234, now);
    expect(T).toBe(0);
  });
});

---------- END apps/server/src/utils/time.test.ts ----------

---------- BEGIN apps/server/src/utils/time.ts (bytes=194) ----------
export function timeToExpiryYears(expiryMs: number, now: number = Date.now()): number {
    const msInYear = 365 * 24 * 60 * 60 * 1000;
    return Math.max((expiryMs - now) / msInYear, 0);
  }


---------- END apps/server/src/utils/time.ts ----------

---------- BEGIN apps/server/src/volModels/ParametricSurface.ts (bytes=3429) ----------
import { VolModelParams, VolModel } from './types.ts';

// Basis functions (smooth bumps in moneyness space)
function gaussianBump(m: number, center: number, width: number): number {
  return Math.exp(-Math.pow((m - center) / width, 2) / 2);
}

export class ParametricSurface implements VolModel {
  // Delta to moneyness mapping (approximate for given TTX and vol)
  private deltaToMoneyness(delta: number, vol: number, ttx: number): number {
    // For puts: delta is negative, for calls: positive
    // Approximate: m ≈ -vol * sqrt(ttx) * N^(-1)(|delta|)
    const absDelta = Math.abs(delta);
    const z = this.inverseNormal(absDelta);
    return -Math.sign(delta - 0.5) * vol * Math.sqrt(ttx) * z;
  }

  private inverseNormal(p: number): number {
    // Approximate inverse normal CDF for delta->moneyness
    if (p <= 0 || p >= 1) return 0;
    const a = [2.515517, 0.802853, 0.010328];
    const b = [1.432788, 0.189269, 0.001308];
    const t = Math.sqrt(-2 * Math.log(Math.min(p, 1 - p)));
    const num = a[0] + t * (a[1] + t * a[2]);
    const den = 1 + t * (b[0] + t * (b[1] + t * b[2]));
    return (p > 0.5 ? 1 : -1) * (t - num / den);
  }

  getIV(moneyness: number, params: VolModelParams): number {
    const { vol, skew, pump, wingPut, wingCall } = params;
    
    // Base quadratic in moneyness
    const base = vol + 0.5 * vol * moneyness * moneyness;
    
    // Skew component (max at ±25Δ ≈ ±0.15 moneyness for typical vol/ttx)
    const skewBump = skew * moneyness * gaussianBump(moneyness, 0, 0.2);
    
    // Pump component (symmetric at ±15Δ ≈ ±0.25 moneyness)
    const pumpBump = pump * (
      gaussianBump(moneyness, -0.25, 0.15) + 
      gaussianBump(moneyness, 0.25, 0.15)
    );
    
    // Wing components (10Δ ≈ ±0.35 moneyness)
    const putWingBump = wingPut * gaussianBump(moneyness, -0.35, 0.15);
    const callWingBump = wingCall * gaussianBump(moneyness, 0.35, 0.15);
    
    return base + skewBump + pumpBump + putWingBump + callWingBump;
  }

  calibrate(strikes: number[], ivs: number[], spot: number): VolModelParams {
    const moneynesses = strikes.map(k => Math.log(k / spot));
    
    // ATM vol (closest to moneyness = 0)
    const atmIdx = moneynesses.reduce((prev, curr, idx) => 
      Math.abs(curr) < Math.abs(moneynesses[prev]) ? idx : prev, 0
    );
    const vol = ivs[atmIdx];
    
    // Find deep OTM put (most negative moneyness)
    const putIdx = moneynesses.reduce((minIdx, curr, idx) => 
      curr < moneynesses[minIdx] ? idx : minIdx, 0
    );
    
    // Find deep OTM call (most positive moneyness)
    const callIdx = moneynesses.reduce((maxIdx, curr, idx) => 
      curr > moneynesses[maxIdx] ? idx : maxIdx, 0
    );
    
    // Skew: difference between put wing and call wing IVs
    const skew = putIdx !== callIdx 
      ? (ivs[putIdx] - ivs[callIdx]) * 0.5  // Scale down because basis function amplifies
      : 0;
    
    console.log(`Calibration: ATM=${vol.toFixed(4)}, Put IV=${ivs[putIdx].toFixed(4)} at m=${moneynesses[putIdx].toFixed(3)}, Call IV=${ivs[callIdx].toFixed(4)} at m=${moneynesses[callIdx].toFixed(3)}, Skew=${skew.toFixed(4)}`);
    
    return { vol, skew, pump: 0, wingPut: 0, wingCall: 0, volPathRate: 0 };
  }

  reprice(strikes: number[], spot: number, params: VolModelParams): number[] {
    return strikes.map(k => {
      const m = Math.log(k / spot);
      return this.getIV(m, params);
    });
  }
}
---------- END apps/server/src/volModels/ParametricSurface.ts ----------

---------- BEGIN apps/server/src/volModels/config/modelConfig.ts (bytes=4608) ----------
/**
 * Model Configuration
 * Centralized config for the dual surface model
 */

export interface EdgeParams {
    E0: number;      // Base edge in ticks
    kappa: number;   // Scale factor
    gamma: number;   // Curvature (1=linear, >1=convex)
    Vref: number;    // Reference vega for normalization
  }
  
  export interface DeltaBucket {
    name: string;
    minDelta: number;
    maxDelta: number;
    edgeParams: EdgeParams;
  }
  
  export interface ModelConfig {
    // SVI parameter bounds
    svi: {
      bMin: number;
      sigmaMin: number;
      rhoMax: number;
      slopeMax: number;
      c0Min: number;
    };
    
    // Delta buckets with edge parameters
    buckets: DeltaBucket[];
    
    // RBF bump parameters
    rbf: {
      width: number;       // Width in log-moneyness space
      ridgeLambda: number; // Regularization for bump solver
    };
    
    // Risk controller limits (per update)
    riskLimits: {
      maxL0Move: number;   // Max ATM vol move
      maxS0Move: number;   // Max skew move
      maxC0Move: number;   // Max curvature move
    };
    
    // Inventory hysteresis
    inventory: {
      hysteresis: number;  // As fraction of Vref
      minTradesForUpdate: number;
    };
    
    // Quote parameters
    quotes: {
      minSpread: number;   // Minimum half-spread in ticks
      touchPremium: number; // Extra spread near ATM
      sizeBlocks: number;   // Quote size increments
      staleHours: number;  // Hours before PC drifts to CC
    };
  }
  
  /**
   * Get default configuration for a product
   */
  export function getDefaultConfig(product: 'BTC' | 'ETH' | 'SPX' = 'BTC'): ModelConfig {
    // Product-specific adjustments
    const productMultipliers = {
      BTC: { edge: 1.0, risk: 1.0 },
      ETH: { edge: 1.2, risk: 1.2 },
      SPX: { edge: 0.5, risk: 0.8 }
    };
    
    const mult = productMultipliers[product];
    
    return {
      svi: {
        bMin: 1e-6,
        sigmaMin: 1e-3,
        rhoMax: 0.995,
        slopeMax: 2.0,
        c0Min: 1e-4
      },
      
      buckets: [
        {
          name: 'atm',
          minDelta: 0.45,
          maxDelta: 0.55,
          edgeParams: {
            E0: 2.0 * mult.edge,
            kappa: 5.0 * mult.edge,
            gamma: 1.5,
            Vref: 20.0
          }
        },
        {
          name: 'rr25',
          minDelta: 0.20,
          maxDelta: 0.30,
          edgeParams: {
            E0: 1.0 * mult.edge,
            kappa: 3.0 * mult.edge,
            gamma: 1.4,
            Vref: 30.0
          }
        },
        {
          name: 'rr10',
          minDelta: 0.08,
          maxDelta: 0.12,
          edgeParams: {
            E0: 0.5 * mult.edge,
            kappa: 2.0 * mult.edge,
            gamma: 1.3,
            Vref: 40.0
          }
        },
        {
          name: 'wings',
          minDelta: 0.00,
          maxDelta: 0.08,
          edgeParams: {
            E0: 0.3 * mult.edge,
            kappa: 1.5 * mult.edge,
            gamma: 1.2,
            Vref: 50.0
          }
        }
      ],
      
      rbf: {
        width: 0.15,
        ridgeLambda: 1e-3
      },
      
      riskLimits: {
        maxL0Move: 0.5 * mult.risk,
        maxS0Move: 0.2 * mult.risk,
        maxC0Move: 0.05 * mult.risk
      },
      
      inventory: {
        hysteresis: 0.2,
        minTradesForUpdate: 1
      },
      
      quotes: {
        minSpread: 0.5,
        touchPremium: 0.2,
        sizeBlocks: 100,
        staleHours: 24
      }
    };
  }
  
  /**
   * Validate configuration
   */
  export function validateConfig(config: ModelConfig): { valid: boolean; errors: string[] } {
    const errors: string[] = [];
    
    // Check SVI bounds
    if (config.svi.rhoMax >= 1) {
      errors.push('rhoMax must be < 1');
    }
    
    // Check buckets don't overlap
    for (let i = 0; i < config.buckets.length - 1; i++) {
      for (let j = i + 1; j < config.buckets.length; j++) {
        const b1 = config.buckets[i];
        const b2 = config.buckets[j];
        
        if (!(b1.maxDelta < b2.minDelta || b2.maxDelta < b1.minDelta)) {
          errors.push(`Buckets ${b1.name} and ${b2.name} overlap`);
        }
      }
    }
    
    // Check edge parameters
    for (const bucket of config.buckets) {
      if (bucket.edgeParams.gamma < 1) {
        errors.push(`Bucket ${bucket.name} has gamma < 1 (must be convex)`);
      }
      if (bucket.edgeParams.Vref <= 0) {
        errors.push(`Bucket ${bucket.name} has invalid Vref`);
      }
    }
    
    return {
      valid: errors.length === 0,
      errors
    };
  }
---------- END apps/server/src/volModels/config/modelConfig.ts ----------

---------- BEGIN apps/server/src/volModels/controllers/inventoryController.ts (bytes=12927) ----------
/**
 * Inventory Controller
 * Manages inventory-locked bumps for PC (Price Curve)
 * Bumps are deterministic functions of inventory - no time decay
 */

import { Bump, SVIParams, SVI } from '../dualSurfaceModel';
import { ModelConfig } from '../config/modelConfig';
import { blackScholes, DeltaConventions, PriceVolConverter } from '../pricing/blackScholes';

export interface BucketInventory {
  bucket: string;
  signedVega: number;  // Negative = short
  count: number;       // Number of trades
  lastUpdate: number;  // Timestamp
}

export interface InventoryState {
  byBucket: Map<string, BucketInventory>;
  byStrike: Map<number, number>;  // Strike -> position
  totalVega: number;
}

/**
 * Calculate edge requirement from inventory
 */
export class EdgeLadder {
  /**
   * Calculate required edge in ticks for a bucket
   */
  static calculateEdge(
    inventory: number,  // Signed vega
    config: ModelConfig,
    bucket: string
  ): number {
    const bucketConfig = config.buckets.find(b => b.name === bucket);
    if (!bucketConfig) return 0;
    
    const { E0, kappa, gamma, Vref } = bucketConfig.edgeParams;
    
    // Edge ladder formula: -sign(I) * (E0 + kappa * (|I|/Vref)^gamma)
    // Negative sign because: SHORT position → want PC > CC → positive edge
    const sign = -Math.sign(inventory);
    const normalized = Math.abs(inventory) / Vref;
    const edge = sign * (E0 + kappa * Math.pow(normalized, gamma));
    
    return edge;
  }
  
  /**
   * Calculate edge with size adjustment
   */
  static calculateEdgeWithSize(
    inventory: number,
    size: number,  // Quote size
    config: ModelConfig,
    bucket: string
  ): number {
    const baseEdge = this.calculateEdge(inventory, config, bucket);
    
    // Size adjustment (optional)
    const sizeRef = 100;  // Reference size
    const sizeMultiplier = 1 + 0.2 * Math.pow(size / sizeRef, 1.2);
    
    return baseEdge * sizeMultiplier;
  }
}

/**
 * Convert edge to variance bumps
 */
export class BumpSolver {
  /**
   * Convert cash edge to variance target
   */
  static edgeToVarianceTarget(
    edge: number,  // In ticks
    k: number,     // Log-moneyness
    cc: SVIParams, // Core surface
    T: number,     // Time to expiry
    spot: number,
    tickValue: number = 0.01
  ): number {
    // Get core IV at this strike
    const variance = SVI.w(cc, k);
    const iv = PriceVolConverter.varianceToIV(variance, T);
    
    // Calculate vega at this point
    const strike = spot * Math.exp(k);
    const greeks = blackScholes({
      strike,
      spot,
      vol: iv,
      T,
      r: 0,
      isCall: false
    });
    
    // Convert edge in ticks to price units
    // For options, 1 tick = tickValue of the option price
    const priceEdge = edge * tickValue;
    
    // Convert price edge to variance adjustment
    // Using vega: dPrice/dVol ≈ vega, so dVol ≈ dPrice/vega
    // But we need variance, not vol: dVariance = 2*σ*T*dVol
    const volChange = priceEdge / Math.max(greeks.vega, 0.1);
    const deltaW = 2 * iv * T * volChange / 100;  // Divide by 100 as vega is per 1% move
    
    return deltaW;
  }
  
  /**
   * Solve for RBF amplitudes given targets
   */
  static solveForBumps(
    targets: Array<{ k: number; deltaW: number }>,
    centers: number[],
    width: number = 0.15,
    ridgeLambda: number = 1e-3
  ): number[] {
    const n = targets.length;
    const m = centers.length;
    
    // Build design matrix (Φ)
    const phi: number[][] = [];
    const y: number[] = [];
    
    for (let i = 0; i < n; i++) {
      phi[i] = [];
      for (let j = 0; j < m; j++) {
        // Gaussian RBF
        const dist = (targets[i].k - centers[j]) / width;
        phi[i][j] = Math.exp(-0.5 * dist * dist);
      }
      y[i] = targets[i].deltaW;
    }
    
    // Ridge regression: (Φ'Φ + λI)α = Φ'y
    // Simplified solver - in production use proper linear algebra library
    const alphas = this.ridgeRegression(phi, y, ridgeLambda);
    
    return alphas;
  }
  
  /**
   * Simple ridge regression solver
   */
  private static ridgeRegression(
    X: number[][],
    y: number[],
    lambda: number
  ): number[] {
    const n = X.length;
    const m = X[0].length;
    
    // Compute X'X
    const XtX: number[][] = [];
    for (let i = 0; i < m; i++) {
      XtX[i] = [];
      for (let j = 0; j < m; j++) {
        let sum = 0;
        for (let k = 0; k < n; k++) {
          sum += X[k][i] * X[k][j];
        }
        XtX[i][j] = sum + (i === j ? lambda : 0);  // Add ridge
      }
    }
    
    // Compute X'y
    const Xty: number[] = [];
    for (let i = 0; i < m; i++) {
      let sum = 0;
      for (let k = 0; k < n; k++) {
        sum += X[k][i] * y[k];
      }
      Xty[i] = sum;
    }
    
    // Solve using Gaussian elimination (simplified)
    // In production, use a proper linear algebra library
    return this.gaussianElimination(XtX, Xty);
  }
  
  /**
   * Gaussian elimination solver
   */
  private static gaussianElimination(A: number[][], b: number[]): number[] {
    const n = b.length;
    const augmented: number[][] = [];
    
    // Create augmented matrix
    for (let i = 0; i < n; i++) {
      augmented[i] = [...A[i], b[i]];
    }
    
    // Forward elimination
    for (let i = 0; i < n; i++) {
      // Partial pivoting
      let maxRow = i;
      for (let k = i + 1; k < n; k++) {
        if (Math.abs(augmented[k][i]) > Math.abs(augmented[maxRow][i])) {
          maxRow = k;
        }
      }
      [augmented[i], augmented[maxRow]] = [augmented[maxRow], augmented[i]];
      
      // Make all rows below this one 0 in current column
      for (let k = i + 1; k < n; k++) {
        const factor = augmented[k][i] / augmented[i][i];
        for (let j = i; j <= n; j++) {
          augmented[k][j] -= factor * augmented[i][j];
        }
      }
    }
    
    // Back substitution
    const x: number[] = new Array(n).fill(0);
    for (let i = n - 1; i >= 0; i--) {
      x[i] = augmented[i][n];
      for (let j = i + 1; j < n; j++) {
        x[i] -= augmented[i][j] * x[j];
      }
      x[i] /= augmented[i][i];
    }
    
    return x;
  }
}

/**
 * Main inventory controller
 */
export class InventoryController {
  private inventory: InventoryState;
  private config: ModelConfig;
  private lastBumpUpdate: Map<string, number>;
  
  constructor(config: ModelConfig) {
    this.config = config;
    this.inventory = {
      byBucket: new Map(),
      byStrike: new Map(),
      totalVega: 0
    };
    this.lastBumpUpdate = new Map();
  }
  
  /**
   * Update inventory after a trade
   */
  updateInventory(
    strike: number,
    size: number,  // Positive = bought, negative = sold
    vega: number,
    bucket: string
  ): void {
    // Update strike-level inventory
    const currentPos = this.inventory.byStrike.get(strike) || 0;
    this.inventory.byStrike.set(strike, currentPos + size);
    
    // Update bucket inventory
    let bucketInv = this.inventory.byBucket.get(bucket);
    if (!bucketInv) {
      bucketInv = {
        bucket,
        signedVega: 0,
        count: 0,
        lastUpdate: Date.now()
      };
      this.inventory.byBucket.set(bucket, bucketInv);
    }
    
    bucketInv.signedVega += size * vega;  // size is signed
    bucketInv.count += 1;
    bucketInv.lastUpdate = Date.now();
    
    // Update total
    this.inventory.totalVega += size * vega;
  }
  
  /**
   * Check if bumps need updating (hysteresis)
   */
  needsBumpUpdate(bucket: string): boolean {
    const bucketInv = this.inventory.byBucket.get(bucket);
    if (!bucketInv) return false;
    
    const lastUpdate = this.lastBumpUpdate.get(bucket) || 0;
    const timeSinceUpdate = Date.now() - lastUpdate;
    
    // Update if:
    // 1. Never updated
    // 2. Significant inventory change (hysteresis)
    // 3. Enough trades accumulated
    
    const bucketConfig = this.config.buckets.find(b => b.name === bucket);
    if (!bucketConfig) return false;
    
    const threshold = bucketConfig.edgeParams.Vref * this.config.inventory.hysteresis;
    const vegaChange = Math.abs(bucketInv.signedVega);
    
    return (
      lastUpdate === 0 ||
      vegaChange > threshold ||
      bucketInv.count >= this.config.inventory.minTradesForUpdate
    );
  }
  
  /**
   * Generate bumps for a bucket
   */
  generateBumps(
    bucket: string,
    cc: SVIParams,
    T: number,
    spot: number,
    strikes: number[]  // Representative strikes for this bucket
  ): Bump[] {
    const bucketInv = this.inventory.byBucket.get(bucket);
    if (!bucketInv || Math.abs(bucketInv.signedVega) < 1e-6) {
      return [];
    }
    
    // Calculate required edge
    const edge = EdgeLadder.calculateEdge(
      bucketInv.signedVega,
      this.config,
      bucket
    );
    
    if (Math.abs(edge) < 0.01) {
      return [];
    }
    
    // Create targets at representative strikes
    const targets: Array<{ k: number; deltaW: number }> = [];
    const centers: number[] = [];
    
    for (const strike of strikes) {
      const k = Math.log(strike / spot);
      const deltaW = BumpSolver.edgeToVarianceTarget(
        edge,
        k,
        cc,
        T,
        spot
      );
      
      targets.push({ k, deltaW });
      centers.push(k);
    }
    
    // Solve for amplitudes
    const alphas = BumpSolver.solveForBumps(
      targets,
      centers,
      this.config.rbf.width,
      this.config.rbf.ridgeLambda
    );
    
    // Create bumps - use tighter width for better localization
    const bumps: Bump[] = [];
    for (let i = 0; i < centers.length; i++) {
      if (Math.abs(alphas[i]) > 1e-6) {
        bumps.push({
          k: centers[i],
          alpha: alphas[i],
          lam: this.config.rbf.width * 0.5,  // Use half the configured width for tighter bumps
          bucket
        });
      }
    }
    
    // Mark update time
    this.lastBumpUpdate.set(bucket, Date.now());
    
    return bumps;
  }
  
  /**
   * Rebase bumps when CC moves
   */
  rebaseBumps(
    oldCC: SVIParams,
    newCC: SVIParams,
    existingBumps: Bump[],
    T: number,
    spot: number
  ): Bump[] {
    // Group bumps by bucket
    const bumpsByBucket = new Map<string, Bump[]>();
    for (const bump of existingBumps) {
      const bucketBumps = bumpsByBucket.get(bump.bucket) || [];
      bucketBumps.push(bump);
      bumpsByBucket.set(bump.bucket, bucketBumps);
    }
    
    // Rebase each bucket
    const newBumps: Bump[] = [];
    
    for (const [bucket, oldBumps] of bumpsByBucket) {
      const bucketInv = this.inventory.byBucket.get(bucket);
      if (!bucketInv) continue;
      
      // Get strikes from old bumps
      const strikes = oldBumps.map(b => spot * Math.exp(b.k));
      
      // Generate new bumps with same edge requirement but new CC
      const rebasedBumps = this.generateBumps(
        bucket,
        newCC,
        T,
        spot,
        strikes
      );
      
      newBumps.push(...rebasedBumps);
    }
    
    return newBumps;
  }
  
  /**
   * Get current inventory state
   */
  getInventoryState(): InventoryState {
    return { ...this.inventory };
  }
  
  /**
   * Clear inventory for a bucket
   */
  clearBucket(bucket: string): void {
    this.inventory.byBucket.delete(bucket);
    this.lastBumpUpdate.delete(bucket);
  }
  
  /**
   * Get edge requirement for current inventory
   */
  getCurrentEdge(bucket: string): number {
    const bucketInv = this.inventory.byBucket.get(bucket);
    if (!bucketInv) return 0;
    
    return EdgeLadder.calculateEdge(
      bucketInv.signedVega,
      this.config,
      bucket
    );
  }
}

/**
 * Test the inventory controller
 */
export function testInventoryController(): void {
  console.log('Testing Inventory Controller...\n');
  
  const config = {
    buckets: [{
      name: 'rr25',
      minDelta: 0.20,
      maxDelta: 0.30,
      edgeParams: {
        E0: 1.0,
        kappa: 3.0,
        gamma: 1.4,
        Vref: 100.0
      }
    }],
    rbf: {
      width: 0.15,
      ridgeLambda: 1e-3
    },
    inventory: {
      hysteresis: 0.2,
      minTradesForUpdate: 1
    }
  } as ModelConfig;
  
  const controller = new InventoryController(config);
  
  // Simulate selling 100 lots
  controller.updateInventory(95, -100, 0.5, 'rr25');
  
  const edge = controller.getCurrentEdge('rr25');
  console.log(`After selling 100 lots:`);
  console.log(`  Inventory: -50 vega`);
  console.log(`  Required edge: ${edge.toFixed(2)} ticks`);
  console.log(`  Direction: ${edge > 0 ? 'PC > CC (discourage selling)' : 'PC < CC'}`);
  
  // Generate bumps
  const cc: SVIParams = {
    a: 0.03,
    b: 0.5,
    rho: -0.2,
    sigma: 0.2,
    m: 0
  };
  
  const bumps = controller.generateBumps('rr25', cc, 0.25, 100, [95]);
  console.log(`\nGenerated ${bumps.length} bump(s)`);
  
  if (bumps.length > 0) {
    console.log(`  Bump at k=${bumps[0].k.toFixed(3)}, alpha=${bumps[0].alpha.toFixed(4)}`);
  }
}
---------- END apps/server/src/volModels/controllers/inventoryController.ts ----------

---------- BEGIN apps/server/src/volModels/correctedAdapter.ts (bytes=3138) ----------
/**
 * Corrected Adapter with Proper Trade Side Logic
 */

import { IntegratedSmileModel, TradeExecution } from './integratedSmileModel';

export type CustomerSide = 'BUY' | 'SELL';
export type MarketMakerPosition = 'LONG' | 'SHORT';

export class CorrectedAdapter {
  private model: IntegratedSmileModel;
  private spot: number;
  private expiry: number = 0.08;
  private debug: boolean = false;

  constructor(spot: number, debug: boolean = false) {
    this.spot = spot;
    this.debug = debug;
    this.model = new IntegratedSmileModel('BTC');
    if (this.debug) {
      console.log('Model initialized - surfaces will auto-create on first quote');
    }
  }

  updateSpot(newSpot: number): void {
    this.spot = newSpot;
    console.log(`CorrectedAdapter spot updated to ${newSpot}`);
  }

  getQuote(strike: number, expiry: number = this.expiry, marketIV?: number) {
    // Pass spot to the model's getQuote method
    return this.model.getQuote(expiry, strike, this.spot, marketIV);
  }

  executeCustomerTrade(
    strike: number, 
    expiry: number = this.expiry,
    customerSide: CustomerSide,
    size: number,
    price?: number
  ) {
    if (!price) {
      const quote = this.getQuote(strike, expiry);
      price = customerSide === 'BUY' ? quote.ask : quote.bid;
    }

    const ourPositionChange = customerSide === 'BUY' ? -size : size;
    const ourAction = customerSide === 'BUY' ? 'SELLING' : 'BUYING';
    const resultingPosition: MarketMakerPosition = customerSide === 'BUY' ? 'SHORT' : 'LONG';
    
    if (this.debug) {
      console.log(`\n📊 Trade Execution:`);
      console.log(`  Customer: ${customerSide}S ${size} @ ${price.toFixed(2)}`);
      console.log(`  We are: ${ourAction} (position change: ${ourPositionChange > 0 ? '+' : ''}${ourPositionChange})`);
      console.log(`  Result: Getting ${resultingPosition}`);
      console.log(`  Expected: Vols should ${resultingPosition === 'SHORT' ? 'RISE ↑' : 'FALL ↓'}`);
    }

    const trade: TradeExecution = {
      expiry,
      strike,
      price,
      size: ourPositionChange,
      spot: this.spot,
      time: Date.now()
    };
    
    this.model.onTrade(trade);
    
    return {
      customerSide,
      ourAction,
      strike,
      price,
      size,
      ourPositionChange,
      resultingPosition
    };
  }

  getInventory() {
    return this.model.getInventorySummary();
  }

  formatQuotes(strikes: number[], expiry: number = this.expiry) {
    console.log('\nStrike | Bid    | Ask    | Edge  | Size  | Mid Vol');
    console.log('---------------------------------------------------');
    
    for (const strike of strikes) {
      const q = this.getQuote(strike, expiry);
      const midPrice = (q.bid + q.ask) / 2;
      const midVol = Math.sqrt(midPrice / (this.spot * 0.4) / expiry) * 100;
      
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${q.bid.toFixed(2).padStart(6)} | ` +
        `${q.ask.toFixed(2).padStart(6)} | ` +
        `${q.edge.toFixed(2).padStart(5)} | ` +
        `${q.bidSize}/${q.askSize.toString().padEnd(3)} | ` +
        `${midVol.toFixed(1)}%`
      );
    }
  }
}
---------- END apps/server/src/volModels/correctedAdapter.ts ----------

---------- BEGIN apps/server/src/volModels/diagnostics.ts (bytes=3312) ----------
/**
 * Diagnose the PC bump issue
 */

import { IntegratedDualSurface, TradeExecution } from './integratedModel';
import { TraderMetrics } from './dualSurfaceModel';

function diagnose() {
  console.log('\n=== DIAGNOSING PC BUMP ISSUE ===\n');
  
  const model = new IntegratedDualSurface('BTC');
  
  // Setup
  const expiry = 0.25;
  const spot = 100;
  
  const metrics: TraderMetrics = {
    L0: 0.04,    // 20% vol
    S0: 0.001,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, metrics);
  
  // Get quote before trade
  const strike = 95;
  const quoteBefore = model.getQuote(expiry, strike, spot);
  console.log(`Before trade - K=${strike}:`);
  console.log(`  CC Mid: ${quoteBefore.ccMid.toFixed(2)}`);
  console.log(`  PC Mid: ${quoteBefore.pcMid.toFixed(2)}`);
  console.log(`  Edge: ${quoteBefore.edge.toFixed(2)}`);
  console.log(`  Bucket: ${quoteBefore.bucket}`);
  
  // Execute trade
  const trade: TradeExecution = {
    expiry,
    strike: 95,
    price: 5.34,  // Use the actual mid price
    size: -100,
    spot,
    time: Date.now()
  };
  
  console.log(`\nExecuting trade: Sell 100 lots at ${trade.price}`);
  model.onTrade(trade);
  
  // Check inventory
  const inventory = model.getInventorySummary();
  console.log(`\nAfter selling 100 lots:`);
  console.log(`  Total Vega: ${inventory.totalVega.toFixed(1)}`);
  
  // Show edges for all buckets
  console.log(`\nEdge requirements by bucket:`);
  for (const [bucket, edge] of Object.entries(inventory.edges)) {
    const bucketInv = (inventory.byBucket as any)[bucket];
    if (bucketInv) {
      console.log(`  ${bucket}: ${bucketInv.vega.toFixed(1)} vega → ${(edge as number).toFixed(2)} ticks edge`);
    }
  }
  
  // Get quotes after trade for different strikes
  console.log(`\nPost-trade quotes:`);
  console.log(`Strike | Bucket | PC Mid | CC Mid | Edge   | Bid    | Ask`);
  console.log('-'.repeat(65));
  
  const testStrikes = [90, 95, 100, 105, 110];
  for (const k of testStrikes) {
    const q = model.getQuote(expiry, k, spot);
    const marker = k === strike ? ' ← traded' : '';
    console.log(
      `${k.toString().padStart(6)} | ` +
      `${q.bucket.padEnd(6)} | ` +
      `${q.pcMid.toFixed(2).padStart(6)} | ` +
      `${q.ccMid.toFixed(2).padStart(6)} | ` +
      `${q.edge.toFixed(2).padStart(6)} | ` +
      `${q.bid.toFixed(2).padStart(6)} | ` +
      `${q.ask.toFixed(2).padStart(6)}${marker}`
    );
  }
  
  // Analyze the problem
  console.log('\n=== ANALYSIS ===\n');
  
  const q95 = model.getQuote(expiry, 95, spot);
  const q90 = model.getQuote(expiry, 90, spot);
  
  console.log('Issue 1: PC is moving too much');
  console.log(`  95 strike edge: ${q95.edge.toFixed(2)} ticks (reasonable)`);
  console.log(`  90 strike edge: ${q90.edge.toFixed(2)} ticks (way too high!)`);
  
  console.log('\nIssue 2: Bumps affecting wrong strikes');
  console.log('  The 90 strike is in a different bucket but still affected');
  console.log('  This suggests bumps are too wide or miscalculated');
  
  console.log('\nLikely causes:');
  console.log('  1. Bump amplitude calculation is wrong (variance vs price units)');
  console.log('  2. Bump width is too large (affects too many strikes)');
  console.log('  3. Edge-to-variance conversion has wrong scaling');
}

diagnose();
---------- END apps/server/src/volModels/diagnostics.ts ----------

---------- BEGIN apps/server/src/volModels/dualSurfaceModel.ts (bytes=16556) ----------
/**
 * Dual Surface Volatility Model
 * Core implementation with CC (belief) and PC (price curve) separation
 */

// ============================================================================
// CORE DATA STRUCTURES
// ============================================================================

export interface SVIParams {
    a: number;
    b: number;
    rho: number;
    sigma: number;
    m: number;
  }
  
  export interface TraderMetrics {
    L0: number;    // ATM total variance
    S0: number;    // ATM skew
    C0: number;    // ATM curvature
    S_neg: number; // Left wing slope
    S_pos: number; // Right wing slope
  }
  
  export interface Bump {
    k: number;       // Center in log-moneyness
    alpha: number;   // Amplitude in variance space
    lam: number;     // Width parameter
    bucket: string;  // Delta bucket
  }
  
  export interface NodeState {
    strike: number;
    pcAnchor: number;      // Last traded price
    widthRef: number;      // Width when position established
    position: number;      // Signed size (negative = short)
    lastBucket: string;    // For detecting migrations
    lastTradeTime: number;
  }
  
  export interface Surface {
    expiry: number;           // Time to expiry in years
    cc: SVIParams;           // Core Curve (belief)
    pcBumps: Bump[];         // Price Curve adjustments
    nodes: Map<number, NodeState>;  // Strike -> NodeState
  }
  
  export interface DeltaBucket {
    name: string;
    minDelta: number;
    maxDelta: number;
  }
  
  export interface EdgeParams {
    E0: number;      // Base edge
    kappa: number;   // Scale factor
    gamma: number;   // Curvature
    Vref: number;    // Reference vega
  }
  
  export interface Config {
    // SVI bounds
    bMin: number;
    sigmaMin: number;
    rhoMax: number;
    sMax: number;
    c0Min: number;
    
    // Delta buckets
    buckets: DeltaBucket[];
    
    // Edge parameters per bucket
    edgeParams: Map<string, EdgeParams>;
    
    // RBF parameters
    rbfWidth: number;
    ridgeLambda: number;
    
    // Risk limits
    maxL0Move: number;
    maxS0Move: number;
    maxC0Move: number;
  }
  
  // ============================================================================
  // SVI FUNCTIONS
  // ============================================================================
  
  export class SVI {
    /**
     * Calculate total variance at log-moneyness k
     */
    static w(params: SVIParams, k: number): number {
      const z = k - params.m;
      return params.a + params.b * (params.rho * z + Math.sqrt(z * z + params.sigma * params.sigma));
    }
    
    /**
     * Validate SVI parameters against no-arbitrage constraints
     */
    static validate(params: SVIParams, config: Config): boolean {
      // Basic bounds
      if (params.b < config.bMin || params.sigma < config.sigmaMin) {
        return false;
      }
      if (Math.abs(params.rho) > config.rhoMax) {
        return false;
      }
      
      // ATM variance must be non-negative
      const L0 = params.a + params.b * params.sigma;
      if (L0 < 0) {
        return false;
      }
      
      // Wing slopes must be positive
      const sLeft = params.b * (1 - params.rho);
      const sRight = params.b * (1 + params.rho);
      if (sLeft <= 0 || sRight <= 0) {
        return false;
      }
      if (sLeft > config.sMax || sRight > config.sMax) {
        return false;
      }
      
      return true;
    }
    
    /**
     * Convert trader metrics to SVI parameters
     */
    static fromMetrics(
      metrics: TraderMetrics,
      config: Config,
      options?: { preserveBumps?: boolean }
    ): SVIParams {
      const eps = 1e-12;
      const rhoMax = config.rhoMax ?? 0.999;
      const c0Min  = config.c0Min  ?? 1e-8;
      const bMin   = config.bMin   ?? 1e-8;
      const sigmaMin = config.sigmaMin ?? 1e-8;
    
      const Sp = metrics.S_pos;
      const Sn = metrics.S_neg;
      const Ssum = Sp + Sn;
      const Sdiff = Sp - Sn;
    
      // Correct identities: b = (S_pos + S_neg)/2, rho = (S_pos - S_neg)/(S_pos + S_neg)
      let b_raw = 0.5 * Ssum;
      let rho_raw = Math.abs(Ssum) > eps ? Sdiff / Ssum : 0;
    
      // Optional: when wings are symmetric (Ssum≈0), use S0 = b·ρ to preserve S0 bumps
      if (options?.preserveBumps && Math.abs(Ssum) < 1e-6) {
        const b_safe = Math.abs(b_raw) > eps ? Math.abs(b_raw) : bMin;
        const rho_from_S0 = metrics.S0 / b_safe;
        rho_raw = 0.75 * rho_raw + 0.25 * rho_from_S0; // Blend 25% from S0
      }
    
      // Legalize without destroying bumps
      let b = Math.max(Math.abs(b_raw), bMin); // SVI requires b > 0
      let rho = Math.max(-rhoMax, Math.min(rhoMax, rho_raw));
      
      // C0 ≈ b/sigma => sigma ≈ b/C0
      const sigma_raw = b / Math.max(metrics.C0, c0Min);
      let sigma = Math.max(sigma_raw, sigmaMin);
      
      // L0 = a + b·sigma => a = L0 - b·sigma
      let a = metrics.L0 - b * sigma;
    
      return { a, b, rho, sigma, m: 0 };
    }  

    /**
     * Extract trader metrics from SVI parameters
     */
    static toMetrics(params: SVIParams): TraderMetrics {
      const L0 = params.a + params.b * params.sigma;
      const S0 = params.b * params.rho;
      const C0 = params.sigma > 0 ? params.b / params.sigma : 0;
      const S_neg = params.b * (1 - params.rho);
      const S_pos = params.b * (1 + params.rho);
      
      return { L0, S0, C0, S_neg, S_pos };
    }
  }  
  
  // ============================================================================
  // BUMP FUNCTIONS
  // ============================================================================
  
  export class BumpFunctions {
    /**
     * Evaluate Gaussian RBF bump at log-moneyness k
     */
    static evalBump(bump: Bump, k: number): number {
      return bump.alpha * Math.exp(-0.5 * Math.pow((k - bump.k) / bump.lam, 2));
    }
    
    /**
     * Evaluate all bumps at log-moneyness k
     */
    static evalBumps(bumps: Bump[], k: number): number {
      return bumps.reduce((sum, bump) => sum + this.evalBump(bump, k), 0);
    }
  }
  
  // ============================================================================
  // WIDTH-DELTA RULE
  // ============================================================================
  
  export class WidthDelta {
    /**
     * Calculate PC mid with width-delta adjustment
     */
    static getPCMid(
      node: NodeState,
      widthNow: number,
      ccMid: number,
      staleHours: number = 24
    ): number {
      if (node.position === 0) {
        return node.pcAnchor;
      }
      
      // Width-delta rule
      const signPos = node.position < 0 ? 1 : -1;
      const pcBase = node.pcAnchor + signPos * (widthNow - node.widthRef);
      
      // Optional: drift toward CC for stale positions
      if (staleHours > 0) {
        const ageHours = (Date.now() - node.lastTradeTime) / (3600 * 1000);
        const confidence = Math.exp(-ageHours / staleHours);
        return confidence * pcBase + (1 - confidence) * ccMid;
      }
      
      return pcBase;
    }
  }
  
  // ============================================================================
  // DELTA COMPUTATION
  // ============================================================================
  
  export class Greeks {
    /**
     * Compute Black-Scholes delta (simplified)
     */
    static delta(
      strike: number,
      spot: number,
      vol: number,
      T: number,
      isCall: boolean = false
    ): number {
      if (T <= 0) return 0;
      
      // Simplified BS delta (assuming r=0)
      const d1 = (Math.log(spot / strike) + 0.5 * vol * vol * T) / (vol * Math.sqrt(T));
      
      // Normal CDF approximation
      const normCdf = (x: number) => {
        const a1 = 0.254829592;
        const a2 = -0.284496736;
        const a3 = 1.421413741;
        const a4 = -1.453152027;
        const a5 = 1.061405429;
        const p = 0.3275911;
        
        const sign = x >= 0 ? 1 : -1;
        x = Math.abs(x) / Math.sqrt(2.0);
        
        const t = 1.0 / (1.0 + p * x);
        const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
        
        return 0.5 * (1.0 + sign * y);
      };
      
      const delta = isCall ? normCdf(d1) : normCdf(d1) - 1;
      return Math.abs(delta);
    }
    
    /**
     * Map delta to bucket
     */
    static getBucket(delta: number, config: Config): string {
      for (const bucket of config.buckets) {
        if (delta >= bucket.minDelta && delta <= bucket.maxDelta) {
          return bucket.name;
        }
      }
      return 'wings';  // Default for far OTM
    }
  }
  
  // ============================================================================
  // RISK SCORER
  // ============================================================================
  
  export interface MarketObservation {
    instrument: string;
    spread: number;
    gamma?: number;
    J_L0?: number;
    J_S0?: number;
    J_C0?: number;
  }
  
  export class RiskScorer {
    private betas: Map<string, number>;
    private lastUpdate: number;
    
    constructor() {
      this.betas = new Map([
        ['gamma', 1.0],
        ['L0', 1.0],
        ['S0', 0.5],
        ['C0', 0.3],
        ['floor', 0.5]
      ]);
      this.lastUpdate = Date.now();
    }
    
    /**
     * Update risk prices from market observations (simplified NNLS)
     */
    updateFromMarket(observations: MarketObservation[]): void {
      if (observations.length === 0) return;
      
      // Simplified update - in production would use proper NNLS
      const alpha = 0.3;  // EMA parameter
      
      // Average observed spreads by category
      const avgSpread = observations.reduce((sum, obs) => sum + obs.spread, 0) / observations.length;
      
      // Update floor
      this.betas.set('floor', 
        alpha * avgSpread * 0.5 + (1 - alpha) * this.betas.get('floor')!);
      
      this.lastUpdate = Date.now();
    }
    
    /**
     * Compute half-spread for a structure
     */
    computeWidth(greeks: Partial<{
      gamma: number;
      J_L0: number;
      J_S0: number;
      J_C0: number;
    }>): number {
      let width = this.betas.get('floor')!;
      
      if (greeks.gamma) {
        width += this.betas.get('gamma')! * Math.abs(greeks.gamma);
      }
      if (greeks.J_L0) {
        width += this.betas.get('L0')! * Math.abs(greeks.J_L0);
      }
      if (greeks.J_S0) {
        width += this.betas.get('S0')! * Math.abs(greeks.J_S0);
      }
      if (greeks.J_C0) {
        width += this.betas.get('C0')! * Math.abs(greeks.J_C0);
      }
      
      return width;
    }
  }
  
  // ============================================================================
  // SURFACE STATE MANAGER
  // ============================================================================
  
  export class DualSurfaceModel {
    private surfaces: Map<number, Surface>;
    private config: Config;
    private scorer: RiskScorer;
    private version: number;
    
    constructor(modelConfig: any) {
      this.surfaces = new Map();
      // Convert ModelConfig to Config format
      this.config = this.convertModelConfig(modelConfig);
      this.scorer = new RiskScorer();
      this.version = 0;
    }
    
    private convertModelConfig(mc: any): Config {
      // Map edge params from array to Map
      const edgeParams = new Map<string, EdgeParams>();
      mc.buckets.forEach((bucket: any) => {
        edgeParams.set(bucket.name, bucket.edgeParams);
      });
      
      return {
        bMin: mc.svi.bMin,
        sigmaMin: mc.svi.sigmaMin,
        rhoMax: mc.svi.rhoMax,
        sMax: mc.svi.slopeMax,
        c0Min: mc.svi.c0Min,
        buckets: mc.buckets.map((b: any) => ({
          name: b.name,
          minDelta: b.minDelta,
          maxDelta: b.maxDelta
        })),
        edgeParams,
        rbfWidth: mc.rbf.width,
        ridgeLambda: mc.rbf.ridgeLambda,
        maxL0Move: mc.riskLimits.maxL0Move,
        maxS0Move: mc.riskLimits.maxS0Move,
        maxC0Move: mc.riskLimits.maxC0Move
      };
    }
    
    /**
     * Initialize or update Core Curve
     */
    updateCC(expiry: number, metrics: TraderMetrics): void {
      const newCC = SVI.fromMetrics(metrics, this.config);
      
      if (!SVI.validate(newCC, this.config)) {
        throw new Error('Invalid SVI parameters');
      }
      
      let surface = this.surfaces.get(expiry);
      if (!surface) {
        // Initialize new surface
        surface = {
          expiry,
          cc: newCC,
          pcBumps: [],
          nodes: new Map()
        };
        this.surfaces.set(expiry, surface);
      } else {
        // Rebase PC to maintain quotes
        // (Implementation would go here)
        surface.cc = newCC;
      }
      
      this.version++;
    }
    
    /**
     * Handle trade execution
     */
    onTrade(
      expiry: number,
      strike: number,
      price: number,
      size: number,
      spot: number
    ): void {
      const surface = this.surfaces.get(expiry);
      if (!surface) return;
      
      let node = surface.nodes.get(strike);
      if (!node) {
        // Create new node
        const vol = 0.3;  // Placeholder
        const delta = Greeks.delta(strike, spot, vol, expiry);
        
        node = {
          strike,
          pcAnchor: price,
          widthRef: this.scorer.computeWidth({ gamma: 0.1 }),
          position: -size,  // Negative for short
          lastBucket: Greeks.getBucket(delta, this.config),
          lastTradeTime: Date.now()
        };
        surface.nodes.set(strike, node);
      } else {
        // Update existing node
        node.pcAnchor = price;
        node.position -= size;
        node.lastTradeTime = Date.now();
      }
      
      this.version++;
    }
    
    /**
     * Get quotes for strikes
     */
    getQuotes(
      expiry: number,
      strikes: number[],
      spot: number
    ): Map<number, { bid: number; ask: number }> {
      const quotes = new Map<number, { bid: number; ask: number }>();
      const surface = this.surfaces.get(expiry);
      
      if (!surface) return quotes;
      
      for (const strike of strikes) {
        const k = Math.log(strike / spot);
        
        // Get or create node
        let node = surface.nodes.get(strike);
        if (!node) {
          const vol = 0.3;  // Placeholder
          const delta = Greeks.delta(strike, spot, vol, expiry);
          
          node = {
            strike,
            pcAnchor: 100 * vol * Math.sqrt(expiry) * 0.4,  // Rough approximation
            widthRef: 0.5,
            position: 0,
            lastBucket: Greeks.getBucket(delta, this.config),
            lastTradeTime: Date.now()
          };
        }
        
        // Compute current width
        const widthNow = this.scorer.computeWidth({ gamma: 0.1 });
        
        // Get PC mid with width-delta adjustment
        const ccMid = 100 * Math.sqrt(SVI.w(surface.cc, k) / expiry) * Math.sqrt(expiry) * 0.4;
        const pcMid = WidthDelta.getPCMid(node, widthNow, ccMid, 24);
        
        // Symmetric quotes
        quotes.set(strike, {
          bid: pcMid - widthNow,
          ask: pcMid + widthNow
        });
      }
      
      return quotes;
    }
    
    /**
     * Get current version for consistency checks
     */
    getVersion(): number {
      return this.version;
    }
  }
  
  // ============================================================================
  // DEFAULT CONFIGURATION
  // ============================================================================
  
  export function getDefaultConfig(): Config {
    const edgeParams = new Map<string, EdgeParams>([
      ['atm', { E0: 2.0, kappa: 5.0, gamma: 1.5, Vref: 100.0 }],
      ['rr25', { E0: 1.0, kappa: 3.0, gamma: 1.4, Vref: 100.0 }],
      ['rr10', { E0: 0.5, kappa: 2.0, gamma: 1.3, Vref: 100.0 }],
      ['wings', { E0: 0.3, kappa: 1.5, gamma: 1.2, Vref: 100.0 }]
    ]);
    
    return {
      bMin: 1e-6,
      sigmaMin: 1e-3,
      rhoMax: 0.995,
      sMax: 2.0,
      c0Min: 1e-4,
      
      buckets: [
        { name: 'atm', minDelta: 0.45, maxDelta: 0.55 },
        { name: 'rr25', minDelta: 0.20, maxDelta: 0.30 },
        { name: 'rr10', minDelta: 0.08, maxDelta: 0.12 },
        { name: 'wings', minDelta: 0.00, maxDelta: 0.05 }
      ],
      
      edgeParams,
      
      rbfWidth: 0.15,
      ridgeLambda: 1e-3,
      
      maxL0Move: 0.5,
      maxS0Move: 0.2,
      maxC0Move: 0.05
    };
  }
---------- END apps/server/src/volModels/dualSurfaceModel.ts ----------

---------- BEGIN apps/server/src/volModels/edgeDiagnostic.ts (bytes=3182) ----------
/**
 * Diagnostic tool to find where the asymmetry is happening
 */

import { SmileInventoryController } from './smileInventoryController';
import { ModelConfig, getDefaultConfig } from './config/modelConfig';

function testSymmetry() {
  console.log('\n' + '='.repeat(60));
  console.log('EDGE CALCULATION SYMMETRY TEST');
  console.log('='.repeat(60));
  
  const config = getDefaultConfig('BTC');
  const controller = new SmileInventoryController(config);
  
  // Test various inventory levels
  const testLevels = [
    { vega: -30, label: 'Very Short' },
    { vega: -10, label: 'Short' },
    { vega: 0, label: 'Flat' },
    { vega: 10, label: 'Long' },
    { vega: 30, label: 'Very Long' }
  ];
  
  console.log('\nTesting smile adjustments for different positions:');
  console.log('Position  | Vega  | ΔL0     | ΔS0     | Edge Req');
  console.log('-'.repeat(55));
  
  for (const test of testLevels) {
    // Simulate ATM position
    controller.updateInventory(100, test.vega > 0 ? 100 : -100, test.vega, 'atm');
    
    const adjustments = controller.calculateSmileAdjustments();
    
    // Get edge required from inventory state
    const invState = controller.getInventoryState();
    const atmInv = invState.get('atm');
    const edgeReq = atmInv ? atmInv.edgeRequired : 0;
    
    console.log(
      `${test.label.padEnd(10)} | ${test.vega.toString().padStart(4)} | ` +
      `${(adjustments.deltaL0 * 100).toFixed(3).padStart(7)}% | ` +
      `${(adjustments.deltaS0 * 100).toFixed(3).padStart(7)}% | ` +
      `${edgeReq.toFixed(2).padStart(8)}`
    );
    
    // Reset for next test
    controller.updateInventory(100, test.vega > 0 ? -100 : 100, -test.vega, 'atm');
  }
  
  console.log('\n' + '-'.repeat(55));
  console.log('\n⚠️  ISSUES TO CHECK:');
  
  console.log('\n1. Is ΔL0 symmetric? (should be negative when long)');
  console.log('2. Is edge requirement signed correctly?');
  console.log('3. Are there any Math.abs() calls preventing negative adjustments?');
  
  // Now let's check the actual code logic
  console.log('\n' + '-'.repeat(55));
  console.log('\nDirect calculation test:');
  
  // Simulate the edge calculation directly
  const E0 = config.buckets[0].edgeParams.E0;
  const Vref = config.buckets[0].edgeParams.Vref;
  
  for (const test of testLevels) {
    // What the calculation SHOULD be
    const correctEdge = (test.vega / Vref) * E0;
    
    // What it might be doing wrong
    const wrongEdge1 = Math.abs(test.vega / Vref) * E0;  // Always positive
    const wrongEdge2 = Math.max(0, (test.vega / Vref) * E0);  // Never negative
    
    console.log(`\nVega ${test.vega}:`);
    console.log(`  Correct (signed):   ${correctEdge.toFixed(3)}`);
    console.log(`  Wrong (absolute):   ${wrongEdge1.toFixed(3)}`);
    console.log(`  Wrong (max 0):      ${wrongEdge2.toFixed(3)}`);
  }
  
  console.log('\n' + '='.repeat(60));
  console.log('The fix needed in smileInventoryController.ts:');
  console.log('1. Remove Math.abs() from edge calculations');
  console.log('2. Allow negative deltaL0 when long');
  console.log('3. Make sure all adjustments can go negative');
  console.log('='.repeat(60));
}

testSymmetry();
---------- END apps/server/src/volModels/edgeDiagnostic.ts ----------

---------- BEGIN apps/server/src/volModels/factors/FactorSpace.ts (bytes=778) ----------
/**
 * FactorSpace — types + helpers for factor calculus
 * Factors: [L0, S0, C0, S_neg, S_pos, F]
 */
export type FactorVec = [number, number, number, number, number, number];
export const ZeroFactors: FactorVec = [0, 0, 0, 0, 0, 0];

export function dot(a: FactorVec, b: FactorVec): number {
  let s = 0;
  for (let i = 0; i < 6; i++) s += a[i] * b[i];
  return s;
}

export function axpy(y: FactorVec, a: number, x: FactorVec): FactorVec {
  return [
    y[0] + a * x[0],
    y[1] + a * x[1],
    y[2] + a * x[2],
    y[3] + a * x[3],
    y[4] + a * x[4],
    y[5] + a * x[5],
  ];
}

export function norm1(a: FactorVec): number {
  return (
    Math.abs(a[0]) +
    Math.abs(a[1]) +
    Math.abs(a[2]) +
    Math.abs(a[3]) +
    Math.abs(a[4]) +
    Math.abs(a[5])
  );
}

---------- END apps/server/src/volModels/factors/FactorSpace.ts ----------

---------- BEGIN apps/server/src/volModels/factors/factorGreeks.ts (bytes=4062) ----------
/**
 * Finite-difference factor greeks g_i = ∂Price/∂θ_i
 * Self-contained: CC (SVI) -> Black-76 price.
 * Factors: [L0, S0, C0, S_neg, S_pos, F]
 */
import { FactorVec } from "./FactorSpace";
import { SVI, SVIParams, TraderMetrics } from "../dualSurfaceModel";
import { black76Greeks } from "../../risk";

const tiny = 1e-12;

function priceFromCC(cc: SVIParams, strike: number, T: number, F: number, isCall: boolean): number {
  const Tpos = Math.max(T, 1e-8);
  const k = Math.log(strike / Math.max(F, tiny));
  let w = SVI.w(cc, k);
  if (!Number.isFinite(w) || w <= 0) {
    const iv0 = 0.35;
    w = Math.max(iv0 * iv0 * Tpos, tiny);
  }
  let iv = Math.sqrt(w / Tpos);
  if (!Number.isFinite(iv) || iv <= 0) iv = 0.35;
  const g = black76Greeks(F, strike, Tpos, iv, isCall, 1.0);
  return Number.isFinite(g.price) ? g.price : 0;
}

export function factorGreeksFiniteDiff(
  cc: SVIParams,
  strike: number,
  T: number,
  F: number,
  isCall: boolean,
  cfg: any,
  debug = false
): FactorVec {
  const Tpos = Math.max(T, 1e-8);

  const clamp = (x: number, lo: number, hi: number) => Math.max(lo, Math.min(hi, x));
  const chooseStepAbs = (v: number, rel = 1e-3, abs = 1e-4) =>
    Math.max(Math.abs(v) * rel, abs);

  function bumpMetrics(m0: TraderMetrics, idx: number, h: number): TraderMetrics {
    const m = { ...m0 };
    const rhoMax = cfg.rhoMax ?? 0.999;
    const bMin   = cfg.bMin   ?? 1e-8;
    const c0Min  = cfg.c0Min  ?? 1e-8;

    switch (idx) {
      case 0: {
        m.L0 += h;
        break;
      }
      case 1: {
        const Ssum = m.S_pos + m.S_neg;
        const b = Math.max(Ssum / 2, bMin);
        const S0_new = m.S0 + h;
        const rho_new = clamp(S0_new / b, -rhoMax, rhoMax);
        m.S_pos = b * (1 + rho_new);
        m.S_neg = b * (1 - rho_new);
        m.S0 = b * rho_new;
        break;
      }
      case 2: {
        m.C0 = Math.max(m.C0 + h, c0Min);
        break;
      }
      case 3: {
        m.S_neg = Math.max(m.S_neg + h, 0);
        const b = (m.S_pos + m.S_neg) / 2;
        const rho = (m.S_pos - m.S_neg) / Math.max(m.S_pos + m.S_neg, bMin * 2);
        m.S0 = b * rho;
        break;
      }
      case 4: {
        m.S_pos = Math.max(m.S_pos + h, 0);
        const b = (m.S_pos + m.S_neg) / 2;
        const rho = (m.S_pos - m.S_neg) / Math.max(m.S_pos + m.S_neg, bMin * 2);
        m.S0 = b * rho;
        break;
      }
    }
    return m;
  }

  const priceFromMetrics = (m: TraderMetrics) =>
    priceFromCC(SVI.fromMetrics(m, cfg, { preserveBumps: true }), strike, Tpos, F, isCall);

  const basePrice = priceFromCC(cc, strike, Tpos, F, isCall);
  const baseM = SVI.toMetrics(cc);

  const hL0 = chooseStepAbs(baseM.L0);
  const hS0 = chooseStepAbs(baseM.S0);
  const hC0 = chooseStepAbs(baseM.C0);
  const hSneg = chooseStepAbs(baseM.S_neg);
  const hSpos = chooseStepAbs(baseM.S_pos);
  const hF = Math.max(Math.abs(F) * 1e-4, 1e-4);

  const mL0p = bumpMetrics(baseM, 0, +hL0);
  const mL0m = bumpMetrics(baseM, 0, -hL0);
  const gL0 = (priceFromMetrics(mL0p) - priceFromMetrics(mL0m)) / (2 * hL0);

  const mS0p = bumpMetrics(baseM, 1, +hS0);
  const mS0m = bumpMetrics(baseM, 1, -hS0);
  const gS0 = (priceFromMetrics(mS0p) - priceFromMetrics(mS0m)) / (2 * hS0);

  const mC0p = bumpMetrics(baseM, 2, +hC0);
  const mC0m = bumpMetrics(baseM, 2, -hC0);
  const gC0 = (priceFromMetrics(mC0p) - priceFromMetrics(mC0m)) / (2 * hC0);

  const mSNp = bumpMetrics(baseM, 3, +hSneg);
  const mSNm = bumpMetrics(baseM, 3, -hSneg);
  const gSN = (priceFromMetrics(mSNp) - priceFromMetrics(mSNm)) / (2 * hSneg);

  const mSPp = bumpMetrics(baseM, 4, +hSpos);
  const mSPm = bumpMetrics(baseM, 4, -hSpos);
  const gSP = (priceFromMetrics(mSPp) - priceFromMetrics(mSPm)) / (2 * hSpos);

  const pFp = priceFromCC(cc, strike, Tpos, F + hF, isCall);
  const pFm = priceFromCC(cc, strike, Tpos, F - hF, isCall);
  const gF = (pFp - pFm) / (2 * hF);

  const clean = (x: number) => (Number.isFinite(x) ? x : 0);
  return [clean(gL0), clean(gS0), clean(gC0), clean(gSN), clean(gSP), clean(gF)];
}

---------- END apps/server/src/volModels/factors/factorGreeks.ts ----------

---------- BEGIN apps/server/src/volModels/integratedModel.ts (bytes=15227) ----------
/**
 * Integrated Dual Surface Model
 * Combines CC (belief), PC (price curve with inventory bumps), and width-delta rule
 */

import { 
    SVIParams, 
    TraderMetrics, 
    NodeState, 
    Surface, 
    SVI,
    BumpFunctions,
    WidthDelta
  } from './dualSurfaceModel';
  import { ModelConfig, getDefaultConfig } from './config/modelConfig';
  import { InventoryController } from './controllers/inventoryController';
  import { RiskScorer } from './dualSurfaceModel';
  import { blackScholes, DeltaConventions } from './pricing/blackScholes';
  
  export interface Quote {
    bid: number;
    ask: number;
    bidSize: number;
    askSize: number;
    pcMid: number;
    ccMid: number;
    edge: number;
    bucket: string;
  }
  
  export interface TradeExecution {
    expiry: number;
    strike: number;
    price: number;
    size: number;    // Negative = sold
    spot: number;
    time: number;
  }
  
  export class IntegratedDualSurface {
    private surfaces: Map<number, Surface>;
    private inventoryController: InventoryController;
    private riskScorer: RiskScorer;
    private config: ModelConfig;
    private sviConfig: any; // Config format for SVI functions
    private version: number;
    
    constructor(product: 'BTC' | 'ETH' | 'SPX' = 'BTC') {
      this.config = getDefaultConfig(product);
      // Convert ModelConfig to Config format for SVI
      this.sviConfig = this.convertToSVIConfig(this.config);
      this.surfaces = new Map();
      this.inventoryController = new InventoryController(this.config);
      this.riskScorer = new RiskScorer();
      this.version = 0;
    }
    
    private convertToSVIConfig(mc: ModelConfig): any {
      const edgeParams = new Map();
      mc.buckets.forEach(bucket => {
        edgeParams.set(bucket.name, bucket.edgeParams);
      });
      
      return {
        bMin: mc.svi.bMin,
        sigmaMin: mc.svi.sigmaMin,
        rhoMax: mc.svi.rhoMax,
        sMax: mc.svi.slopeMax,
        c0Min: mc.svi.c0Min,
        buckets: mc.buckets.map(b => ({
          name: b.name,
          minDelta: b.minDelta,
          maxDelta: b.maxDelta
        })),
        edgeParams,
        rbfWidth: mc.rbf.width,
        ridgeLambda: mc.rbf.ridgeLambda,
        maxL0Move: mc.riskLimits.maxL0Move,
        maxS0Move: mc.riskLimits.maxS0Move,
        maxC0Move: mc.riskLimits.maxC0Move
      };
    }
    
    /**
     * Initialize or update Core Curve (CC)
     */
    updateCC(expiry: number, metrics: TraderMetrics): void {
      const newCC = SVI.fromMetrics(metrics, this.sviConfig);
      
      if (!SVI.validate(newCC, this.sviConfig)) {
        throw new Error('Invalid SVI parameters');
      }
      
      let surface = this.surfaces.get(expiry);
      
      if (!surface) {
        // Initialize new surface
        surface = {
          expiry,
          cc: newCC,
          pcBumps: [],
          nodes: new Map()
        };
        this.surfaces.set(expiry, surface);
      } else {
        // Rebase PC bumps to maintain edge with new CC
        const spot = 100; // Should be passed in
        surface.pcBumps = this.inventoryController.rebaseBumps(
          surface.cc,
          newCC,
          surface.pcBumps,
          expiry,
          spot
        );
        surface.cc = newCC;
      }
      
      this.version++;
    }
    
    /**
     * Execute a trade and update everything
     */
    onTrade(trade: TradeExecution): void {
      const surface = this.surfaces.get(trade.expiry);
      if (!surface) {
        console.warn(`No surface for expiry ${trade.expiry}`);
        return;
      }
      
      // 1. Update node state (PC anchor)
      this.updateNodeState(surface, trade);
      
      // 2. Calculate Greeks for inventory tracking
      const k = Math.log(trade.strike / trade.spot);
      const variance = SVI.w(surface.cc, k);
      const iv = Math.sqrt(variance / trade.expiry);
      
      const greeks = blackScholes({
        strike: trade.strike,
        spot: trade.spot,
        vol: iv,
        T: trade.expiry,
        r: 0,
        isCall: false
      });
      
      // 3. Update inventory
      const bucket = DeltaConventions.strikeToBucket(
        trade.strike,
        trade.spot,
        iv,
        trade.expiry
      );
      
      this.inventoryController.updateInventory(
        trade.strike,
        trade.size,
        greeks.vega,
        bucket
      );
      
      // 4. Check if bumps need updating
      if (this.inventoryController.needsBumpUpdate(bucket)) {
        this.updatePCBumps(surface, trade.expiry, trade.spot);
      }
      
      this.version++;
    }
    
    /**
     * Update node state after trade
     */
    private updateNodeState(surface: Surface, trade: TradeExecution): void {
      let node = surface.nodes.get(trade.strike);
      
      if (!node) {
        // Create new node
        const bucket = DeltaConventions.strikeToBucket(
          trade.strike,
          trade.spot,
          0.3, // Approximate IV
          surface.expiry
        );
        
        node = {
          strike: trade.strike,
          pcAnchor: trade.price,
          widthRef: this.riskScorer.computeWidth({ gamma: 0.1 }),
          position: trade.size,
          lastBucket: bucket,
          lastTradeTime: Date.now()
        };
        surface.nodes.set(trade.strike, node);
      } else {
        // Update existing node
        node.pcAnchor = trade.price;
        node.position += trade.size;
        node.lastTradeTime = Date.now();
        node.widthRef = this.riskScorer.computeWidth({ gamma: 0.1 });
      }
    }
    
    /**
     * Update PC bumps based on inventory
     */
    private updatePCBumps(surface: Surface, expiry: number, spot: number): void {
      // Only generate bumps for strikes where we have positions
      const newBumps = [];
      
      // Get inventory state
      const invState = this.inventoryController.getInventoryState();
      
      // For each bucket with inventory
      for (const [bucket, bucketInv] of invState.byBucket) {
        if (Math.abs(bucketInv.signedVega) < 0.1) continue;  // Skip if no significant inventory
        
        // Get strikes where we actually have positions in this bucket
        const strikesWithPositions: number[] = [];
        
        for (const [strike, node] of surface.nodes) {
          if (node.position !== 0) {
            // Check if this strike is in the current bucket
            const k = Math.log(strike / spot);
            const variance = SVI.w(surface.cc, k);
            const iv = Math.sqrt(variance / expiry);
            const strikeBucket = DeltaConventions.strikeToBucket(strike, spot, iv, expiry);
            
            if (strikeBucket === bucket) {
              strikesWithPositions.push(strike);
            }
          }
        }
        
        // Only generate bumps if we have positions in this bucket
        if (strikesWithPositions.length > 0) {
          const bumps = this.inventoryController.generateBumps(
            bucket,
            surface.cc,
            expiry,
            spot,
            strikesWithPositions
          );
          newBumps.push(...bumps);
        }
      }
      
      // Replace old bumps
      surface.pcBumps = newBumps;
    }
    
    /**
     * Get representative strikes for each bucket
     */
    private getBucketStrikes(spot: number, expiry: number): Map<string, number[]> {
      const bucketStrikes = new Map<string, number[]>();
      
      // ATM strikes
      bucketStrikes.set('atm', [
        spot * 0.98,
        spot * 0.99,
        spot * 1.00,
        spot * 1.01,
        spot * 1.02
      ]);
      
      // 25-delta strikes (approximate)
      bucketStrikes.set('rr25', [
        spot * 0.93,
        spot * 0.94,
        spot * 0.95,
        spot * 1.05,
        spot * 1.06,
        spot * 1.07
      ]);
      
      // 10-delta strikes
      bucketStrikes.set('rr10', [
        spot * 0.88,
        spot * 0.90,
        spot * 1.10,
        spot * 1.12
      ]);
      
      // Wing strikes
      bucketStrikes.set('wings', [
        spot * 0.80,
        spot * 0.85,
        spot * 1.15,
        spot * 1.20
      ]);
      
      return bucketStrikes;
    }
    
    /**
     * Get quotes with full integration
     */
    getQuote(expiry: number, strike: number, spot: number): Quote {
      const surface = this.surfaces.get(expiry);
      if (!surface) {
        throw new Error(`No surface for expiry ${expiry}`);
      }
      
      const k = Math.log(strike / spot);
      
      // 1. Calculate CC price
      const ccVariance = SVI.w(surface.cc, k);
      const ccIV = Math.sqrt(ccVariance / expiry);
      const ccGreeks = blackScholes({
        strike,
        spot,
        vol: ccIV,
        T: expiry,
        r: 0,
        isCall: false
      });
      const ccMid = ccGreeks.price;
      
      // 2. Calculate PC price (CC + bumps)
      const bumpAdjustment = BumpFunctions.evalBumps(surface.pcBumps, k);
      const pcVariance = ccVariance + bumpAdjustment;
      const pcIV = Math.sqrt(Math.max(pcVariance, 1e-8) / expiry);
      const pcGreeks = blackScholes({
        strike,
        spot,
        vol: pcIV,
        T: expiry,
        r: 0,
        isCall: false
      });
      
      // 3. Get or create node state
      let node = surface.nodes.get(strike);
      const bucket = DeltaConventions.strikeToBucket(strike, spot, ccIV, expiry);
      
      if (!node) {
        node = {
          strike,
          pcAnchor: pcGreeks.price,
          widthRef: this.riskScorer.computeWidth({ gamma: ccGreeks.gamma }),
          position: 0,
          lastBucket: bucket,
          lastTradeTime: Date.now()
        };
      }
      
      // 4. Apply width-delta rule
      const currentWidth = this.riskScorer.computeWidth({ 
        gamma: ccGreeks.gamma,
        J_L0: 1.0,  // Placeholder sensitivities
        J_S0: 0.5,
        J_C0: 0.3
      });
      
      const pcMid = WidthDelta.getPCMid(
        node,
        currentWidth,
        ccMid,
        this.config.quotes.staleHours
      );
      
      // 5. Build quote
      const bid = pcMid - currentWidth;
      const ask = pcMid + currentWidth;
      
      // 6. Calculate edge (PC - CC)
      const edge = pcMid - ccMid;
      
      // 7. Size based on inventory
      const baseSize = this.config.quotes.sizeBlocks;
      const invState = this.inventoryController.getInventoryState();
      const bucketInv = invState.byBucket.get(bucket);
      
      let bidSize = baseSize;
      let askSize = baseSize;
      
      if (bucketInv) {
        const invRatio = Math.abs(bucketInv.signedVega) / 
          this.config.buckets.find(b => b.name === bucket)!.edgeParams.Vref;
        
        if (bucketInv.signedVega < 0) {
          // Short - reduce ask size
          askSize = Math.max(10, baseSize * Math.exp(-invRatio));
        } else {
          // Long - reduce bid size
          bidSize = Math.max(10, baseSize * Math.exp(-invRatio));
        }
      }
      
      return {
        bid,
        ask,
        bidSize: Math.round(bidSize),
        askSize: Math.round(askSize),
        pcMid,
        ccMid,
        edge,
        bucket
      };
    }
    
    /**
     * Get inventory summary
     */
    getInventorySummary() {
      const state = this.inventoryController.getInventoryState();
      const summary = {
        totalVega: state.totalVega,
        byBucket: {} as any,
        edges: {} as any
      };
      
      for (const [bucket, inv] of state.byBucket) {
        summary.byBucket[bucket] = {
          vega: inv.signedVega,
          count: inv.count
        };
        summary.edges[bucket] = this.inventoryController.getCurrentEdge(bucket);
      }
      
      return summary;
    }
    
    /**
     * Update market observations for risk scorer
     */
    updateMarketObservations(observations: any[]): void {
      this.riskScorer.updateFromMarket(observations);
    }
  }
  
  /**
   * Test the integrated model
   */
  export function testIntegratedModel(): void {
    console.log('\n' + '='.repeat(60));
    console.log('INTEGRATED DUAL SURFACE MODEL TEST');
    console.log('='.repeat(60) + '\n');
    
    const model = new IntegratedDualSurface('BTC');
    
    // Setup CC
    const expiry = 0.25; // 3 months
    const spot = 100;
    
    const initialMetrics: TraderMetrics = {
      L0: 0.04,    // 20% vol
      S0: 0.001,
      C0: 0.5,
      S_neg: -0.8,
      S_pos: 0.9
    };
    
    model.updateCC(expiry, initialMetrics);
    console.log('✅ Initialized CC with 20% ATM vol\n');
    
    // Get initial quotes
    const strikes = [90, 95, 100, 105, 110];
    
    console.log('Initial quotes (no position):');
    console.log('Strike | Bucket | Bid    | Ask    | PC Mid | CC Mid | Edge');
    console.log('-'.repeat(65));
    
    for (const strike of strikes) {
      const quote = model.getQuote(expiry, strike, spot);
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${quote.bucket.padEnd(6)} | ` +
        `${quote.bid.toFixed(2).padStart(6)} | ` +
        `${quote.ask.toFixed(2).padStart(6)} | ` +
        `${quote.pcMid.toFixed(2).padStart(6)} | ` +
        `${quote.ccMid.toFixed(2).padStart(6)} | ` +
        `${quote.edge.toFixed(2).padStart(5)}`
      );
    }
    
    // Execute a trade
    console.log('\n' + '-'.repeat(60));
    console.log('\n📝 TRADE: Sell 100 lots of 95 strike put\n');
    
    const trade: TradeExecution = {
      expiry,
      strike: 95,
      price: 3.50,
      size: -100,  // Negative = sold
      spot,
      time: Date.now()
    };
    
    model.onTrade(trade);
    
    // Get post-trade quotes
    console.log('Post-trade quotes:');
    console.log('Strike | Bucket | Bid    | Ask    | PC Mid | CC Mid | Edge  | Sizes');
    console.log('-'.repeat(75));
    
    for (const strike of strikes) {
      const quote = model.getQuote(expiry, strike, spot);
      const marker = strike === 95 ? ' ←' : '  ';
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${quote.bucket.padEnd(6)} | ` +
        `${quote.bid.toFixed(2).padStart(6)} | ` +
        `${quote.ask.toFixed(2).padStart(6)} | ` +
        `${quote.pcMid.toFixed(2).padStart(6)} | ` +
        `${quote.ccMid.toFixed(2).padStart(6)} | ` +
        `${quote.edge.toFixed(2).padStart(5)} | ` +
        `${quote.bidSize}/${quote.askSize}${marker}`
      );
    }
    
    // Show inventory
    console.log('\n' + '-'.repeat(60));
    console.log('\n📊 Inventory Summary:\n');
    
    const inventory = model.getInventorySummary();
    console.log(`Total Vega: ${inventory.totalVega.toFixed(1)}`);
    console.log('\nBy Bucket:');
    for (const [bucket, data] of Object.entries(inventory.byBucket)) {
      const bucketData = data as { vega: number; count: number };
      const edge = (inventory.edges as any)[bucket];
      console.log(`  ${bucket}: ${bucketData.vega.toFixed(1)} vega, edge = ${edge.toFixed(2)} ticks`);
    }
    
    console.log('\n' + '='.repeat(60));
    console.log('✅ INTEGRATED MODEL TEST COMPLETE');
    console.log('='.repeat(60) + '\n');
  }
  
  // Run if executed directly
  if (require.main === module) {
    testIntegratedModel();
  }
---------- END apps/server/src/volModels/integratedModel.ts ----------

---------- BEGIN apps/server/src/volModels/integratedSmileModel.ts (bytes=12192) ----------
/**
 * Integrated Dual Surface Model with Market Calibration
 * Convention: TradeExecution.size is **DEALER-signed**
 *   - Customer BUY  => dealer SELL  => size = -|q|
 *   - Customer SELL => dealer BUY   => size = +|q|
 */
import {
  SVIParams, TraderMetrics, NodeState, SVI, RiskScorer
} from './dualSurfaceModel';
import { ModelConfig, getDefaultConfig } from './config/modelConfig';
import { SmileInventoryController } from './smileInventoryController';
import { DeltaConventions } from './pricing/blackScholes';
import { black76Greeks } from "../risk";
import { timeToExpiryYears } from "../utils/time";
import { totalVariance } from "../pricing/totalVariance";
import { tauIntegral } from "../pricing/seasonality";

const tiny = 1e-12;
const safe = (x: number, fallback = 0) => (Number.isFinite(x) ? x : fallback);

export interface Quote {
  bid: number; ask: number;
  bidSize: number; askSize: number;
  pcMid: number; ccMid: number;
  edge: number; bucket: string;
}
export interface TradeExecution {
  expiryMs: number;
  strike: number;
  forward: number;
  optionType: 'C' | 'P';
  price: number;
  size: number;
  time: number;
}
export interface EnhancedSurface {
  expiry: number; cc: SVIParams; pc: SVIParams; nodes: Map<number, NodeState>;
}
export interface MarketQuoteForCalibration { strike: number; iv: number; weight?: number; }

export class IntegratedSmileModel {
  private surfaces = new Map<number, EnhancedSurface>();
  private inventoryController: SmileInventoryController;
  private riskScorer: RiskScorer;
  private config: ModelConfig;
  private sviConfig: any;
  private version = 0;
  private marketIVs = new Map<number, number>();
  private symbol: string;
  private clockFn: () => number = Date.now;  // ← Injected clock for determinism

  constructor(product: 'BTC'|'ETH'|'SPX' = 'BTC', clockFn?: () => number) {
    this.symbol = product;
    this.config = getDefaultConfig(product);
    this.sviConfig = this.convertToSVIConfig(this.config);
    this.inventoryController = new SmileInventoryController(this.config);
    this.riskScorer = new RiskScorer();
    if (clockFn) this.clockFn = clockFn;  // ← Allow clock injection
  }

  private deriveMetricsFromMarketIV(atmIV: number, expiryYears: number): TraderMetrics {
    const L0 = atmIV * atmIV * expiryYears;
    const scale = Math.sqrt(Math.max(L0, 0.001) / 0.04);
    
    return { 
      L0, 
      S0: -0.02 * scale, 
      C0: 0.5, 
      S_neg: -0.8 * scale, 
      S_pos: 0.9 * scale 
    };
  }

  private convertToSVIConfig(mc: ModelConfig): any {
    const edgeParams = new Map<string, any>();
    mc.buckets.forEach(b => edgeParams.set(b.name, b.edgeParams));
    return {
      bMin: mc.svi.bMin, sigmaMin: mc.svi.sigmaMin, rhoMax: mc.svi.rhoMax,
      sMax: mc.svi.slopeMax, c0Min: mc.svi.c0Min,
      buckets: mc.buckets.map(b => ({ name: b.name, minDelta: b.minDelta, maxDelta: b.maxDelta })),
      edgeParams, rbfWidth: mc.rbf.width, ridgeLambda: mc.rbf.ridgeLambda,
      maxL0Move: mc.riskLimits.maxL0Move, maxS0Move: mc.riskLimits.maxS0Move, maxC0Move: mc.riskLimits.maxC0Move
    };
  }

  updateCC(expiry: number, metrics: TraderMetrics): void {
    const newCC = SVI.fromMetrics(metrics, this.sviConfig);
    if (!SVI.validate(newCC, this.sviConfig)) throw new Error('Invalid SVI parameters');
    let s = this.surfaces.get(expiry);
    if (!s) { s = { expiry, cc: newCC, pc: newCC, nodes: new Map() }; this.surfaces.set(expiry, s); }
    else { s.cc = newCC; this.updatePC(s); }
    this.version++;
  }

  private updatePC(surface: EnhancedSurface): void {
    surface.pc = this.inventoryController.adjustSVIForInventory(surface.cc);
  }

  onTrade(trade: TradeExecution): void {
    const s = this.surfaces.get(trade.expiryMs);
    if (!s) { console.warn(`No surface for expiryMs=${trade.expiryMs}`); return; }
    const T = timeToExpiryYears(trade.expiryMs, trade.time ?? this.clockFn());
    if (T <= 0) { console.warn('Expired trade ignored (T<=0):', trade); return; }

    this.updateNodeState(s, {
      strike: trade.strike, price: trade.price, size: trade.size,
      expiryMs: trade.expiryMs, forward: trade.forward, optionType: trade.optionType, time: trade.time ?? this.clockFn()
    } as any);

    const F = trade.forward, K = trade.strike, isCall = trade.optionType === 'C';
    const ivFallback = this.marketIVs.get(trade.expiryMs) ?? 0.35;
    const k = Math.log(K / Math.max(F, tiny));

    let ccVar = SVI.w(s.cc, k);

    if (!Number.isFinite(ccVar) || ccVar <= 0) {
      const fallbackVar = ivFallback*ivFallback*Math.max(T,1e-8);
      console.log(`[onTrade] Using fallback variance: ${fallbackVar}`);
      ccVar = Math.max(fallbackVar, 1e-12);
    }
    let ccIV = Math.sqrt(ccVar / Math.max(T,1e-12));
    console.log(`[onTrade] After fallback: ccVar=${ccVar}, ccIV=${ccIV}`);

    const ivMin = Math.max(0.15, 0.5 * ivFallback);
    const ivUsed = Math.max(ccIV, ivMin);

    let g = black76Greeks(F, K, Math.max(T,1e-8), ivUsed, isCall, 1.0);
    if (!Number.isFinite(g.vega)) {
      g = black76Greeks(F, K, Math.max(T,1e-8), Math.max(ivFallback, ivMin), isCall, 1.0);
    }
    const vegaSafe = Number.isFinite(g.vega) ? g.vega : 0;

    const bucket = DeltaConventions.strikeToBucket(K, F, ivUsed, Math.max(T,1e-8));
    console.log(`[ISM.onTrade] bucket=${bucket} K=${K} size(dealer)=${trade.size} ccIV=${ccIV} ivUsed=${ivUsed} vega=${vegaSafe} product=${trade.size * vegaSafe}`);

    this.inventoryController.updateInventory(K, trade.size, vegaSafe, bucket);
    this.updatePC(s);
    this.version++;
  }

  private updateNodeState(surface: EnhancedSurface, trade: {
    strike: number; price: number; size: number; expiryMs: number;
    forward: number; optionType: 'C'|'P'; time: number;
  }): void {
    let node = surface.nodes.get(trade.strike);
    const T = timeToExpiryYears(trade.expiryMs, trade.time);
    const k = Math.log(trade.strike / Math.max(trade.forward, tiny));
    const ccVar = SVI.w(surface.cc, k);
    const ccIV  = Math.sqrt(Math.max(ccVar, tiny) / Math.max(T, 1e-8));
    const greeks = black76Greeks(trade.forward, trade.strike, Math.max(T,1e-8), ccIV, trade.optionType === 'C', 1.0);
    const widthRef = this.riskScorer.computeWidth({ gamma: greeks.gamma });
    const bucket = DeltaConventions.strikeToBucket(trade.strike, trade.forward, ccIV, Math.max(T, 1e-8));

    if (!node) {
      node = { strike: trade.strike, pcAnchor: trade.price, widthRef, position: trade.size, lastBucket: bucket, lastTradeTime: trade.time };
      surface.nodes.set(trade.strike, node);
    } else {
      node.pcAnchor = trade.price;
      node.position += trade.size;
      node.widthRef = widthRef;
      node.lastBucket = bucket;
      node.lastTradeTime = trade.time;
    }
  }

  calibrateFromMarket(expiry: number, marketQuotes: MarketQuoteForCalibration[], spot: number): void {
    if (marketQuotes.length === 0) { console.warn('No market quotes provided for calibration'); return; }
    const atm = marketQuotes.reduce((c, q) => Math.abs(q.strike - spot) < Math.abs(c.strike - spot) ? q : c);
    this.marketIVs.set(expiry, atm.iv);
    const m = this.deriveMetricsFromMarketIV(atm.iv, expiry);
    this.updateCC(expiry, m);
  }

  getQuote(expiryMs: number, strike: number, forward: number, optionType: 'C'|'P', marketIV?: number, nowMs?: number): Quote {
    const now = nowMs ?? this.clockFn();  // ← Use injected clock
    const isCall = optionType === 'C';
    const Traw = timeToExpiryYears(expiryMs, now);
    const T = Math.max(safe(Traw, 0), 1e-8);
    let s = this.surfaces.get(expiryMs);

    let atmIV: number; let recal = false;
    if (marketIV !== undefined) {
      atmIV = marketIV;
      const cached = this.marketIVs.get(expiryMs);
      if (!cached || Math.abs(atmIV - cached) > 0.01) { this.marketIVs.set(expiryMs, atmIV); recal = true; }
    } else atmIV = this.marketIVs.get(expiryMs) ?? 0.35;

    if (!s || recal) {
      const m = this.deriveMetricsFromMarketIV(atmIV, T);
      this.updateCC(expiryMs, m);
      s = this.surfaces.get(expiryMs)!;
      this.updatePC(s);
    }

    const k = safe(Math.log(strike / Math.max(forward, tiny)), 0);

    // CC mid - use total variance with clock injection
    const ccVarBase = Math.max(safe(SVI.w(s.cc, k), tiny), tiny);
    const ccSigmaBase = Math.sqrt(ccVarBase / T);
    const ccVarTotal = totalVariance({
      symbol: this.symbol,
      baseSigma: ccSigmaBase,
      startMs: now,  // ← Deterministic
      endMs: expiryMs
    });
    const tau = Math.max(tauIntegral(now, expiryMs), 1e-6);  // ← Floor tau at 1 microsecond
    let ccIV = Math.min(Math.max(safe(Math.sqrt(ccVarTotal / tau), 1e-8), 1e-8), 5.0);  // ← Cap at 500%
    let ccG = black76Greeks(forward, strike, T, ccIV, isCall, 1.0);
    let ccMid = safe(ccG.price, 0);

    // PC mid - use total variance
    const pcVarBase = Math.max(safe(SVI.w(s.pc, k), tiny), tiny);
    const pcSigmaBase = Math.sqrt(pcVarBase / T);
    const pcVarTotal = totalVariance({
      symbol: this.symbol,
      baseSigma: pcSigmaBase,
      startMs: now,  // ← Deterministic
      endMs: expiryMs
    });
    let pcIV = Math.min(Math.max(safe(Math.sqrt(pcVarTotal / tau), 1e-8), 1e-8), 5.0);  // ← Cap at 500%
    let pcG = black76Greeks(forward, strike, T, pcIV, isCall, 1.0);
    let pcMid = safe(pcG.price, 0);

    // Fallback mids if collapsed
    const ivFallback = Number.isFinite(marketIV) ? (marketIV as number) : 0.35;
    if (ccMid <= 1e-12) { ccG = black76Greeks(forward, strike, T, ivFallback, isCall, 1.0); ccMid = Math.max(0, ccG.price); ccIV = ivFallback; }
    if (pcMid <= 1e-12) { pcG = black76Greeks(forward, strike, T, ivFallback, isCall, 1.0); pcMid = Math.max(0, pcG.price); pcIV = ivFallback; }

    const midIsSane = (p: number) => Number.isFinite(p) && p >= 0 && p <= Math.max(forward, strike) * 2;
    if (!midIsSane(ccMid)) ccMid = Math.max(0, forward * ccIV * Math.sqrt(T) * 0.4);
    if (!midIsSane(pcMid)) pcMid = Math.max(0, forward * pcIV * Math.sqrt(T) * 0.4);

    const bucket = DeltaConventions.strikeToBucket(strike, forward, ccIV, T);

    let node = s.nodes.get(strike);
    if (!node) {
      node = { strike, pcAnchor: pcMid, widthRef: this.riskScorer.computeWidth({ gamma: ccG.gamma }), position: 0, lastBucket: bucket, lastTradeTime: now };
      s.nodes.set(strike, node);
    }

    const currentWidth = this.riskScorer.computeWidth({ gamma: pcG.gamma, J_L0: 1.0, J_S0: 0.5, J_C0: 0.3 });
    const bid = Math.max(0, pcMid - currentWidth);
    const ask = pcMid + currentWidth;
    const edge = pcMid - ccMid;

    // Inventory-aware sizes (simple)
    const baseSize = this.config.quotes.sizeBlocks;
    const invState = this.inventoryController.getInventoryState();
    const bucketInv = invState.get(bucket as any);
    let bidSize = baseSize, askSize = baseSize;
    if (bucketInv && typeof (bucketInv as any).vega === 'number') {
      const vegaSigned = (bucketInv as any).vega as number;
      const vref = this.config.buckets.find((b) => b.name === bucket)?.edgeParams.Vref ?? 100;
      const invRatio = Math.min(5, Math.abs(vegaSigned) / Math.max(vref, 1e-6));
      if (vegaSigned < 0) askSize = Math.max(10, Math.round(baseSize * Math.exp(-invRatio)));
      else if (vegaSigned > 0) bidSize = Math.max(10, Math.round(baseSize * Math.exp(-invRatio)));
    }

    return { bid, ask, bidSize, askSize, pcMid, ccMid, edge, bucket };
  }

  getInventorySummary() {
    const invState = this.inventoryController.getInventoryState();
    const adjustments = this.inventoryController.calculateSmileAdjustments();
    const summary = { totalVega: 0, byBucket: {} as any, smileAdjustments: adjustments };
    for (const [bucket, inv] of invState) {
      const v = Number(inv.vega) || 0;
      summary.totalVega += v;
      (summary.byBucket as any)[bucket] = { vega: v, count: inv.count };
    }
    return summary;
  }

  getCCSVI(expiryMs: number): SVIParams | null {
    const s = this.surfaces.get(expiryMs);
    return s ? s.cc : null;
  }

  resetAllState(): void {
    this.surfaces.clear();
    this.marketIVs.clear();
    this.inventoryController = new SmileInventoryController(this.config);
    this.version = 0;
  }
}

---------- END apps/server/src/volModels/integratedSmileModel.ts ----------

---------- BEGIN apps/server/src/volModels/integration/basicIntegration.ts (bytes=358) ----------
import { CorrectedAdapter } from '../correctedAdapter';

// Start with just BTC to test
const btcModel = new CorrectedAdapter(100);  // Initialize with spot price

// Simple function to get a quote
export function getVolQuote(strike: number) {
  return btcModel.getQuote(strike);
}

// Test it works
console.log('Test quote for strike 95:', getVolQuote(95));
---------- END apps/server/src/volModels/integration/basicIntegration.ts ----------

---------- BEGIN apps/server/src/volModels/integration/volModelService.ts (bytes=7330) ----------
// Single-calculus adapter: λ·g shift on quotes, factor inventory on trades.

import { IntegratedSmileModel } from "../integratedSmileModel";
import { FactorVec, ZeroFactors, axpy, dot } from "../factors/FactorSpace";
import { factorGreeksFiniteDiff } from "../factors/factorGreeks";
import { timeToExpiryYears } from "../../utils/time";

export type Side = "BUY" | "SELL";
export type OptionType = "C" | "P";

type SymbolState = {
  model: IntegratedSmileModel;
  forward: number;
  lambda: FactorVec;      // cost per unit factor exposure (tunable)
  inventory: FactorVec;   // running factor inventory
};

const YEAR_MS = 365.25 * 24 * 3600 * 1000;
const DEFAULT_FORWARDS: Record<string, number> = { BTC: 45000, ETH: 3000 };
const DEFAULT_LAMBDA: FactorVec = [
  0.00001,   // L0 - scale way down
  0.00002,   // S0
  0.0001,    // C0  
  0.00005,   // S_neg
  0.00002,   // S_pos
  0.000001   // F
];

function nowMs() { return Date.now(); }
function ensureMs(expiryOrYears: number): number {
  return expiryOrYears > 1e10
    ? Math.floor(expiryOrYears)
    : Math.floor(nowMs() + Math.max(expiryOrYears, 0) * YEAR_MS);
}
const FACTOR_CFG = {
  bMin: 1e-6,
  sigmaMin: 1e-6,
  rhoMax: 0.999,
  sMax: 5,
  c0Min: 0.01,
  buckets: [],
  edgeParams: new Map(),
  rbfWidth: 0,
  ridgeLambda: 0,
  maxL0Move: 0,
  maxS0Move: 0,
  maxC0Move: 0
};
class VolModelService {
  private symbols = new Map<string, SymbolState>();

  private ensure(symbol: string): SymbolState {
    let s = this.symbols.get(symbol);
    if (!s) {
      s = {
        model: new IntegratedSmileModel(symbol as any),
        forward: DEFAULT_FORWARDS[symbol] ?? DEFAULT_FORWARDS.BTC,
        lambda: [...DEFAULT_LAMBDA],
        inventory: [...ZeroFactors],
      };
      this.symbols.set(symbol, s);
    }
    return s;
  }

  updateSpot(symbol: string, forward: number) {
    const s = this.ensure(symbol);
    s.forward = forward;
  }
  updateForward(symbol: string, forward: number) { this.updateSpot(symbol, forward); }

  // ------ READ/WRITE FACTORS (λ, I) ------
  getFactors(symbol: string) {
    const s = this.ensure(symbol);
    return {
      lambda: s.lambda,
      inventory: s.inventory,
      lambdaDotInventory: dot(s.lambda, s.inventory),
    };
  }
  setLambda(symbol: string, lambda: FactorVec) {
    const s = this.ensure(symbol);
    s.lambda = lambda;
    return this.getFactors(symbol);
  }
  clearInventory(symbol: string) {
    const s = this.ensure(symbol);
    s.inventory = [...ZeroFactors];
    return this.getFactors(symbol);
  }

  // ------ QUOTES WITH λ·g SHIFT ------
  getQuoteWithIV(
    symbol: string,
    strike: number,
    expiryMsOrYears: number,
    marketIV?: number,        // ← Move marketIV before optionType
    optionType: OptionType = "C"
  ) {
    
    const s = this.ensure(symbol);
    const expiryMs = ensureMs(expiryMsOrYears);

    // Base quotes from the model (PC/CC separation done inside)
    const q = s.model.getQuote(expiryMs, strike, s.forward, optionType, marketIV);
    const rawMid = (q.bid + q.ask) / 2;
    const half   = Math.max(0, (q.ask - q.bid) / 2);

    // Compute CC-based factor greeks and apply λ·g as a parallel mid shift
    let bid = q.bid, ask = q.ask, adjPcMid = q.pcMid ?? rawMid;
    let ladg = 0;
    try {
      const cc = s.model.getCCSVI(expiryMs);
      if (cc) {
        const T = Math.max(timeToExpiryYears(expiryMs), 1e-8);
        const isCall = optionType === "C";
        const g = factorGreeksFiniteDiff(cc, strike, T, s.forward, isCall, FACTOR_CFG);
        ladg = dot(s.lambda, g);
        adjPcMid = (q.pcMid ?? rawMid) + (Number.isFinite(ladg) ? ladg : 0);
        bid = Math.max(0, adjPcMid - half);
        ask = adjPcMid + half;

        // Lightweight debug (safe to keep or comment out)
        // console.debug(`[quote λ·g] ${symbol} K=${strike} T=${T.toFixed(4)} ladg=${ladg.toFixed(4)} mid=${rawMid.toFixed(4)}→${adjPcMid.toFixed(4)}`);
      }
    } catch {
      // keep original q on any calc issue
    }

    return {
      bid,
      ask,
      bidSize: q.bidSize,
      askSize: q.askSize,
      mid: (bid + ask) / 2,
      spread: Math.max(0, ask - bid),
      edge: q.edge,
      pcMid: adjPcMid,
      ccMid: q.ccMid,
      bucket: q.bucket,
      ladg, // expose inventory edge for UI/observability
    };
  }

  // ------ TRADES UPDATE INVENTORY (I ← I + q·g) AND INFORM MODEL ------
  onCustomerTrade(
    symbol: string,
    strike: number,
    side: Side,
    size: number,
    price: number,
    expiryMs: number,
    optionType: OptionType,
    timestamp?: number,
    marketIV?: number
  ) {
    const s = this.ensure(symbol);
    const t = timestamp ?? nowMs();

    console.log(`[volService.onCustomerTrade] marketIV=${marketIV}, expiryMs=${expiryMs}`);
    // Ensure the surface exists (will also (re)calibrate if marketIV provided)
    s.model.getQuote(expiryMs, strike, s.forward, optionType, marketIV);

    // Ensure the surface exists (will also (re)calibrate if marketIV provided)
    s.model.getQuote(expiryMs, strike, s.forward, optionType, marketIV);

    // Verify surface was created properly
    const cc = s.model.getCCSVI(expiryMs);
    if (cc) {
      console.log(`[volService] CC after getQuote: a=${cc.a}, b=${cc.b}, rho=${cc.rho}, sigma=${cc.sigma}, m=${cc.m}`);
      if (cc.a === null || !Number.isFinite(cc.a)) {
        console.error(`[volService] INVALID CC: a=${cc.a} - surface calibration failed`);
  }
}

    // Customer side → signed size for our inventory: BUY => we are short
    const signedSize = side === "BUY" ? -Math.abs(size) : +Math.abs(size);

    // Update factor inventory via CC-based greeks at trade point
try {
  const cc = s.model.getCCSVI(expiryMs);
  if (cc) {
    console.log(`[volService] Computing factor greeks: K=${strike}, T=${timeToExpiryYears(expiryMs, t)}, F=${s.forward}, optionType=${optionType}`);
    const T = Math.max(timeToExpiryYears(expiryMs, t), 1e-8);
    const isCall = optionType === "C";
    const g = factorGreeksFiniteDiff(cc, strike, T, s.forward, isCall, FACTOR_CFG);
    console.log(`[volService] Factor greeks: g=[${g.map(x => x.toFixed(6)).join(', ')}]`);
    console.log(`[volService] I_old=[${s.inventory.map(x => x.toFixed(2)).join(', ')}]`);
    s.inventory = axpy(s.inventory, signedSize, g);
    console.log(`[volService] I_new=[${s.inventory.map(x => x.toFixed(2)).join(', ')}] (signedSize=${signedSize})`);
  } else {
    console.warn(`[volService] No CC surface found for expiryMs=${expiryMs}`);
  }
} catch (err) {
  console.error(`[volService] Factor inventory update FAILED:`, err);
  // best-effort inventory; model booking still happens
}

    // Book into model (inventory-aware PC inside model adjusts too)
    s.model.onTrade({
      expiryMs,
      strike,
      forward: s.forward,
      optionType,
      price,
      size: signedSize, // customer-signed convention (negative when we sell)
      time: t,
    });

    return true;
  }

  getInventory(symbol: string) {
    const s = this.ensure(symbol);
    return s.model.getInventorySummary();
  }
  
  getFactorInventory(symbol: string) {
    const s = this.ensure(symbol);
    return {
      inventory: s.inventory,
      lambda: s.lambda,
      lambdaDotInventory: dot(s.lambda, s.inventory)
    };
  }
}

export const volService = new VolModelService();

---------- END apps/server/src/volModels/integration/volModelService.ts ----------

---------- BEGIN apps/server/src/volModels/invariants.ts (bytes=666) ----------
// apps/server/src/volModels/invariants.ts
import type { TraderMetrics } from "./sviMapping";

export function assertMetricsInvariants(m: TraderMetrics, eps = 1e-9) {
  const b = 0.5 * (m.S_pos + m.S_neg);
  const denom = Math.max(m.S_pos + m.S_neg, eps);
  const rho = (m.S_pos - m.S_neg) / denom;
  const S0_expected = b * rho;

  if (!Number.isFinite(b) || b <= 0) {
    throw new Error(`[metrics] invalid b: ${b}`);
  }
  if (!Number.isFinite(rho) || Math.abs(rho) >= 1) {
    throw new Error(`[metrics] invalid rho: ${rho}`);
  }
  if (Math.abs(m.S0 - S0_expected) > 1e-6) {
    throw new Error(`[metrics] S0 mismatch: S0=${m.S0}, b*rho=${S0_expected}`);
  }
}

---------- END apps/server/src/volModels/invariants.ts ----------

---------- BEGIN apps/server/src/volModels/marketScenarios.ts (bytes=5306) ----------
/**
 * Market Making Scenarios
 * Test how the model behaves in different situations
 */

import { SimpleAdapter } from './simpleAdapter';

function scenario1_NormalFlow() {
  console.log('\n' + '='.repeat(60));
  console.log('SCENARIO 1: Normal Customer Flow');
  console.log('='.repeat(60));
  
  const model = new SimpleAdapter(100);
  
  console.log('\nCustomer wants to buy protection (buy puts)...');
  model.formatQuotes([90, 95, 100], 0.08);
  
  // Customer buys 95 puts
  const fill1 = model.executeTrade(95, 0.08, 'BUY', 50);
  console.log(`\n✓ Customer BOUGHT 50x 95 puts @ ${fill1.price.toFixed(2)}`);
  console.log('  (We are now SHORT 50 puts)');
  
  console.log('\nUpdated quotes - notice ask is wider:');
  model.formatQuotes([90, 95, 100], 0.08);
  
  // Another customer sells puts to us
  const fill2 = model.executeTrade(95, 0.08, 'SELL', 30);
  console.log(`\n✓ Customer SOLD 30x 95 puts @ ${fill2.price.toFixed(2)}`);
  console.log('  (We are now SHORT only 20 puts)');
  
  console.log('\nRisk reduced, spreads tighten:');
  model.formatQuotes([90, 95, 100], 0.08);
  
  const inv = model.getInventory();
  console.log(`\nNet position: ${inv.totalVega.toFixed(1)} vega`);
}

function scenario2_InventoryManagement() {
  console.log('\n' + '='.repeat(60));
  console.log('SCENARIO 2: Building and Managing Inventory');
  console.log('='.repeat(60));
  
  const model = new SimpleAdapter(100);
  
  console.log('\nInitial quotes (flat):');
  model.formatQuotes([95, 100, 105], 0.08);
  
  // Accumulate short gamma
  console.log('\n1. Selling premium (getting short gamma)...');
  model.executeTrade(100, 0.08, 'SELL', 100);  // Sell ATM
  model.executeTrade(95, 0.08, 'SELL', 50);    // Sell puts
  model.executeTrade(105, 0.08, 'SELL', 50);   // Sell calls
  
  console.log('\nAfter selling - edge is positive (PC > CC):');
  model.formatQuotes([95, 100, 105], 0.08);
  
  const inv1 = model.getInventory();
  console.log(`Position: ${inv1.totalVega.toFixed(1)} vega`);
  console.log(`Smile adjustment: Level +${(inv1.smileAdjustments.deltaL0 * 100).toFixed(2)}%`);
  
  // Try to reduce risk
  console.log('\n2. Trying to buy back some risk...');
  model.executeTrade(100, 0.08, 'BUY', 50);  // Buy back ATM
  
  console.log('\nAfter reducing - edge decreases:');
  model.formatQuotes([95, 100, 105], 0.08);
  
  const inv2 = model.getInventory();
  console.log(`Position: ${inv2.totalVega.toFixed(1)} vega`);
  console.log(`Smile adjustment: Level +${(inv2.smileAdjustments.deltaL0 * 100).toFixed(2)}%`);
}

function scenario3_SkewTrading() {
  console.log('\n' + '='.repeat(60));
  console.log('SCENARIO 3: Skew Trading (Put-Call Imbalance)');
  console.log('='.repeat(60));
  
  const model = new SimpleAdapter(100);
  
  console.log('\nBalanced market initially:');
  model.formatQuotes([90, 95, 100, 105, 110], 0.08);
  
  // Heavy put selling
  console.log('\n1. Market sells puts aggressively...');
  model.executeTrade(95, 0.08, 'SELL', 100);
  model.executeTrade(90, 0.08, 'SELL', 100);
  
  console.log('\nPut skew emerges (puts more expensive):');
  model.formatQuotes([90, 95, 100, 105, 110], 0.08);
  
  const inv1 = model.getInventory();
  console.log(`\nSkew adjustment: ${(inv1.smileAdjustments.deltaS0 * 100).toFixed(3)}%`);
  
  // Now calls get sold
  console.log('\n2. Market sells calls to balance...');
  model.executeTrade(105, 0.08, 'SELL', 100);
  model.executeTrade(110, 0.08, 'SELL', 100);
  
  console.log('\nMore balanced smile:');
  model.formatQuotes([90, 95, 100, 105, 110], 0.08);
  
  const inv2 = model.getInventory();
  console.log(`\nTotal position: ${inv2.totalVega.toFixed(1)} vega`);
  console.log('Inventory by bucket:');
  Object.entries(inv2.byBucket).forEach(([bucket, data]: [string, any]) => {
    if (data.vega !== 0) {
      console.log(`  ${bucket}: ${data.vega.toFixed(1)} vega`);
    }
  });
}

function scenario4_StressTest() {
  console.log('\n' + '='.repeat(60));
  console.log('SCENARIO 4: Stress Test (Large Position)');
  console.log('='.repeat(60));
  
  const model = new SimpleAdapter(100);
  
  console.log('\nNormal market:');
  model.formatQuotes([95, 100, 105], 0.08);
  
  console.log('\n💥 Massive one-sided flow hits...');
  model.executeTrade(100, 0.08, 'SELL', 500);  // Huge ATM sale
  
  console.log('\nExtreme adjustment - look at the edge!');
  model.formatQuotes([95, 100, 105], 0.08);
  
  const inv = model.getInventory();
  console.log(`\nPosition: ${inv.totalVega.toFixed(1)} vega (very short!)`);
  console.log(`Level adjustment: ${(inv.smileAdjustments.deltaL0 * 100).toFixed(2)}% 🚨`);
  
  console.log('\nThis shows the model protects itself with wide spreads');
  console.log('when inventory gets extreme.');
}

// Run all scenarios
function runAll() {
  scenario1_NormalFlow();
  scenario2_InventoryManagement();
  scenario3_SkewTrading();
  scenario4_StressTest();
  
  console.log('\n' + '='.repeat(60));
  console.log('SCENARIOS COMPLETE');
  console.log('='.repeat(60));
  console.log('\nKey observations:');
  console.log('1. Edge (PC-CC) grows with inventory risk');
  console.log('2. Sizes adjust based on position direction');
  console.log('3. Entire smile shifts, not just single strikes');
  console.log('4. Model naturally tries to reduce inventory via pricing');
}

runAll();
---------- END apps/server/src/volModels/marketScenarios.ts ----------

---------- BEGIN apps/server/src/volModels/multiTradeTest.ts (bytes=6454) ----------
/**
 * Multi-trade test scenario
 * Shows how smile evolves with complex inventory
 */

import { IntegratedSmileModel, TradeExecution } from './integratedSmileModel';
import { TraderMetrics } from './dualSurfaceModel';

function runMultiTradeScenario() {
  console.log('\n' + '='.repeat(70));
  console.log('MULTI-TRADE SCENARIO - REALISTIC MARKET MAKING SESSION');
  console.log('='.repeat(70) + '\n');
  
  const model = new IntegratedSmileModel('BTC');
  const expiry = 0.25; // 3 months
  const spot = 100;
  
  // Initialize with typical market conditions
  const initialMetrics: TraderMetrics = {
    L0: 0.04,    // 20% vol for 3M
    S0: -0.002,  // Slight put skew (normal market)
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, initialMetrics);
  console.log('Market opened with 20% ATM vol, slight put skew\n');
  
  // Helper function to show state
  const showState = (title: string) => {
    console.log('\n' + '-'.repeat(70));
    console.log(title);
    console.log('-'.repeat(70) + '\n');
    
    const strikes = [90, 95, 100, 105, 110];
    
    console.log('Strike | Bid    | Ask    | Mid    | CC Mid | Edge  | Vol   | Size');
    console.log('-'.repeat(70));
    
    for (const strike of strikes) {
      const quote = model.getQuote(expiry, strike, spot);
      const k = Math.log(strike / spot);
      
      // Get the vol for display
      const surface = (model as any).surfaces.get(expiry);
      const pcVar = surface ? (surface.pc as any).w(k) : 0;
      const vol = Math.sqrt(pcVar / expiry) * 100;
      
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${quote.bid.toFixed(2).padStart(6)} | ` +
        `${quote.ask.toFixed(2).padStart(6)} | ` +
        `${quote.pcMid.toFixed(2).padStart(6)} | ` +
        `${quote.ccMid.toFixed(2).padStart(6)} | ` +
        `${quote.edge.toFixed(2).padStart(5)} | ` +
        `${vol.toFixed(1).padStart(5)}% | ` +
        `${quote.bidSize}/${quote.askSize}`
      );
    }
    
    const summary = model.getInventorySummary();
    console.log(`\nTotal Vega: ${summary.totalVega.toFixed(1)}`);
    
    // Show inventory by bucket
    console.log('\nInventory by bucket:');
    for (const [bucket, data] of Object.entries(summary.byBucket)) {
      if ((data as any).vega !== 0) {
        console.log(`  ${bucket}: ${(data as any).vega.toFixed(1)} vega`);
      }
    }
    
    // Show smile adjustments
    const adj = summary.smileAdjustments;
    if (Math.abs(adj.deltaL0) + Math.abs(adj.deltaS0) + Math.abs(adj.deltaSNeg) > 0.0001) {
      console.log('\nSmile adjustments:');
      console.log(`  Level: ${(adj.deltaL0 * 100).toFixed(3)}% vol`);
      console.log(`  Skew:  ${(adj.deltaS0 * 100).toFixed(3)}% vol/unit`);
      console.log(`  L-wing: ${(adj.deltaSNeg * 100).toFixed(3)}% vol/unit`);
    }
  };
  
  // Show initial state
  showState('INITIAL STATE - Empty book');
  
  // TRADE 1: Customer sells 25-delta puts
  console.log('\n' + '='.repeat(70));
  console.log('TRADE 1: Customer SELLS 200 lots of 95 strike (25-delta put)');
  console.log('Market maker perspective: We BUY puts (long vol, short skew)');
  
  const trade1: TradeExecution = {
    expiry,
    strike: 95,
    price: 5.34,  // Near mid
    size: -200,   // Negative = we sold to customer = we're short
    spot,
    time: Date.now()
  };
  model.onTrade(trade1);
  
  showState('After Trade 1 - Short 25d puts');
  
  // TRADE 2: Another customer buys ATM straddle
  console.log('\n' + '='.repeat(70));
  console.log('TRADE 2: Customer BUYS 100 lots ATM straddle');
  console.log('Market maker perspective: We SELL straddle (short ATM vol)');
  
  const trade2: TradeExecution = {
    expiry,
    strike: 100,
    price: 7.97,
    size: -100,  // Selling ATM
    spot,
    time: Date.now() + 1000
  };
  model.onTrade(trade2);
  
  showState('After Trade 2 - Short 25d puts + Short ATM');
  
  // TRADE 3: Hedge trade - buy some 10-delta puts
  console.log('\n' + '='.repeat(70));
  console.log('TRADE 3: We BUY 150 lots of 90 strike (10-delta put) as hedge');
  
  const trade3: TradeExecution = {
    expiry,
    strike: 90,
    price: 3.39,
    size: 150,  // Positive = we bought
    spot,
    time: Date.now() + 2000
  };
  model.onTrade(trade3);
  
  showState('After Trade 3 - Mixed inventory across strikes');
  
  // TRADE 4: Customer lifts offer on OTM calls
  console.log('\n' + '='.repeat(70));
  console.log('TRADE 4: Customer BUYS 100 lots of 110 calls (wings)');
  
  const trade4: TradeExecution = {
    expiry,
    strike: 110,
    price: 14.92,
    size: -100,
    spot,
    time: Date.now() + 3000
  };
  model.onTrade(trade4);
  
  showState('After Trade 4 - Complex inventory across smile');
  
  // TRADE 5: Unwind some risk
  console.log('\n' + '='.repeat(70));
  console.log('TRADE 5: Unwind - We BUY back 100 lots of 95 puts');
  
  const trade5: TradeExecution = {
    expiry,
    strike: 95,
    price: 5.40,  // Paying slightly above mid to close
    size: 100,    // Buying back
    spot,
    time: Date.now() + 4000
  };
  model.onTrade(trade5);
  
  showState('After Trade 5 - Partially unwound');
  
  // Summary
  console.log('\n' + '='.repeat(70));
  console.log('SCENARIO SUMMARY');
  console.log('='.repeat(70) + '\n');
  
  console.log('Trades executed:');
  console.log('  1. Sold 200x 95 puts  (customer selling pressure)');
  console.log('  2. Sold 100x 100 ATM  (straddle seller)');
  console.log('  3. Bought 150x 90 puts (hedge/inventory management)');
  console.log('  4. Sold 100x 110 calls (customer buying OTM)');
  console.log('  5. Bought 100x 95 puts (risk reduction)');
  
  const finalSummary = model.getInventorySummary();
  console.log('\nFinal inventory:');
  console.log(`  Total vega: ${finalSummary.totalVega.toFixed(1)}`);
  for (const [bucket, data] of Object.entries(finalSummary.byBucket)) {
    if ((data as any).vega !== 0) {
      console.log(`  ${bucket}: ${(data as any).vega.toFixed(1)} vega`);
    }
  }
  
  console.log('\nKey observations:');
  console.log('  • Smile should steepen when net short puts');
  console.log('  • ATM vol should lift when short gamma');
  console.log('  • Quotes should widen on inventory-heavy strikes');
  console.log('  • PC diverges from CC based on positioning');
  
  console.log('\n' + '='.repeat(70) + '\n');
}

// Run the scenario
if (require.main === module) {
  runMultiTradeScenario();
}

export { runMultiTradeScenario };
---------- END apps/server/src/volModels/multiTradeTest.ts ----------

---------- BEGIN apps/server/src/volModels/pricing/blackScholes.ts (bytes=5149) ----------
/**
 * Black-Scholes Pricing Engine
 * Handles option pricing and Greeks calculation
 * Conventions:
 *  - Vega: per absolute vol unit (1.0 = 100% vol)
 *  - Theta: per year (no /365 here; divide at display time if needed)
 *  - Rho: per 1% rate move (kept for compatibility)
 */

function normCdf(x: number): number {
    const a1 = 0.254829592;
    const a2 = -0.284496736;
    const a3 = 1.421413741;
    const a4 = -1.453152027;
    const a5 = 1.061405429;
    const p = 0.3275911;
  
    const sign = x >= 0 ? 1 : -1;
    const absX = Math.abs(x) / Math.sqrt(2);
    const t = 1 / (1 + p * absX);
    const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-absX * absX);
    return 0.5 * (1 + sign * y);
  }
  
  function normPdf(x: number): number {
    return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
  }
  
  export interface OptionInputs {
    strike: number;
    spot: number;
    vol: number;   // annualized volatility (decimal)
    T: number;     // time to expiry in years
    r: number;     // risk-free rate (decimal)
    isCall: boolean;
  }
  
  export interface OptionGreeks {
    price: number;
    delta: number;
    gamma: number;
    vega: number;   // per absolute vol
    theta: number;  // per year
    rho: number;    // per 1% rate move
  }
  
  export function blackScholes(inputs: OptionInputs): OptionGreeks {
    const { strike, spot, vol, T, r, isCall } = inputs;
  
    if (T <= 0) {
      const intrinsic = isCall ? Math.max(spot - strike, 0) : Math.max(strike - spot, 0);
      return { price: intrinsic, delta: intrinsic > 0 ? (isCall ? 1 : -1) : 0, gamma: 0, vega: 0, theta: 0, rho: 0 };
    }
  
    const sqrtT = Math.sqrt(T);
    const d1 = (Math.log(spot / strike) + (r + 0.5 * vol * vol) * T) / (vol * sqrtT);
    const d2 = d1 - vol * sqrtT;
  
    const Nd1 = normCdf(d1);
    const Nd2 = normCdf(d2);
    const Nmd1 = normCdf(-d1);
    const Nmd2 = normCdf(-d2);
  
    const df = Math.exp(-r * T);
  
    let price: number;
    let delta: number;
  
    if (isCall) {
      price = spot * Nd1 - strike * df * Nd2;
      delta = Nd1;
    } else {
      price = strike * df * Nmd2 - spot * Nmd1;
      delta = -Nmd1;
    }
  
    const nd1 = normPdf(d1);
    const gamma = nd1 / (spot * vol * sqrtT);
  
    // ✅ Vega per absolute vol unit
    const vega = spot * nd1 * sqrtT;
  
    // ✅ Theta per YEAR (no /365)
    let theta: number;
    if (isCall) {
      theta = -spot * nd1 * vol / (2 * sqrtT) - r * strike * df * Nd2;
    } else {
      theta = -spot * nd1 * vol / (2 * sqrtT) + r * strike * df * Nmd2;
    }
  
    // Rho per 1% rate move (kept)
    const rho = isCall ? (strike * T * df * Nd2) / 100 : (-strike * T * df * Nmd2) / 100;
  
    return { price, delta, gamma, vega, theta, rho };
  }
  
  /**
   * Newton solver for BS implied vol
   * Assumes vega is per absolute vol (no 100x scaling).
   */
  export function impliedVol(
    price: number,
    strike: number,
    spot: number,
    T: number,
    r: number,
    isCall: boolean,
    maxIterations: number = 50,
    tolerance: number = 1e-6
  ): number | null {
    let vol = Math.sqrt(2 * Math.PI / Math.max(T, 1e-12)) * Math.max(price, 1e-12) / Math.max(spot, 1e-12);
    vol = Math.max(0.001, Math.min(5.0, vol));
  
    for (let i = 0; i < maxIterations; i++) {
      const res = blackScholes({ strike, spot, vol, T, r, isCall });
      const diff = res.price - price;
      if (Math.abs(diff) < tolerance) return vol;
  
      const vega = res.vega; // ✅ already per absolute vol
      if (Math.abs(vega) < 1e-10) return null;
  
      vol = Math.max(0.001, Math.min(5.0, vol - diff / vega));
    }
    return null;
  }
  
  export class PriceVolConverter {
    static varianceToIV(variance: number, T: number): number {
      if (T <= 0) return 0;
      return Math.sqrt(variance / T);
    }
    static ivToVariance(iv: number, T: number): number {
      return iv * iv * T;
    }
    static priceFromVariance(
      variance: number,
      strike: number,
      spot: number,
      T: number,
      r: number,
      isCall: boolean
    ): number {
      const iv = this.varianceToIV(variance, T);
      return blackScholes({ strike, spot, vol: iv, T, r, isCall }).price;
    }
  }
  
  export class DeltaConventions {
    static spotDelta(inputs: OptionInputs): number {
      return blackScholes(inputs).delta;
    }
    static forwardDelta(inputs: OptionInputs): number {
      const df = Math.exp(-inputs.r * inputs.T);
      return this.spotDelta(inputs) / df;
    }
    // 🔤 rename: simplicDelta -> simpleDelta
    static simpleDelta(inputs: OptionInputs): number {
      return Math.abs(this.spotDelta(inputs));
    }
    static strikeToBucket(
      strike: number,
      spot: number,
      vol: number,
      T: number,
      r: number = 0
    ): string {
      const delta = Math.abs(this.spotDelta({ strike, spot, vol, T, r, isCall: false })); // put-delta convention
      if (delta >= 0.40 && delta <= 0.60) return 'atm';
      if (delta >= 0.18 && delta <= 0.32) return 'rr25';
      if (delta >= 0.06 && delta <= 0.14) return 'rr10';
      return 'wings';
    }
  }
  
---------- END apps/server/src/volModels/pricing/blackScholes.ts ----------

---------- BEGIN apps/server/src/volModels/quoteEngineAdapter.ts (bytes=8486) ----------
/**
 * Quote Engine Adapter
 * Bridges the integrated smile model to external quote engines / UIs.
 */

import { IntegratedSmileModel } from "./integratedSmileModel";

// Request/response types
export interface QuoteRequest {
  symbol: string;
  strike: number;
  expiryMs: number;               // absolute timestamp (ms)
  optionType: "C" | "P";
  side: "BUY" | "SELL" | "BOTH";
  size: number;
  clientId?: string;
  marketIV?: number;              // optional ATM market IV (decimal)
}

export interface Quote {
  symbol: string;
  strike: number;
  expiryMs: number;
  bid: number;
  ask: number;
  bidSize: number;
  askSize: number;
  mid: number;
  edge: number;
  timestamp: Date;
}

export interface Fill {
  symbol: string;
  strike: number;
  expiryMs: number;
  side: "BUY" | "SELL";
  price: number;
  size: number;
  timestamp: Date;
  clientId?: string;
}

export interface RiskMetrics {
  totalVega: number;
  totalGamma: number;
  totalTheta: number;
  buckets: { name: string; vega: number; gamma: number; edge: number }[];
  smileAdjustments: { level: number; skew: number; leftWing: number; rightWing: number };
}

export class QuoteEngineAdapter {
  private model: IntegratedSmileModel;
  private symbol: string;
  private forward: number; // forward, not spot

  private callbackHandlers: {
    onQuoteUpdate?: (quotes: Quote[]) => void;
    onFill?: (fill: Fill) => void;
    onRiskUpdate?: (risk: RiskMetrics) => void;
  } = {};

  constructor(symbol: string, forward: number) {
    this.symbol = symbol;
    this.forward = forward;
    this.model = new IntegratedSmileModel(); // no initialize()
  }

  /** Get a single quote */
  getQuote(req: QuoteRequest): Quote {
    const q = this.model.getQuote(
      req.expiryMs,
      req.strike,
      this.forward,
      req.optionType,
      req.marketIV
    );

    // Size gating
    let bidSize = q.bidSize;
    let askSize = q.askSize;
    if (req.side === "BUY") askSize = Math.min(askSize, req.size);
    if (req.side === "SELL") bidSize = Math.min(bidSize, req.size);

    return {
      symbol: this.symbol,
      strike: req.strike,
      expiryMs: req.expiryMs,
      bid: q.bid,
      ask: q.ask,
      bidSize,
      askSize,
      mid: (q.bid + q.ask) / 2,
      edge: q.edge,
      timestamp: new Date(),
    };
  }

  /** Get multiple quotes (for quote grids) */
  getQuoteGrid(strikes: number[], expiryMs: number, optionType: "C" | "P" = "C"): Quote[] {
    return strikes.map((strike) =>
      this.getQuote({
        symbol: this.symbol,
        strike,
        expiryMs,
        optionType,
        side: "BOTH",
        size: 100,
      })
    );
  }

  /** Execute a trade (customer side) */
  executeTrade(
    strike: number,
    expiryMs: number,
    side: "BUY" | "SELL",
    size: number,
    price?: number,
    optionType: "C" | "P" = "C",
    clientId?: string
  ): Fill {
    // If no price given, take our current quote
    if (price == null) {
      const q = this.getQuote({
        symbol: this.symbol,
        strike,
        expiryMs,
        optionType,
        side,
        size,
      });
      price = side === "BUY" ? q.ask : q.bid;
    }

    // Signed size from CUSTOMER perspective (BUY means we SELL => negative)
    const signedSize = side === "BUY" ? -Math.abs(size) : Math.abs(size);

    // Inform the model
    this.model.onTrade({
      expiryMs,
      strike,
      forward: this.forward,
      optionType,
      price,
      size: signedSize,
      time: Date.now(),
    });

    const fill: Fill = {
      symbol: this.symbol,
      strike,
      expiryMs,
      side,
      price,
      size,
      timestamp: new Date(),
      clientId,
    };

    this.notifyFill(fill);
    this.notifyQuoteUpdate(expiryMs);
    this.notifyRiskUpdate();

    return fill;
  }

  /** Risk metrics proxy */
  getRiskMetrics(): RiskMetrics {
    const inv = this.model.getInventorySummary();
    const sa = inv.smileAdjustments;

    const buckets = Object.entries(inv.byBucket || {}).map(([name, m]: [string, any]) => ({
      name,
      vega: m.vega ?? 0,
      gamma: m.gamma ?? 0,
      edge: m.edgeRequired ?? 0,
    }));

    return {
      totalVega: inv.totalVega ?? 0,
      totalGamma: 0,
      totalTheta: 0,
      buckets,
      smileAdjustments: {
        level: sa.deltaL0,
        skew: sa.deltaS0,
        leftWing: sa.deltaSNeg,
        rightWing: sa.deltaSPos,
      },
    };
  }

  /** Update forward (perp) */
  updateForward(newForward: number): void {
    this.forward = newForward;
    this.notifyQuoteUpdate();
  }

  /** Events */
  on(event: "quote" | "fill" | "risk", handler: Function): void {
    if (event === "quote") this.callbackHandlers.onQuoteUpdate = handler as any;
    if (event === "fill") this.callbackHandlers.onFill = handler as any;
    if (event === "risk") this.callbackHandlers.onRiskUpdate = handler as any;
  }

  /** Internals */
  private defaultExpiryMs(): number {
    // default: 1 week ahead
    return Date.now() + 7 * 24 * 3600 * 1000;
  }

  private notifyQuoteUpdate(expiryMs?: number): void {
    if (!this.callbackHandlers.onQuoteUpdate) return;
    const strikes = this.generateStrikeGrid(this.forward);
    const ems = expiryMs ?? this.defaultExpiryMs();
    const quotes = this.getQuoteGrid(strikes, ems, "C");
    this.callbackHandlers.onQuoteUpdate(quotes);
  }

  private notifyFill(fill: Fill): void {
    this.callbackHandlers.onFill?.(fill);
  }

  private notifyRiskUpdate(): void {
    this.callbackHandlers.onRiskUpdate?.(this.getRiskMetrics());
  }

  private generateStrikeGrid(base: number): number[] {
    const strikes: number[] = [];
    const m = [0.8, 0.85, 0.9, 0.95, 1.0, 1.05, 1.1, 1.15, 1.2];
    for (const x of m) strikes.push(Math.round(base * x));
    return strikes;
  }

  /** Pretty-printer */
  formatQuoteTable(strikes: number[], expiryMs: number): string {
    const quotes = this.getQuoteGrid(strikes, expiryMs);
    let table = "Strike | Bid    | Ask    | Mid    | Edge   | Size\n";
    table += "--------------------------------------------------\n";
    for (const q of quotes) {
      table += `${q.strike.toString().padStart(6)} | `;
      table += `${q.bid.toFixed(2).padStart(6)} | `;
      table += `${q.ask.toFixed(2).padStart(6)} | `;
      table += `${q.mid.toFixed(2).padStart(6)} | `;
      table += `${q.edge.toFixed(2).padStart(6)} | `;
      table += `${q.bidSize}/${q.askSize}\n`;
    }
    return table;
  }
}

/** Example WebSocket integration */
export class WebSocketQuoteEngine {
  private adapter: QuoteEngineAdapter;
  private ws: any; // Your WebSocket implementation

  constructor(symbol: string, forward: number) {
    this.adapter = new QuoteEngineAdapter(symbol, forward);
    this.adapter.on("quote", (quotes) => this.broadcastQuotes(quotes));
    this.adapter.on("fill", (fill) => this.broadcastFill(fill));
    this.adapter.on("risk", (risk) => this.broadcastRisk(risk));
  }

  handleMessage(message: any): void {
    switch (message.type) {
      case "QUOTE_REQUEST": {
        // Expect: { strike, expiryMs, optionType, size, side }
        const quote = this.adapter.getQuote({
          symbol: (this.adapter as any)["symbol"],
          strike: message.strike,
          expiryMs: message.expiryMs,
          optionType: message.optionType ?? "C",
          side: message.side ?? "BOTH",
          size: message.size ?? 100,
          clientId: message.clientId,
          marketIV: message.marketIV,
        });
        this.sendQuote(message.clientId, quote);
        break;
      }
      case "TRADE": {
        // Expect: { strike, expiryMs, optionType, side, size, price? }
        const fill = this.adapter.executeTrade(
          message.strike,
          message.expiryMs,
          message.side,
          message.size,
          message.price,
          message.optionType ?? "C",
          message.clientId
        );
        break;
      }
      case "FORWARD_UPDATE": {
        this.adapter.updateForward(message.forward);
        break;
      }
    }
  }

  private broadcastQuotes(quotes: Quote[]): void {
    this.ws?.broadcast({ type: "QUOTES", data: quotes });
  }
  private broadcastFill(fill: Fill): void {
    this.ws?.broadcast({ type: "FILL", data: fill });
  }
  private broadcastRisk(risk: RiskMetrics): void {
    this.ws?.broadcast({ type: "RISK_UPDATE", data: risk });
  }
  private sendQuote(clientId: string, quote: Quote): void {
    this.ws?.send(clientId, { type: "QUOTE_RESPONSE", data: quote });
  }
}

---------- END apps/server/src/volModels/quoteEngineAdapter.ts ----------

---------- BEGIN apps/server/src/volModels/runTests.ts (bytes=219) ----------
/**
 * Simple test runner
 * Run with: npx ts-node apps/server/src/volModels/runTests.ts
 */

import { runAllTests } from './tests/testDualSurface';

console.log('Starting Dual Surface Model Tests...\n');
runAllTests();
---------- END apps/server/src/volModels/runTests.ts ----------

---------- BEGIN apps/server/src/volModels/simpleAdapter.ts (bytes=3031) ----------
/**
 * Simple Adapter for IntegratedSmileModel
 * Directly matches the actual model interface
 */

import { IntegratedSmileModel, TradeExecution } from './integratedSmileModel';
import { TraderMetrics } from './dualSurfaceModel';

export class SimpleAdapter {
  private model: IntegratedSmileModel;
  private spot: number;
  private expiry: number = 0.08; // 30 days

  constructor(spot: number) {
    this.spot = spot;
    this.model = new IntegratedSmileModel('BTC');
    
    // Initialize CC (Core Curve)
    const initialMetrics: TraderMetrics = {
      L0: 0.04,    // 20% vol
      S0: 0.001,
      C0: 0.5,
      S_neg: -0.8,
      S_pos: 0.9
    };
    
    this.model.updateCC(this.expiry, initialMetrics);
  }

  getQuote(strike: number, expiry: number = this.expiry) {
    return this.model.getQuote(expiry, strike, this.spot);
  }

  executeTrade(
    strike: number, 
    expiry: number = this.expiry,
    side: 'BUY' | 'SELL',
    size: number,
    price?: number
  ) {
    // Get quote if no price
    if (!price) {
      const quote = this.getQuote(strike, expiry);
      price = side === 'BUY' ? quote.ask : quote.bid;
    }

    // Create trade execution object
    const trade: TradeExecution = {
      expiry,
      strike,
      price,
      size: side === 'SELL' ? -size : size,  // Negative for sells
      spot: this.spot,
      time: Date.now()
    };
    
    // Execute via onTrade
    this.model.onTrade(trade);
    
    return trade;
  }

  getInventory() {
    return this.model.getInventorySummary();
  }

  formatQuotes(strikes: number[], expiry: number = this.expiry) {
    console.log('\nStrike | Bid    | Ask    | Edge  | Size');
    console.log('------------------------------------------');
    
    for (const strike of strikes) {
      const q = this.getQuote(strike, expiry);
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${q.bid.toFixed(2).padStart(6)} | ` +
        `${q.ask.toFixed(2).padStart(6)} | ` +
        `${q.edge.toFixed(2).padStart(5)} | ` +
        `${q.bidSize}/${q.askSize}`
      );
    }
  }
}

// Test it
function testAdapter() {
  console.log('\n' + '='.repeat(60));
  console.log('SIMPLE ADAPTER TEST');
  console.log('='.repeat(60));

  const adapter = new SimpleAdapter(100);
  const strikes = [90, 95, 100, 105, 110];

  // Initial quotes
  console.log('\nInitial quotes:');
  adapter.formatQuotes(strikes);

  // Execute some trades
  console.log('\n' + '-'.repeat(60));
  console.log('Executing trades...');
  
  const fill1 = adapter.executeTrade(95, 0.08, 'SELL', 100);
  console.log(`Fill: SELL 100x95 @ ${fill1.price.toFixed(2)}`);
  
  const fill2 = adapter.executeTrade(100, 0.08, 'SELL', 50);
  console.log(`Fill: SELL 50x100 @ ${fill2.price.toFixed(2)}`);

  // Updated quotes
  console.log('\nQuotes after trades:');
  adapter.formatQuotes(strikes);

  // Show inventory
  const inv = adapter.getInventory();
  console.log(`\nTotal Vega: ${inv.totalVega.toFixed(1)}`);

  console.log('\n' + '='.repeat(60));
}

testAdapter();
---------- END apps/server/src/volModels/simpleAdapter.ts ----------

---------- BEGIN apps/server/src/volModels/simpleDiagnostic.ts (bytes=2606) ----------
/**
 * Simple diagnostic to show the asymmetry problem
 */

import { SmileInventoryController } from './smileInventoryController';
import { ModelConfig, getDefaultConfig } from './config/modelConfig';

function testSymmetry() {
  console.log('\n' + '='.repeat(60));
  console.log('EDGE CALCULATION SYMMETRY TEST');
  console.log('='.repeat(60));
  
  const config = getDefaultConfig('BTC');
  const controller = new SmileInventoryController(config);
  
  // Test various inventory levels
  const testLevels = [
    { vega: -30, label: 'Very Short' },
    { vega: -10, label: 'Short' },
    { vega: 0, label: 'Flat' },
    { vega: 10, label: 'Long' },
    { vega: 30, label: 'Very Long' }
  ];
  
  console.log('\nTesting smile adjustments for different positions:');
  console.log('Position  | Vega  | ΔL0     | ΔS0     ');
  console.log('-'.repeat(45));
  
  for (const test of testLevels) {
    // Clear and set new inventory
    controller.clearInventory();
    
    if (test.vega !== 0) {
      // Simulate ATM position
      controller.updateInventory(100, test.vega > 0 ? 100 : -100, Math.abs(test.vega) / 100, 'atm');
    }
    
    const adjustments = controller.calculateSmileAdjustments();
    
    console.log(
      `${test.label.padEnd(10)} | ${test.vega.toString().padStart(4)} | ` +
      `${(adjustments.deltaL0 * 100).toFixed(3).padStart(7)}% | ` +
      `${(adjustments.deltaS0 * 100).toFixed(3).padStart(7)}%`
    );
  }
  
  console.log('\n' + '-'.repeat(45));
  console.log('\n⚠️  ASYMMETRY CHECK:');
  
  // Find the specific issue
  controller.clearInventory();
  controller.updateInventory(100, -100, 10, 'atm');  // Short 10 vega
  const shortAdj = controller.calculateSmileAdjustments();
  
  controller.clearInventory();
  controller.updateInventory(100, 100, 10, 'atm');   // Long 10 vega
  const longAdj = controller.calculateSmileAdjustments();
  
  console.log(`\nWith 10 vega ATM position:`);
  console.log(`  SHORT: ΔL0 = ${(shortAdj.deltaL0 * 100).toFixed(3)}%`);
  console.log(`  LONG:  ΔL0 = ${(longAdj.deltaL0 * 100).toFixed(3)}%`);
  
  if (Math.abs(shortAdj.deltaL0) === Math.abs(longAdj.deltaL0) && longAdj.deltaL0 <= 0) {
    console.log(`\n✅ SYMMETRIC: Long and short create equal but opposite adjustments`);
  } else if (longAdj.deltaL0 === 0) {
    console.log(`\n❌ ASYMMETRIC: Long positions don't reduce vols!`);
    console.log(`   This is the bug - Math.abs() or Math.max() preventing negative adjustments`);
  } else {
    console.log(`\n⚠️  PARTIAL: Some asymmetry detected`);
  }
  
  console.log('\n' + '='.repeat(60));
}

testSymmetry();
---------- END apps/server/src/volModels/simpleDiagnostic.ts ----------

---------- BEGIN apps/server/src/volModels/simpleMultiTrade.ts (bytes=3761) ----------
/**
 * Simple multi-trade test that works
 */

import { IntegratedSmileModel, TradeExecution } from './integratedSmileModel';
import { TraderMetrics } from './dualSurfaceModel';

function runSimpleMultiTrade() {
  console.log('\n' + '='.repeat(70));
  console.log('MULTI-TRADE SCENARIO');
  console.log('='.repeat(70) + '\n');
  
  const model = new IntegratedSmileModel('BTC');
  const expiry = 0.25; // 3 months
  const spot = 100;
  
  // Initialize
  const initialMetrics: TraderMetrics = {
    L0: 0.04,
    S0: -0.002,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, initialMetrics);
  console.log('Market initialized\n');
  
  // Helper to show quotes
  const showQuotes = (title: string) => {
    console.log('\n' + title);
    console.log('-'.repeat(50));
    console.log('Strike | Bid    | Ask    | Edge  | Size');
    console.log('-'.repeat(50));
    
    const strikes = [90, 95, 100, 105, 110];
    for (const strike of strikes) {
      const quote = model.getQuote(expiry, strike, spot);
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${quote.bid.toFixed(2).padStart(6)} | ` +
        `${quote.ask.toFixed(2).padStart(6)} | ` +
        `${quote.edge.toFixed(2).padStart(5)} | ` +
        `${quote.bidSize}/${quote.askSize}`
      );
    }
    
    const summary = model.getInventorySummary();
    console.log(`\nTotal Vega: ${summary.totalVega.toFixed(1)}`);
  };
  
  // Initial state
  showQuotes('INITIAL - No inventory');
  
  // Trade 1: Sell 200x 95 puts
  console.log('\n' + '='.repeat(50));
  console.log('TRADE 1: Sell 200x 95 puts');
  
  model.onTrade({
    expiry,
    strike: 95,
    price: 5.34,
    size: -200,
    spot,
    time: Date.now()
  });
  
  showQuotes('After Trade 1');
  
  // Trade 2: Sell 100x ATM
  console.log('\n' + '='.repeat(50));
  console.log('TRADE 2: Sell 100x ATM (100 strike)');
  
  model.onTrade({
    expiry,
    strike: 100,
    price: 7.97,
    size: -100,
    spot,
    time: Date.now() + 1000
  });
  
  showQuotes('After Trade 2');
  
  // Trade 3: Buy 150x 90 puts (hedge)
  console.log('\n' + '='.repeat(50));
  console.log('TRADE 3: Buy 150x 90 puts (hedge)');
  
  model.onTrade({
    expiry,
    strike: 90,
    price: 3.39,
    size: 150,
    spot,
    time: Date.now() + 2000
  });
  
  showQuotes('After Trade 3');
  
  // Trade 4: Sell 100x 110 calls
  console.log('\n' + '='.repeat(50));
  console.log('TRADE 4: Sell 100x 110 calls');
  
  model.onTrade({
    expiry,
    strike: 110,
    price: 14.92,
    size: -100,
    spot,
    time: Date.now() + 3000
  });
  
  showQuotes('After Trade 4');
  
  // Trade 5: Buy back 100x 95 puts
  console.log('\n' + '='.repeat(50));
  console.log('TRADE 5: Buy back 100x 95 puts');
  
  model.onTrade({
    expiry,
    strike: 95,
    price: 5.40,
    size: 100,
    spot,
    time: Date.now() + 4000
  });
  
  showQuotes('After Trade 5 - Final position');
  
  // Summary
  console.log('\n' + '='.repeat(70));
  console.log('SUMMARY');
  console.log('='.repeat(70));
  
  const finalSummary = model.getInventorySummary();
  console.log('\nFinal inventory by bucket:');
  for (const [bucket, data] of Object.entries(finalSummary.byBucket)) {
    if ((data as any).vega !== 0) {
      console.log(`  ${bucket}: ${(data as any).vega.toFixed(1)} vega`);
    }
  }
  
  const adj = finalSummary.smileAdjustments;
  console.log('\nSmile adjustments:');
  console.log(`  Level:  ${(adj.deltaL0 * 100).toFixed(3)}%`);
  console.log(`  Skew:   ${(adj.deltaS0 * 100).toFixed(3)}%`);
  console.log(`  L-wing: ${(adj.deltaSNeg * 100).toFixed(3)}%`);
  console.log(`  R-wing: ${(adj.deltaSPos * 100).toFixed(3)}%`);
  
  console.log('\n' + '='.repeat(70) + '\n');
}

// Run it
runSimpleMultiTrade();
---------- END apps/server/src/volModels/simpleMultiTrade.ts ----------

---------- BEGIN apps/server/src/volModels/smileAdjuster.ts (bytes=7149) ----------
/**
 * Smile-aware inventory adjustments
 * Adjusts the entire smile shape based on inventory, not just local bumps
 */

import { SVIParams, SVI } from './dualSurfaceModel';
import { ModelConfig, getDefaultConfig } from './config/modelConfig';
import type { TraderMetrics } from './dualSurfaceModel';

export interface InventoryImpact {
  deltaL0: number;   // ATM level adjustment
  deltaS0: number;   // Skew adjustment  
  deltaC0: number;   // Curvature adjustment
  deltaSNeg: number; // Left wing adjustment
  deltaSPos: number; // Right wing adjustment
}

export class SmileAdjuster {
  /**
   * Calculate how inventory should adjust the smile
   * Based on market microstructure effects
   */
  static calculateSmileImpact(
    inventory: Map<string, { vega: number; count: number }>,
    config: ModelConfig
  ): InventoryImpact {
    let deltaL0 = 0;
    let deltaS0 = 0;
    let deltaC0 = 0;
    let deltaSNeg = 0;
    let deltaSPos = 0;
    
    // Process each bucket's contribution
    for (const [bucket, inv] of inventory) {
      if (Math.abs(inv.vega) < 0.1) continue;
      
      // Get edge requirement for this bucket
      const bucketConfig = config.buckets.find((b: any) => b.name === bucket);
      if (!bucketConfig) continue;
      
      const { E0, kappa, gamma, Vref } = bucketConfig.edgeParams;
      const normalized = Math.abs(inv.vega) / Vref;
      const edgeTicks = -Math.sign(inv.vega) * (E0 + kappa * Math.pow(normalized, gamma));
      
      // Convert edge to vol adjustments based on bucket
      // These are calibrated impacts - would be fitted to real market behavior
      
      switch (bucket) {
        case 'atm':
          deltaL0 += edgeTicks * 0.001;
          deltaC0 += Math.sign(inv.vega) * edgeTicks * 0.0002;
          break;
          
        case 'rr25':
          if (inv.vega < 0) {
            deltaS0 += edgeTicks * 0.0003;
            deltaSNeg += -edgeTicks * 0.0002;
            deltaL0 += edgeTicks * 0.0002;
          } else {
            deltaS0 -= edgeTicks * 0.0003;
            deltaSNeg -= -edgeTicks * 0.0002;
            deltaL0 -= edgeTicks * 0.0002;
          }
          
          if (inv.vega < 0 && bucket.includes('call')) {
            deltaSPos += -edgeTicks * 0.0002;
          }
          break;
          
        case 'rr10':
          if (inv.vega < 0) {
            deltaSNeg += -edgeTicks * 0.0003;
            deltaS0 += edgeTicks * 0.0002;
          } else {
            deltaSNeg -= -edgeTicks * 0.0003;
            deltaS0 -= edgeTicks * 0.0002;
          }
          break;
          
        case 'wings':
          if (inv.vega < 0) {
            deltaSNeg += -edgeTicks * 0.0004;
            deltaS0 += edgeTicks * 0.0001;
          }
          break;
      }
    }
    
    return {
      deltaL0,
      deltaS0,
      deltaC0,
      deltaSNeg,
      deltaSPos
    };
  }
  
  /**
   * Apply smile adjustments to SVI parameters
   */
  static adjustSVIForInventory(
    baseCC: SVIParams,
    inventory: Map<string, { vega: number; count: number }>,
    config: ModelConfig
  ): SVIParams {
    const baseMetrics = SVI.toMetrics(baseCC);
    const impact = this.calculateSmileImpact(inventory, config);
    
    const adjustedMetrics: TraderMetrics = {
      L0: baseMetrics.L0 + impact.deltaL0,
      S0: baseMetrics.S0 + impact.deltaS0,
      C0: baseMetrics.C0 + impact.deltaC0,
      S_neg: baseMetrics.S_neg + impact.deltaSNeg,
      S_pos: baseMetrics.S_pos + impact.deltaSPos
    };
    
    const sviConfig = {
      bMin: config.svi.bMin,
      sigmaMin: config.svi.sigmaMin,
      rhoMax: config.svi.rhoMax,
      sMax: config.svi.slopeMax,
      c0Min: config.svi.c0Min,
      buckets: [],
      edgeParams: new Map(),
      rbfWidth: 0,
      ridgeLambda: 0,
      maxL0Move: 0,
      maxS0Move: 0,
      maxC0Move: 0
    };
    
    const adjustedSVI = SVI.fromMetrics(adjustedMetrics, sviConfig);
    
    if (SVI.validate(adjustedSVI, sviConfig)) {
      return adjustedSVI;
    } else {
      console.warn('Adjusted SVI failed validation, returning base');
      return baseCC;
    }
  }
  
  /**
   * Visualize the smile adjustment
   */
  static compareSmiles(
    baseCC: SVIParams,
    adjustedPC: SVIParams,
    spot: number,
    T: number
  ): void {
    console.log('\nSmile Comparison (CC vs PC with inventory adjustment):');
    console.log('Strike | Delta | CC Vol | PC Vol | Diff');
    console.log('-'.repeat(50));
    
    const strikes = [
      spot * 0.80,
      spot * 0.90,
      spot * 0.95,
      spot * 1.00,
      spot * 1.05,
      spot * 1.10,
      spot * 1.20
    ];
    
    for (const strike of strikes) {
      const k = Math.log(strike / spot);
      
      const ccVar = SVI.w(baseCC, k);
      const pcVar = SVI.w(adjustedPC, k);
      
      const ccVol = Math.sqrt(ccVar / T) * 100;
      const pcVol = Math.sqrt(pcVar / T) * 100;
      const diff = pcVol - ccVol;
      
      const delta = 50 * Math.exp(-2 * k * k);
      
      console.log(
        `${strike.toFixed(0).padStart(6)} | ` +
        `${delta.toFixed(0).padStart(5)} | ` +
        `${ccVol.toFixed(1).padStart(6)} | ` +
        `${pcVol.toFixed(1).padStart(6)} | ` +
        `${diff > 0 ? '+' : ''}${diff.toFixed(2)}`
      );
    }
  }
}

function testSmileAdjuster() {
  const config = getDefaultConfig();
  
  const baseMetrics: TraderMetrics = {
    L0: 0.04,
    S0: -0.001,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  const sviConfig = {
    bMin: config.svi.bMin,
    sigmaMin: config.svi.sigmaMin,
    rhoMax: config.svi.rhoMax,
    sMax: config.svi.slopeMax,
    c0Min: config.svi.c0Min,
    buckets: [],
    edgeParams: new Map(),
    rbfWidth: 0,
    ridgeLambda: 0,
    maxL0Move: 0,
    maxS0Move: 0,
    maxC0Move: 0
  };
  
  const baseCC = SVI.fromMetrics(baseMetrics, sviConfig);
  
  const inventory = new Map<string, { vega: number; count: number }>();
  inventory.set('rr25', { vega: -100, count: 1 });
  
  console.log('Inventory: SHORT 100 vega in 25-delta puts\n');
  
  const impact = SmileAdjuster.calculateSmileImpact(inventory, config);
  
  console.log('Expected smile adjustments:');
  console.log(`  ΔL0 (ATM level):    ${(impact.deltaL0 * 100).toFixed(2)}% vol`);
  console.log(`  ΔS0 (Skew):         ${(impact.deltaS0 * 100).toFixed(3)}% vol/unit`);
  console.log(`  ΔC0 (Curvature):    ${impact.deltaC0.toFixed(4)}`);
  console.log(`  ΔS_neg (Left wing): ${(impact.deltaSNeg * 100).toFixed(3)}% vol/unit`);
  console.log(`  ΔS_pos (Right wing):${(impact.deltaSPos * 100).toFixed(3)}% vol/unit`);
  
  const adjustedPC = SmileAdjuster.adjustSVIForInventory(baseCC, inventory, config);
  
  SmileAdjuster.compareSmiles(baseCC, adjustedPC, 100, 0.25);
  
  console.log('\nInterpretation:');
  console.log('  • Skew increased (puts more expensive relative to calls)');
  console.log('  • Left wing lowered (far OTM puts cheaper)');
  console.log('  • Small ATM lift (general vol increase)');
  console.log('  • This matches real market behavior when dealers are short puts');
  
  console.log('\n' + '='.repeat(60));
}

if (require.main === module) {
  testSmileAdjuster();
}

---------- END apps/server/src/volModels/smileAdjuster.ts ----------

---------- BEGIN apps/server/src/volModels/smileInventoryController.ts (bytes=5833) ----------
/**
 * Smile-based Inventory Controller
 * Expects **DEALER-signed** size in updateInventory(size).
 * We accumulate bucket vega as: inv.vega += size * option_vega.
 */
import { SVIParams, SVI, TraderMetrics } from './dualSurfaceModel';
import { ModelConfig } from './config/modelConfig';

export interface SmileAdjustments {
  deltaL0: number;
  deltaS0: number;
  deltaC0: number;
  deltaSNeg: number;
  deltaSPos: number;
}

export interface InventoryBucket {
  vega: number;
  count: number;
  strikes: number[];
  edgeRequired?: number;
}

export class SmileInventoryController {
  private inventory: Map<string, InventoryBucket>;
  private config: ModelConfig;

  constructor(config: ModelConfig) {
    this.config = config;
    this.inventory = new Map();
  }

  /** Update inventory after trade — expects DEALER-signed size */
  updateInventory(strike: number, size: number, vega: number, bucket: string): void {
    const s = Number(size) || 0;
    const v = Number(vega) || 0;

    let bucketInv = this.inventory.get(bucket);
    if (!bucketInv) {
      bucketInv = { vega: 0, count: 0, strikes: [], edgeRequired: 0 };
      this.inventory.set(bucket, bucketInv);
    }

    const deltaV = s * v;
    bucketInv.vega = (Number(bucketInv.vega) || 0) + deltaV;
    bucketInv.count = (Number(bucketInv.count) || 0) + 1;
    if (!bucketInv.strikes.includes(strike)) bucketInv.strikes.push(strike);

    // 🔎 Debug
    console.log(`[SIC.updateInv] bucket=${bucket} strike=${strike} size(dealer)=${s} vega=${v} Δvega=${deltaV} agg=${bucketInv.vega}`);
  }

  /** Map inventory to smile parameter adjustments */
  calculateSmileAdjustments(): SmileAdjustments {
    let deltaL0 = 0, deltaS0 = 0, deltaC0 = 0, deltaSNeg = 0, deltaSPos = 0;

    for (const [bucket, inv] of this.inventory) {
      const bucketVega = Number(inv.vega) || 0;
      if (Math.abs(bucketVega) < 1e-9) continue;

      const cfg = this.config.buckets.find(b => b.name === bucket);
      if (!cfg) continue;

      const E0    = Number(cfg.edgeParams?.E0)    || 0;
      const kappa = Number(cfg.edgeParams?.kappa) || 0;
      const gamma = Number(cfg.edgeParams?.gamma) || 1;
      const Vref  = Math.max(Number(cfg.edgeParams?.Vref) || 1, 1e-6);

      const normalized = Math.abs(bucketVega) / Vref;
      // Negative for SHORT (bucketVega < 0) -> wants higher prices
      const edgeRequired = -Math.sign(bucketVega) * (E0 + kappa * Math.pow(normalized, gamma));
      inv.edgeRequired = edgeRequired;

      const TICK_TO_VOL = 0.005;
      switch (bucket) {
        case 'atm':
          deltaL0 += edgeRequired * TICK_TO_VOL * 1.0;
          deltaC0 += Math.sign(bucketVega) * Math.abs(edgeRequired) * 0.0001;
          break;
        case 'rr25':
          if (bucketVega < 0) {
            deltaS0   += Math.abs(edgeRequired) * TICK_TO_VOL * 0.3;
            deltaSNeg += -Math.abs(edgeRequired) * TICK_TO_VOL * 0.2;
            deltaL0   += Math.abs(edgeRequired) * TICK_TO_VOL * 0.2;
          } else {
            deltaS0   -= Math.abs(edgeRequired) * TICK_TO_VOL * 0.3;
            deltaSNeg -= -Math.abs(edgeRequired) * TICK_TO_VOL * 0.2;
            deltaL0   -= Math.abs(edgeRequired) * TICK_TO_VOL * 0.2;
          }
          break;
        case 'rr10':
          if (bucketVega < 0) {
            deltaSNeg += -Math.abs(edgeRequired) * TICK_TO_VOL * 0.3;
            deltaS0   += Math.abs(edgeRequired) * TICK_TO_VOL * 0.15;
          } else {
            deltaSNeg -= -Math.abs(edgeRequired) * TICK_TO_VOL * 0.3;
            deltaS0   -= Math.abs(edgeRequired) * TICK_TO_VOL * 0.15;
          }
          break;
        case 'wings':
          deltaL0   += edgeRequired * TICK_TO_VOL * 0.1;
          deltaSNeg += -edgeRequired * TICK_TO_VOL * 0.4;
          deltaS0   += edgeRequired * TICK_TO_VOL * 0.1;
          break;
      }
    }

    return { deltaL0, deltaS0, deltaC0, deltaSNeg, deltaSPos };
  }

  /** Create PC from CC with backoff */
  adjustSVIForInventory(ccParams: SVIParams): SVIParams {
    const base = SVI.toMetrics(ccParams);
    const adj = this.calculateSmileAdjustments();

    const make = (scale: number) => {
      const m: TraderMetrics = {
        L0: Math.max(0.001, base.L0 + adj.deltaL0 * scale),
        S0: base.S0 + adj.deltaS0 * scale,
        C0: Math.max(0.1, base.C0 + adj.deltaC0 * scale),
        S_neg: base.S_neg + adj.deltaSNeg * scale,
        S_pos: base.S_pos + adj.deltaSPos * scale,
      };
      return SVI.fromMetrics(m, this.createSVIConfig());
    };

    let pc = make(1.0);
    if (!SVI.validate(pc, this.createSVIConfig())) {
      let s = 0.5;
      while (s > 1e-3) {
        pc = make(s);
        if (SVI.validate(pc, this.createSVIConfig())) break;
        s *= 0.5;
      }
      if (!SVI.validate(pc, this.createSVIConfig())) {
        console.warn('Adjusted SVI invalid; using CC.');
        return ccParams;
      }
    }
    return pc;
  }

  createSVIConfig(): any {
    return {
      bMin: this.config.svi.bMin,
      sigmaMin: this.config.svi.sigmaMin,
      rhoMax: this.config.svi.rhoMax,
      sMax: this.config.svi.slopeMax,
      c0Min: this.config.svi.c0Min,
      buckets: [],
      edgeParams: new Map(),
      rbfWidth: 0,
      ridgeLambda: 0,
      maxL0Move: 0,
      maxS0Move: 0,
      maxC0Move: 0
    };
  }

  getInventoryState(): Map<string, InventoryBucket> {
    return new Map(this.inventory);
  }

  getInventory() {
    const total = { vega: 0, gamma: 0, theta: 0 };
    const byBucket: any = {};
    for (const [bucket, inv] of this.inventory) {
      const v = Number(inv.vega) || 0;
      total.vega += v;
      byBucket[bucket] = { vega: v, count: inv.count };
    }
    return { total, totalVega: total.vega, byBucket, smileAdjustments: this.calculateSmileAdjustments() };
  }

  clearInventory(): void { this.inventory.clear(); }
}

---------- END apps/server/src/volModels/smileInventoryController.ts ----------

---------- BEGIN apps/server/src/volModels/sviMapping.ts (bytes=1237) ----------
// apps/server/src/volModels/sviMapping.ts
// Dual-compatible module exports (CJS + ESM)

export type SVIParams = { a: number; b: number; rho: number; m: number; sigma: number };
export type TraderMetrics = { S0: number; C0: number; L0: number; S_pos: number; S_neg: number };
export type Config = Record<string, any>;

// Example implementation placeholders
export function toMetrics(svi: SVIParams): TraderMetrics {
  const S0 = svi.b * svi.rho;
  const b = svi.b;
  const S_pos = b * (1 + svi.rho);
  const S_neg = b * (1 - svi.rho);
  return { S0, C0: 0.5, L0: 0.5, S_pos, S_neg };
}

export function fromMetrics(m: TraderMetrics, cfg: Config): SVIParams {
  const b = 0.5 * (m.S_pos + m.S_neg);
  const rho = (m.S_pos - m.S_neg) / Math.max(b * 2, 1e-12);
  return { a: 0.1, b, rho, m: 0, sigma: 0.2 };
}

export function s0FromWings(m: TraderMetrics): number {
  const sum = m.S_pos + m.S_neg;
  const b = 0.5 * sum;
  const rho = (m.S_pos - m.S_neg) / Math.max(Math.abs(sum), 1e-12);
  return b * rho;
}

// Back-compat grouped export
export const SVI = { toMetrics, fromMetrics };

// Default export for interop between ESM and CJS
const defaultExport = { SVI, toMetrics, fromMetrics, s0FromWings };
export default defaultExport;

---------- END apps/server/src/volModels/sviMapping.ts ----------

---------- BEGIN apps/server/src/volModels/testInventory.ts (bytes=5138) ----------
/**
 * Standalone test for the inventory controller
 * Shows how inventory drives PC adjustments
 */

import { InventoryController, EdgeLadder, BumpSolver } from './controllers/inventoryController';
import { getDefaultConfig } from './config/modelConfig';
import { SVIParams } from './dualSurfaceModel';

function runInventoryTest() {
  console.log('\n' + '='.repeat(50));
  console.log('INVENTORY CONTROLLER TEST');
  console.log('='.repeat(50) + '\n');
  
  const config = getDefaultConfig('BTC');
  const controller = new InventoryController(config);
  
  // ===== Test 1: Edge Ladder =====
  console.log('Test 1: Edge Ladder (how edge scales with inventory)\n');
  console.log('For 25-delta bucket:');
  
  const positions = [-200, -100, -50, 0, 50, 100, 200];
  for (const pos of positions) {
    const edge = EdgeLadder.calculateEdge(pos, config, 'rr25');
    const direction = edge > 0 ? '↑ PC > CC' : edge < 0 ? '↓ PC < CC' : '= PC = CC';
    console.log(`  Position: ${pos.toString().padStart(4)} vega → Edge: ${edge.toFixed(2).padStart(6)} ticks ${direction}`);
  }
  
  // ===== Test 2: Trade Simulation =====
  console.log('\n' + '-'.repeat(50));
  console.log('\nTest 2: Trade Simulation\n');
  
  // Initial state
  console.log('Initial: No position, PC = CC\n');
  
  // Trade 1: Sell 100 lots
  const strike1 = 95;
  const vega1 = 0.5;
  controller.updateInventory(strike1, -100, vega1, 'rr25');
  
  let edge = controller.getCurrentEdge('rr25');
  let inventory = controller.getInventoryState();
  
  console.log('After SELLING 100 lots of 25-delta put:');
  console.log(`  Strike: ${strike1}`);
  console.log(`  Position: -100 lots (SHORT)`);
  console.log(`  Vega inventory: ${inventory.byBucket.get('rr25')?.signedVega.toFixed(1)}`);
  console.log(`  Required edge: ${edge.toFixed(2)} ticks`);
  console.log(`  → PC moves ${Math.abs(edge).toFixed(2)} ticks ${edge > 0 ? 'ABOVE' : 'BELOW'} CC`);
  console.log(`  → Quotes become ${edge > 0 ? 'HIGHER' : 'LOWER'} to ${edge > 0 ? 'discourage more selling' : 'encourage buying'}\n`);
  
  // Trade 2: Sell more
  controller.updateInventory(strike1, -100, vega1, 'rr25');
  
  edge = controller.getCurrentEdge('rr25');
  inventory = controller.getInventoryState();
  
  console.log('After SELLING another 100 lots:');
  console.log(`  Total position: -200 lots`);
  console.log(`  Vega inventory: ${inventory.byBucket.get('rr25')?.signedVega.toFixed(1)}`);
  console.log(`  Required edge: ${edge.toFixed(2)} ticks`);
  console.log(`  → Edge requirement increased due to larger position\n`);
  
  // Trade 3: Buy some back
  controller.updateInventory(strike1, 50, vega1, 'rr25');
  
  edge = controller.getCurrentEdge('rr25');
  inventory = controller.getInventoryState();
  
  console.log('After BUYING back 50 lots:');
  console.log(`  Total position: -150 lots`);
  console.log(`  Vega inventory: ${inventory.byBucket.get('rr25')?.signedVega.toFixed(1)}`);
  console.log(`  Required edge: ${edge.toFixed(2)} ticks`);
  console.log(`  → Edge requirement reduced\n`);
  
  // ===== Test 3: Bump Generation =====
  console.log('-'.repeat(50));
  console.log('\nTest 3: Variance Bump Generation\n');
  
  // Create a sample CC surface
  const cc: SVIParams = {
    a: 0.03,
    b: 0.5,
    rho: -0.2,
    sigma: 0.2,
    m: 0
  };
  
  const T = 0.25;  // 3 months
  const spot = 100;
  
  // Generate bumps for current inventory
  const bumps = controller.generateBumps('rr25', cc, T, spot, [95, 96, 97]);
  
  console.log(`Generated ${bumps.length} bump(s) for 25-delta bucket:`);
  for (const bump of bumps) {
    const strike = Math.round(spot * Math.exp(bump.k));
    console.log(`  Strike ~${strike}: amplitude=${bump.alpha.toFixed(4)}, width=${bump.lam.toFixed(3)}`);
  }
  
  // ===== Test 4: Different Buckets =====
  console.log('\n' + '-'.repeat(50));
  console.log('\nTest 4: Edge Requirements by Bucket\n');
  
  const testVega = -100;  // Short 100 vega
  const buckets = ['wings', 'rr10', 'rr25', 'atm'];
  
  console.log(`For ${testVega} vega position:`);
  for (const bucket of buckets) {
    const e = EdgeLadder.calculateEdge(testVega, config, bucket);
    console.log(`  ${bucket.padEnd(6)}: ${e.toFixed(2).padStart(6)} ticks required`);
  }
  console.log('\nNote: ATM requires more edge than wings (higher risk)\n');
  
  // ===== Test 5: Rebasing =====
  console.log('-'.repeat(50));
  console.log('\nTest 5: Rebasing (when CC moves)\n');
  
  console.log('Scenario: CC moves but we want to preserve edge\n');
  
  // New CC with higher vol
  const newCC: SVIParams = {
    a: 0.04,  // Higher ATM vol
    b: 0.5,
    rho: -0.2,
    sigma: 0.2,
    m: 0
  };
  
  const oldBumps = controller.generateBumps('rr25', cc, T, spot, [95]);
  const newBumps = controller.rebaseBumps(cc, newCC, oldBumps, T, spot);
  
  console.log('Original bumps:', oldBumps.length);
  console.log('Rebased bumps:', newBumps.length);
  console.log('\n→ Bumps adjusted to maintain same cash edge with new CC');
  
  console.log('\n' + '='.repeat(50));
  console.log('TEST COMPLETE');
  console.log('='.repeat(50) + '\n');
}

// Run the test
runInventoryTest();
---------- END apps/server/src/volModels/testInventory.ts ----------

---------- BEGIN apps/server/src/volModels/testQuoteAdapter.ts (bytes=1761) ----------
/**
 * Test the Quote Engine Adapter
 */

import { QuoteEngineAdapter, Fill, RiskMetrics } from './quoteEngineAdapter';

console.log('\n' + '='.repeat(60));
console.log('QUOTE ENGINE ADAPTER TEST');
console.log('='.repeat(60));

const adapter = new QuoteEngineAdapter('BTC', 100);

// Register event handlers
adapter.on('fill', (fill: Fill) => {
  console.log(`\n✅ FILL: ${fill.side} ${fill.size}x ${fill.strike} @ ${fill.price.toFixed(2)}`);
});

adapter.on('risk', (risk: RiskMetrics) => {
  console.log(`\n📊 Risk Update:`);
  console.log(`  Total Vega: ${risk.totalVega.toFixed(1)}`);
  console.log(`  Smile Level Adj: ${(risk.smileAdjustments.level * 100).toFixed(3)}%`);
});

// Initial quote grid
console.log('\nInitial quotes:');
console.log(adapter.formatQuoteTable([90, 95, 100, 105, 110], 0.08));

// Simulate trades
console.log('\n' + '-'.repeat(60));
console.log('Executing trades...');

try {
  adapter.executeTrade(95, 0.08, 'SELL', 100);
  adapter.executeTrade(100, 0.08, 'SELL', 50);
  adapter.executeTrade(105, 0.08, 'BUY', 75);
} catch (error) {
  console.error('Error executing trades:', error);
}

// Show updated quotes
console.log('\nQuotes after trades:');
console.log(adapter.formatQuoteTable([90, 95, 100, 105, 110], 0.08));

// Show risk metrics
const risk = adapter.getRiskMetrics();
console.log('\nFinal Risk Metrics:');
console.log(`  Total Vega: ${risk.totalVega.toFixed(1)}`);
console.log(`  Total Gamma: ${risk.totalGamma.toFixed(1)}`);
console.log('\n  Bucket breakdown:');
risk.buckets.forEach((b: any) => {
  if (b.vega !== 0) {
    console.log(`    ${b.name}: ${b.vega.toFixed(1)} vega, edge: ${b.edge.toFixed(2)}`);
  }
});

console.log('\n' + '='.repeat(60));
console.log('TEST COMPLETE');
console.log('='.repeat(60));
---------- END apps/server/src/volModels/testQuoteAdapter.ts ----------

---------- BEGIN apps/server/src/volModels/testSmileSimple.ts (bytes=2435) ----------
/**
 * Simple test to show smile adjustment concept
 * No complex imports, just the core idea
 */

function testSmileAdjustment() {
    console.log('\n' + '='.repeat(60));
    console.log('SMILE ADJUSTMENT CONCEPT');
    console.log('='.repeat(60) + '\n');
    
    console.log('When you SELL 25-delta puts:\n');
    
    console.log('Current localized bump approach:');
    console.log('  • Only affects the 95 strike');
    console.log('  • Other strikes unchanged');
    console.log('  • Not realistic market behavior\n');
    
    console.log('Better smile-wide adjustment:');
    console.log('  • Increase skew (S0): Puts become more expensive vs calls');
    console.log('  • Lower left wing (S_neg): Far OTM puts get cheaper');  
    console.log('  • Small ATM lift (L0): General vol increase');
    console.log('  • Right wing unchanged (S_pos): Calls unaffected\n');
    
    console.log('Example impact on volatilities:');
    console.log('Strike | Before | After  | Change');
    console.log('-'.repeat(40));
    
    // Simulated vols showing the pattern
    const impacts = [
      { strike: 80, before: 22.0, after: 21.5, desc: 'Far OTM put' },
      { strike: 90, before: 20.0, after: 20.2, desc: '10d put' },
      { strike: 95, before: 19.0, after: 19.5, desc: '25d put' },
      { strike: 100, before: 18.0, after: 18.2, desc: 'ATM' },
      { strike: 105, before: 19.0, after: 19.1, desc: '25d call' },
      { strike: 110, before: 20.0, after: 20.0, desc: '10d call' },
      { strike: 120, before: 22.0, after: 22.0, desc: 'Far OTM call' }
    ];
    
    for (const { strike, before, after, desc } of impacts) {
      const change = after - before;
      const sign = change > 0 ? '+' : '';
      console.log(
        `${strike.toString().padStart(6)} | ` +
        `${before.toFixed(1).padStart(6)}% | ` +
        `${after.toFixed(1).padStart(6)}% | ` +
        `${sign}${change.toFixed(1).padStart(4)}%  ${desc}`
      );
    }
    
    console.log('\nKey observations:');
    console.log('  1. Put skew increases (95-105 spread wider)');
    console.log('  2. Far OTM puts decrease (you already supplied there)');
    console.log('  3. ATM gets small bump (general risk premium)');
    console.log('  4. Calls largely unchanged (asymmetric impact)');
    
    console.log('\nThis matches real dealer behavior!');
    console.log('='.repeat(60) + '\n');
  }
  
  // Run it
  testSmileAdjustment();
---------- END apps/server/src/volModels/testSmileSimple.ts ----------

---------- BEGIN apps/server/src/volModels/tests/bs.test.ts (bytes=1240) ----------
import { black76Greeks } from "../../risk";

describe("black76Greeks", () => {
  const F = 100_000;
  const T = 0.25; // 3 months
  const df = 1;

  test("finite outputs for reasonable inputs (call)", () => {
    const g = black76Greeks(F, F, T, 0.3, true, df);
    for (const [k, v] of Object.entries(g)) {
      expect(Number.isFinite(v as number)).toBe(true);
    }
  });

  test("finite outputs for reasonable inputs (put)", () => {
    const g = black76Greeks(F, F, T, 0.3, false, df);
    for (const [k, v] of Object.entries(g)) {
      expect(Number.isFinite(v as number)).toBe(true);
    }
  });

  test("call price increases with vol", () => {
    const p1 = black76Greeks(F, F, T, 0.1, true, df).price;
    const p2 = black76Greeks(F, F, T, 0.4, true, df).price;
    expect(p2).toBeGreaterThan(p1);
  });

  test("put price increases with vol", () => {
    const p1 = black76Greeks(F, F, T, 0.1, false, df).price;
    const p2 = black76Greeks(F, F, T, 0.4, false, df).price;
    expect(p2).toBeGreaterThan(p1);
  });

  test("deep OTM call ~ small", () => {
    const p = black76Greeks(F, F * 10, T, 0.3, true, df).price;
    expect(p).toBeGreaterThanOrEqual(0);
    expect(p).toBeLessThan(1e-3 * F); // tiny vs forward
  });
});

---------- END apps/server/src/volModels/tests/bs.test.ts ----------

---------- BEGIN apps/server/src/volModels/tests/bucket.test.ts (bytes=456) ----------
import { DeltaConventions } from "../pricing/blackScholes";

describe("DeltaConventions.strikeToBucket", () => {
  const spot = 100;
  const T = 0.25;
  const iv = 0.31;

  test("ATM falls into atm bucket", () => {
    const b = DeltaConventions.strikeToBucket(100, spot, iv, T);
    expect(b).toBe("atm");
  });

  test("OTM put is not atm", () => {
    const b = DeltaConventions.strikeToBucket(90, spot, iv, T);
    expect(b).not.toBe("atm");
  });
});

---------- END apps/server/src/volModels/tests/bucket.test.ts ----------

---------- BEGIN apps/server/src/volModels/tests/integratedSmileModel.test.ts (bytes=1498) ----------
import { IntegratedSmileModel } from "../integratedSmileModel";

const days = (d: number) => d * 24 * 3600 * 1000;

describe("IntegratedSmileModel", () => {
  let model: IntegratedSmileModel;
  let now: number;

  beforeEach(() => {
    model = new IntegratedSmileModel("BTC");
    now = Date.now();
  });

  test("ATM quote finite & reasonable", () => {
    const forward = 100_000;
    const strike  = 100_000;
    const expiry  = now + days(14);

    const q = model.getQuote(expiry, strike, forward, "C", 0.31);
    expect(q.pcMid).toBeGreaterThan(0);
    expect(q.ccMid).toBeGreaterThan(0);
    expect(q.ask).toBeGreaterThanOrEqual(q.bid);
    expect(["atm","rr25","rr10","wings"]).toContain(q.bucket);
  });

  test("trade updates inventory and changes edge (directional)", () => {
    const forward = 100_000;
    const strike  = 90_000;       // OTM put-ish
    const expiry  = now + days(14);

    const q0   = model.getQuote(expiry, strike, forward, "P", 0.31);
    const edge0 = q0.edge;

    // Customer BUY 50 puts at ask → we SELL → short vega → PC should lift vs CC (edge up)
    const price = q0.ask;
    model.onTrade({
      expiryMs: expiry,
      strike,
      forward,
      optionType: "P",
      price,
      size: +50,    // size signed from CUSTOMER perspective per your service
      time: now
    });

    const q1 = model.getQuote(expiry, strike, forward, "P", 0.31);
    expect(Number.isFinite(q1.edge)).toBe(true);
    expect(q1.edge).not.toBe(edge0);
  });
});

---------- END apps/server/src/volModels/tests/integratedSmileModel.test.ts ----------

---------- BEGIN apps/server/src/volModels/tests/smokeQuoteTrade.test.ts (bytes=980) ----------
import { volService } from "../integration/volModelService";

describe("smokeQuoteTrade → quote→trade→quote path", () => {
  const symbol = "BTC";
  const now = Date.now();
  const expiry = now + 7 * 24 * 3600 * 1000;

  it("quotes OTM put, executes a trade, and inventory shifts edge directionally", () => {
    const strikeOTMPut = 90_000;

    const q0 = volService.getQuoteWithIV(symbol, strikeOTMPut, expiry, 0.35, "P");

    expect(q0).toBeTruthy();
    expect(q0.bid).toBeGreaterThanOrEqual(0);
    expect(q0.ask).toBeGreaterThan(q0.bid);

    // trade via integration adapter (positional API)
    volService.onCustomerTrade(
      symbol,
      strikeOTMPut,
      "BUY",    // we buy the put (dealer sells)
      50,
      q0.bid,
      expiry,
      "P",
      now,
      0.35
    );

    const q1 = volService.getQuoteWithIV(symbol, strikeOTMPut, expiry, 0.35, "P");

    expect(q1).toBeTruthy();
    expect(q1.ask).toBeGreaterThan(q1.bid);
  });
});

export {};

---------- END apps/server/src/volModels/tests/smokeQuoteTrade.test.ts ----------

---------- BEGIN apps/server/src/volModels/tests/testDualSurface.ts (bytes=7739) ----------
/**
 * Test Suite for Dual Surface Model
 * Run this to verify everything is working
 */

import { DualSurfaceModel, TraderMetrics } from '../dualSurfaceModel';
import { getDefaultConfig } from '../config/modelConfig';
import { blackScholes, DeltaConventions } from '../pricing/blackScholes';

/**
 * Test 1: Basic surface creation and CC updates
 */
function testSurfaceCreation(): void {
  console.log('=== Test 1: Surface Creation ===\n');
  
  const config = getDefaultConfig('BTC');
  const model = new DualSurfaceModel(config);
  
  // Initial CC setup
  const expiry = 0.25; // 3 months
  const initialMetrics: TraderMetrics = {
    L0: 0.04,    // 20% vol for 3M (0.2^2 * 0.25)
    S0: 0.001,   // Small positive skew
    C0: 0.5,     // Moderate curvature
    S_neg: -0.8, // Left wing slope
    S_pos: 0.9   // Right wing slope
  };
  
  model.updateCC(expiry, initialMetrics);
  console.log('✅ Created initial CC with 20% ATM vol\n');
  
  // Get initial quotes
  const spot = 100;
  const strikes = [90, 95, 100, 105, 110];
  const quotes = model.getQuotes(expiry, strikes, spot);
  
  console.log('Initial quotes (no trades yet):');
  quotes.forEach((quote, strike) => {
    const bucket = DeltaConventions.strikeToBucket(strike, spot, 0.2, expiry);
    console.log(`  K=${strike} (${bucket}): ${quote.bid.toFixed(2)} / ${quote.ask.toFixed(2)}`);
  });
  
  console.log('');
}

/**
 * Test 2: Trade execution and PC anchoring
 */
function testTradeExecution(): void {
  console.log('=== Test 2: Trade Execution ===\n');
  
  const config = getDefaultConfig('BTC');
  const model = new DualSurfaceModel(config);
  
  // Setup
  const expiry = 0.25;
  const spot = 100;
  const initialMetrics: TraderMetrics = {
    L0: 0.04,
    S0: 0.001,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, initialMetrics);
  
  // Get quotes before trade
  const strikeToTrade = 95;
  const quotesBefore = model.getQuotes(expiry, [strikeToTrade], spot);
  const quoteBefore = quotesBefore.get(strikeToTrade)!;
  
  console.log(`Before trade - K=95: ${quoteBefore.bid.toFixed(2)} / ${quoteBefore.ask.toFixed(2)}`);
  
  // Execute trade - sell 100 lots at the ask
  const tradedPrice = quoteBefore.ask;
  model.onTrade(expiry, strikeToTrade, tradedPrice, 100, spot);
  
  console.log(`\n✅ Sold 100 lots at ${tradedPrice.toFixed(2)}\n`);
  
  // Get quotes after trade
  const quotesAfter = model.getQuotes(expiry, [90, 95, 100, 105, 110], spot);
  
  console.log('After trade - quotes:');
  quotesAfter.forEach((quote, strike) => {
    const marker = strike === strikeToTrade ? ' ← traded' : '';
    console.log(`  K=${strike}: ${quote.bid.toFixed(2)} / ${quote.ask.toFixed(2)}${marker}`);
  });
  
  console.log('\nNote: PC has anchored at trade price, quotes now centered there\n');
}

/**
 * Test 3: Width-delta rule on spot move
 */
function testWidthDeltaRule(): void {
  console.log('=== Test 3: Width-Delta Rule (Spot Move) ===\n');
  
  const config = getDefaultConfig('BTC');
  const model = new DualSurfaceModel(config);
  
  // Setup
  const expiry = 0.25;
  let spot = 100;
  const initialMetrics: TraderMetrics = {
    L0: 0.04,
    S0: 0.001,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, initialMetrics);
  
  // Trade at K=95 (initially ~25 delta put)
  const strike = 95;
  console.log(`Initial: Spot=${spot}, K=${strike}`);
  
  const initialDelta = Math.abs(blackScholes({
    strike,
    spot,
    vol: 0.2,
    T: expiry,
    r: 0,
    isCall: false
  }).delta);
  
  console.log(`  Delta: ${(initialDelta * 100).toFixed(0)}Δ`);
  console.log(`  Bucket: ${DeltaConventions.strikeToBucket(strike, spot, 0.2, expiry)}\n`);
  
  // Execute trade
  model.onTrade(expiry, strike, 5.5, 100, spot);
  console.log('✅ Sold 100 lots at 5.5\n');
  
  // Get quotes at original spot
  let quotes = model.getQuotes(expiry, [strike], spot);
  let quote = quotes.get(strike)!;
  console.log(`Quotes at spot=100: ${quote.bid.toFixed(2)} / ${quote.ask.toFixed(2)}`);
  
  // Move spot - strike gets closer to ATM
  spot = 96;
  console.log(`\n📉 Spot moves to ${spot} (strike now closer to ATM)\n`);
  
  const newDelta = Math.abs(blackScholes({
    strike,
    spot,
    vol: 0.2,
    T: expiry,
    r: 0,
    isCall: false
  }).delta);
  
  console.log(`New delta: ${(newDelta * 100).toFixed(0)}Δ`);
  console.log(`New bucket: ${DeltaConventions.strikeToBucket(strike, spot, 0.2, expiry)}\n`);
  
  // Get new quotes - should reflect higher risk
  quotes = model.getQuotes(expiry, [strike], spot);
  quote = quotes.get(strike)!;
  console.log(`Quotes at spot=96: ${quote.bid.toFixed(2)} / ${quote.ask.toFixed(2)}`);
  console.log('\n⚠️  Width should increase as position risk increased');
  console.log('(In full implementation, PC would adjust via width-delta rule)\n');
}

/**
 * Test 4: Greeks calculation
 */
function testGreeks(): void {
  console.log('=== Test 4: Greeks Calculation ===\n');
  
  const inputs = {
    strike: 100,
    spot: 100,
    vol: 0.25,
    T: 0.25,
    r: 0.05,
    isCall: true
  };
  
  const greeks = blackScholes(inputs);
  
  console.log('ATM Call (S=K=100, σ=25%, T=3M, r=5%):');
  console.log(`  Price: $${greeks.price.toFixed(2)}`);
  console.log(`  Delta: ${greeks.delta.toFixed(3)}`);
  console.log(`  Gamma: ${greeks.gamma.toFixed(4)}`);
  console.log(`  Vega:  $${greeks.vega.toFixed(2)} per 1% vol`);
  console.log(`  Theta: $${greeks.theta.toFixed(2)} per day`);
  console.log(`  Rho:   $${greeks.rho.toFixed(2)} per 1% rate`);
  
  // Test put-call parity
  const callGreeks = blackScholes({ ...inputs, isCall: true });
  const putGreeks = blackScholes({ ...inputs, isCall: false });
  
  const parityCheck = callGreeks.price - putGreeks.price - 
    (inputs.spot - inputs.strike * Math.exp(-inputs.r * inputs.T));
  
  console.log(`\n✅ Put-Call Parity check: ${Math.abs(parityCheck) < 0.01 ? 'PASS' : 'FAIL'}`);
  console.log(`  Difference: ${parityCheck.toFixed(6)}\n`);
}

/**
 * Test 5: Market learning (risk scorer)
 */
function testMarketLearning(): void {
  console.log('=== Test 5: Market Learning ===\n');
  
  const config = getDefaultConfig('BTC');
  const model = new DualSurfaceModel(config);
  
  // Setup surface
  const expiry = 0.25;
  const spot = 100;
  const initialMetrics: TraderMetrics = {
    L0: 0.04,
    S0: 0.001,
    C0: 0.5,
    S_neg: -0.8,
    S_pos: 0.9
  };
  
  model.updateCC(expiry, initialMetrics);
  
  console.log('Simulating market observations...\n');
  
  // Simulate tight market
  console.log('Scenario 1: Tight market');
  // In real implementation, would update risk scorer with tight spreads
  let quotes = model.getQuotes(expiry, [100], spot);
  let quote = quotes.get(100)!;
  console.log(`  ATM: ${quote.bid.toFixed(2)} / ${quote.ask.toFixed(2)}`);
  
  // Simulate wide market (would need to update risk scorer)
  console.log('\nScenario 2: Wide market (stressed conditions)');
  console.log('  [In full implementation, spreads would widen]');
  
  console.log('\n✅ Market learning framework in place\n');
}

/**
 * Run all tests
 */
export function runAllTests(): void {
  console.log('\n' + '='.repeat(50));
  console.log('DUAL SURFACE MODEL - TEST SUITE');
  console.log('='.repeat(50) + '\n');
  
  try {
    testSurfaceCreation();
    testTradeExecution();
    testWidthDeltaRule();
    testGreeks();
    testMarketLearning();
    
    console.log('='.repeat(50));
    console.log('✅ ALL TESTS COMPLETED SUCCESSFULLY');
    console.log('='.repeat(50) + '\n');
  } catch (error) {
    console.error('\n❌ TEST FAILED:', error);
    process.exit(1);
  }
}

// Run tests if this file is executed directly
if (require.main === module) {
  runAllTests();
}
---------- END apps/server/src/volModels/tests/testDualSurface.ts ----------

---------- BEGIN apps/server/src/volModels/tests/volModelService.test.ts (bytes=636) ----------
import { volService } from "../integration/volModelService";

describe("VolModelService basic functionality", () => {
  const symbol = "BTC";
  const now = Date.now();
  const expiry = now + 7 * 24 * 3600 * 1000;

  it("gets a quote with valid prices", () => {
    const strike = 95_000;
    // positional API: getQuoteWithIV(symbol, strike, expiryMs, ivGuessOrFwd, "P"|"C")
    const q = volService.getQuoteWithIV(symbol, strike, expiry, 0.35, "P");

    expect(q).toBeTruthy();
    expect(q.bid).toBeGreaterThanOrEqual(0);
    expect(q.ask).toBeGreaterThan(q.bid);
    expect(Number.isFinite(q.mid)).toBe(true);
  });
});

export {};

---------- END apps/server/src/volModels/tests/volModelService.test.ts ----------

---------- BEGIN apps/server/src/volModels/types.ts (bytes=598) ----------
export type VolModelParams = {
  vol: number;        // Base vol level (affects all strikes)
  skew: number;       // Put-call spread (max at 25Δ)
  pump: number;       // Symmetric smile (max at 15Δ)
  wingPut: number;    // Put wing (max at 10Δ)
  wingCall: number;   // Call wing (max at 10Δ)
  volPathRate: number; // dVol/dSpot tangent at ATM
};

export type VolModel = {
  getIV(moneyness: number, params: VolModelParams): number;
  calibrate(strikes: number[], ivs: number[], spot: number): VolModelParams;
  reprice(strikes: number[], spot: number, params: VolModelParams): number[];
};
---------- END apps/server/src/volModels/types.ts ----------

---------- BEGIN src/components/VolController.jsx (bytes=10613) ----------
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { LineChart, Line, XAxis, YAxis, Tooltip, ResponsiveContainer, Legend, Scatter } from "recharts";

/**
 * Deribit BTC Options Pricer — Live Controller (Front-end)
 *
 * What changed per request:
 * - **Futures Price (F), Time-to-Expiry (T), and Risk-Free Rate (r) are NOT editable** on the UI.
 * - F should be fed live from your market feed. Pass it via the `F` prop to this component.
 * - T is computed **live** from a given `expiry` (UTC) prop (recomputed every second).
 * - r is an automated input — pass it via the `r` prop from your rate service; UI shows it read-only.
 *
 * Vol controls (editable): ATM Vol %, Skew %, Put Wing %, Call Wing %, Vol Path Rate.
 * Smile (demo): sigma(K) = atm + skew*ln(K/F) + (K<F?pWing : K>F?cWing : 0); then damp by volPathRate.
 * Pricing: Black-76 on futures with discount factor DF = exp(-r*T). Units: price in BTC (F and K are USD; this is model-only illustrative).
 */

// ---- Types (JSDoc) ----
/**
 * @typedef {Object} VolState
 * @property {number} atmVolPct - % e.g. 33.1
 * @property {number} skewPct - % per ln(K/F)
 * @property {number} pWingPct - % add for K<F
 * @property {number} cWingPct - % add for K>F
 * @property {number} volPathRatePct - % dampener (dimensionless scaling via %/100)
 */

/**
 * @typedef {Object} ParamConfig
 * @property {keyof VolState} key
 * @property {string} label
 * @property {number} step
 * @property {number} [min]
 * @property {number} [max]
 * @property {number} [decimals]
 * @property {string} [unit]
 */

const PARAMS = [
  { key: "atmVolPct", label: "ATM Vol", step: 0.1, min: 0, max: 500, decimals: 1, unit: "%" },
  { key: "skewPct", label: "Skew", step: 0.1, min: -200, max: 200, decimals: 1, unit: "%" },
  { key: "pWingPct", label: "Put Wing", step: 0.1, min: -200, max: 200, decimals: 1, unit: "%" },
  { key: "cWingPct", label: "Call Wing", step: 0.1, min: -200, max: 200, decimals: 1, unit: "%" },
  { key: "volPathRatePct", label: "Vol Path Rate", step: 0.1, min: 0, max: 200, decimals: 1, unit: "%" },
];

function clamp(n, min, max) {
  if (min != null && n < min) return min; if (max != null && n > max) return max; return n;
}

function effectiveStep(base, e) {
  let factor = 1; if (!e) return base;
  const anyE = e;
  if (anyE.shiftKey) factor *= 0.1; // fine
  if (anyE.altKey) factor *= 5;     // coarse
  if (anyE.ctrlKey || anyE.metaKey) factor *= 10; // big
  return base * factor;
}

// ---- Math (Black-76) ----
function erf(x) {
  // Abramowitz & Stegun approximation
  const sign = Math.sign(x);
  const a1 = 0.254829592;
  const a2 = -0.284496736;
  const a3 = 1.421413741;
  const a4 = -1.453152027;
  const a5 = 1.061405429;
  const p = 0.3275911;
  const t = 1 / (1 + p * Math.abs(x));
  const y = 1 - (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) * Math.exp(-x * x);
  return sign * y;
}

function cnd(x) { return 0.5 * (1 + erf(x / Math.SQRT2)); }

function black76Call(F, K, T, sigma, r) {
  // DF = exp(-r T); F here is futures; price in futures numeraire then discount
  if (sigma <= 0 || T <= 0) return Math.max(F - K, 0) * Math.exp(-r * T);
  const vol = sigma * Math.sqrt(T);
  const d1 = (Math.log(F / K)) / vol + 0.5 * vol;
  const d2 = d1 - vol;
  const DF = Math.exp(-r * T);
  return DF * (F * cnd(d1) - K * cnd(d2));
}

function pctToVol(p) { return Math.max(0, p) / 100; }

// Smile function (demo)
function smileVolPct(K, F, s) {
  const m = Math.log(Math.max(1e-12, K / F));
  const wing = K < F ? s.pWingPct : (K > F ? s.cWingPct : 0);
  const raw = s.atmVolPct + s.skewPct * m + wing;
  const damp = 1.0 / (1.0 + pctToVol(s.volPathRatePct));
  return Math.max(0, raw * damp);
}

// ---- UI Tile ----
function ControlTile({ cfg, value, onChange }) {
  const repeatRef = useRef(null);
  const applyDelta = useCallback((delta, e) => {
    const step = effectiveStep(cfg.step, e);
    const next = Number((clamp(value + delta * step, cfg.min, cfg.max)).toFixed(cfg.decimals ?? 1));
    onChange(next);
  }, [cfg, value, onChange]);

  const startRepeat = useCallback((delta, e) => {
    applyDelta(delta, e);
    let delay = 300;
    const tick = () => { applyDelta(delta, e); delay = Math.max(40, delay * 0.86); repeatRef.current.timer = setTimeout(tick, delay); };
    repeatRef.current = { timer: setTimeout(tick, delay), delta, delay };
  }, [applyDelta]);

  const stopRepeat = useCallback(() => { if (repeatRef.current && repeatRef.current.timer) clearTimeout(repeatRef.current.timer); repeatRef.current = null; }, []);
  useEffect(() => { const up = () => stopRepeat(); window.addEventListener("mouseup", up); return () => window.removeEventListener("mouseup", up); }, [stopRepeat]);

  return (
    <div
      className="rounded-2xl border border-gray-200 p-4 bg-white hover:shadow-sm transition-shadow select-none"
      onMouseDown={(e) => { e.preventDefault(); if (e.button === 0) startRepeat(+1, e.nativeEvent); if (e.button === 2) startRepeat(-1, e.nativeEvent); }}
      onContextMenu={(e) => e.preventDefault()}
      onWheel={(e) => { e.preventDefault(); applyDelta(e.deltaY < 0 ? +1 : -1, e.nativeEvent); }}
      onKeyDown={(e) => { if (e.key === "ArrowUp") { e.preventDefault(); applyDelta(+1, e.nativeEvent); } if (e.key === "ArrowDown") { e.preventDefault(); applyDelta(-1, e.nativeEvent); } }}
      tabIndex={0}
    >
      <div className="text-sm text-gray-500 mb-2 flex items-center justify-between">
        <span>{cfg.label}</span>
        <span className="opacity-70">{cfg.unit}</span>
      </div>
      <div className="flex items-center gap-3">
        <button className="px-3 py-2 rounded-xl border" onClick={(e) => { e.preventDefault(); applyDelta(-1, e.nativeEvent); }}>–</button>
        <div className="flex-1 text-center text-2xl font-semibold tracking-tight tabular-nums">{value.toFixed(cfg.decimals ?? 1)}</div>
        <button className="px-3 py-2 rounded-xl border" onClick={(e) => { e.preventDefault(); applyDelta(+1, e.nativeEvent); }}>+</button>
      </div>
      <div className="mt-2 text-xs text-gray-500">Click & drag • Wheel • ↑/↓ (Shift ×0.1 • Alt ×5 • Ctrl/Cmd ×10)</div>
    </div>
  );
}

// ---- Chart ----
function ModelChart({ F, T, r, params, market }) {
  const data = useMemo(() => {
    const strikes = [];
    for (let k = 0.6 * F; k <= 1.8 * F; k += (1.8 * F - 0.6 * F) / 80) strikes.push(k);
    return strikes.map((K) => {
      const sigma = pctToVol(smileVolPct(K, F, params));
      const px = black76Call(F, K, T, sigma, r);
      return { K, model: px };
    });
  }, [F, T, r, params]);

  return (
    <div className="rounded-2xl border border-gray-200 p-4 bg-white">
      <h2 className="font-semibold mb-2">Live BTC Options — Model vs Deribit Market</h2>
      <div className="h-[360px]">
        <ResponsiveContainer width="100%" height="100%">
          <LineChart data={data} margin={{ top: 10, right: 20, left: 0, bottom: 10 }}>
            <XAxis dataKey="K" type="number" domain={[0.6 * F, 1.8 * F]} tickFormatter={(v) => v.toLocaleString()} label={{ value: "Strike (USD)", position: "insideBottom", offset: -5 }} />
            <YAxis dataKey="model" type="number" tickFormatter={(v) => v.toFixed(4)} label={{ value: "Option Price (BTC)", angle: -90, position: "insideLeft" }} />
            <Tooltip formatter={(v, n) => (n === "model" ? Number(v).toFixed(6) : v)} labelFormatter={(v) => `K=${Number(v).toLocaleString()}`} />
            <Legend />
            <Line name="Model (BTC)" type="monotone" dataKey="model" dot={false} />
            {market && market.length > 0 && (
              <Scatter name="Market (BTC)" data={market.map(m => ({ K: m.K, model: m.price }))} />
            )}
          </LineChart>
        </ResponsiveContainer>
      </div>
    </div>
  );
}

// ---- Main ----
export default function VolController({
  initial = { atmVolPct: 33.1, skewPct: 0.0, pWingPct: 0.0, cWingPct: 0.0, volPathRatePct: 0.0 },
  F = 111447,                   // live futures price (USD) from feed
  expiry,                       // UTC Date or ms — required for live TTX
  r = 0.00,                     // risk-free rate (annualized, decimal) — from rate service
  market = [],
  onChange,
  title = "Deribit BTC Vol — Live Controller",
  liveConnected = true,
}) {
  const [state, setState] = useState(initial);

  // Compute T from expiry continuously (years)
  const [T, setT] = useState(0);
  useEffect(() => {
    const getYears = () => {
      const now = Date.now();
      const e = typeof expiry === "number" ? expiry : expiry.getTime();
      return Math.max(0, (e - now) / (365.25 * 24 * 3600 * 1000));
    };
    setT(getYears());
    const id = setInterval(() => setT(getYears()), 1000);
    return () => clearInterval(id);
  }, [expiry]);

  useEffect(() => { onChange?.(state); }, [state, onChange]);

  return (
    <div className="p-6 max-w-6xl mx-auto space-y-6">
      <h1 className="text-3xl font-bold tracking-tight">Deribit BTC Options Pricer</h1>

      <div className="rounded-2xl border border-gray-200 bg-white">
        <div className="border-b px-4 py-3 font-semibold">{title}</div>

        {/* Volatility Model (editable) */}
        <div className="p-4">
          <h3 className="font-semibold mb-2">Volatility Model</h3>
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
            {PARAMS.map((cfg) => (
              <ControlTile key={cfg.key} cfg={cfg} value={state[cfg.key]} onChange={(v) => setState((prev) => ({ ...prev, [cfg.key]: v }))} />
            ))}
          </div>
        </div>

        {/* Market Parameters (read-only, live-fed) */}
        <div className="px-4 pb-4 text-sm text-gray-700 grid grid-cols-1 sm:grid-cols-2 gap-4">
          <div>
            <div className="font-semibold mb-1">Market Parameters</div>
            <div>Futures Price (USD): <span className="tabular-nums">{F.toLocaleString()}</span></div>
            <div>Time to Expiry (years): <span className="tabular-nums">{T.toFixed(6)}</span></div>
            <div>Risk-Free Rate (r): <span className="tabular-nums">{(r * 100).toFixed(3)}%</span></div>
            <div>Live Data: {liveConnected ? "✔ Connected" : "✖ Disconnected"}</div>
          </div>
          <div>
            <div className="font-semibold mb-1">Snapshot</div>
            <div>ATM IV (model): {(state.atmVolPct).toFixed(2)}%</div>
            <div>Skew: {(state.skewPct).toFixed(2)}%</div>
          </div>
        </div>
      </div>

      <ModelChart F={F} T={T} r={r} params={state} market={market} />
    </div>
  );
}

---------- END src/components/VolController.jsx ----------

---------- BEGIN src/components/ui/button.jsx (bytes=1435) ----------
import * as React from "react"
import { cn } from "../../lib/utils.js"

const Button = React.forwardRef(({ className, variant = "default", size = "default", ...props }, ref) => {
  return (
    <button
      className={cn(
        "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
        {
          "bg-primary text-primary-foreground hover:bg-primary/90": variant === "default",
          "bg-destructive text-destructive-foreground hover:bg-destructive/90": variant === "destructive",
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground": variant === "outline",
          "bg-secondary text-secondary-foreground hover:bg-secondary/80": variant === "secondary",
          "hover:bg-accent hover:text-accent-foreground": variant === "ghost",
          "text-primary underline-offset-4 hover:underline": variant === "link",
        },
        {
          "h-10 px-4 py-2": size === "default",
          "h-9 rounded-md px-3": size === "sm",
          "h-11 rounded-md px-8": size === "lg",
          "h-10 w-10": size === "icon",
        },
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Button.displayName = "Button"

export { Button }

---------- END src/components/ui/button.jsx ----------

---------- BEGIN src/components/ui/card.jsx (bytes=1501) ----------
import * as React from "react"
import { cn } from "../../lib/utils.js"

const Card = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

---------- END src/components/ui/card.jsx ----------

---------- BEGIN src/components/ui/input.jsx (bytes=686) ----------
import * as React from "react"
import { cn } from "../../lib/utils.js"

const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Input.displayName = "Input"

export { Input }

---------- END src/components/ui/input.jsx ----------

---------- BEGIN src/components/ui/label.jsx (bytes=373) ----------
import * as React from "react"
import { cn } from "../../lib/utils.js"

const Label = React.forwardRef(({ className, ...props }, ref) => (
  <label
    ref={ref}
    className={cn(
      "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
      className
    )}
    {...props}
  />
))
Label.displayName = "Label"

export { Label }

---------- END src/components/ui/label.jsx ----------

---------- BEGIN src/components/ui/slider.jsx (bytes=385) ----------
import * as React from "react"
import { cn } from "../../lib/utils.js"

const Slider = React.forwardRef(({ className, ...props }, ref) => (
  <input
    type="range"
    className={cn(
      "w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700",
      className
    )}
    ref={ref}
    {...props}
  />
))
Slider.displayName = "Slider"

export { Slider }

---------- END src/components/ui/slider.jsx ----------

---------- BEGIN src/lib/utils.js (bytes=85) ----------
import { clsx } from "clsx"

export function cn(...inputs) {
  return clsx(inputs)
}

---------- END src/lib/utils.js ----------

---------- BEGIN src/screens/PnL.jsx (bytes=15990) ----------
import React, { useState, useMemo } from 'react';

// Mock data - in real app, this would come from trade DB
const mockTrades = [
  {
    trade_id: 1001,
    ts: "2024-01-15T10:30:00Z",
    instrument: "BTC-3OCT25-110000-C",
    side: "BUY",
    qty: 3,
    price_btc: 0.0125,
    fee_btc: 0.0001
  },
  {
    trade_id: 1002,
    ts: "2024-01-15T11:15:00Z",
    instrument: "BTC-3OCT25-110000-C",
    side: "BUY",
    qty: 2,
    price_btc: 0.0128,
    fee_btc: 0.0001
  },
  {
    trade_id: 1003,
    ts: "2024-01-16T09:45:00Z",
    instrument: "BTC-3OCT25-110000-C",
    side: "SELL",
    qty: 1,
    price_btc: 0.0135,
    fee_btc: 0.0001
  },
  {
    trade_id: 1004,
    ts: "2024-01-16T14:20:00Z",
    instrument: "BTC-3OCT25-112000-P",
    side: "SELL",
    qty: 3,
    price_btc: 0.0089,
    fee_btc: 0.0001
  }
];

const mockPnLParams = {
  mark_source: "MODEL",
  index_usd: 111447,
  F: 111447
};

// Mock current marks for unrealized P&L
const mockCurrentMarks = {
  "BTC-3OCT25-110000-C": 0.0156, // BTC per contract
  "BTC-3OCT25-112000-P": 0.0092  // BTC per contract
};

export default function PnL() {
  const [selectedPeriod, setSelectedPeriod] = useState('today');
  const [markSource, setMarkSource] = useState('MODEL');

  // Calculate realized P&L from trades
  const realizedPnL = useMemo(() => {
    const instrumentTrades = {};
    
    // Group trades by instrument
    mockTrades.forEach(trade => {
      if (!instrumentTrades[trade.instrument]) {
        instrumentTrades[trade.instrument] = [];
      }
      instrumentTrades[trade.instrument].push(trade);
    });

    let totalRealizedBtc = 0;
    let totalFeesBtc = 0;
    const byInstrument = {};

    Object.entries(instrumentTrades).forEach(([instrument, trades]) => {
      // Sort by timestamp
      trades.sort((a, b) => new Date(a.ts) - new Date(b.ts));
      
      let position = 0;
      let avgCost = 0;
      let realizedBtc = 0;
      let feesBtc = 0;

      trades.forEach(trade => {
        const signedQty = trade.side === 'BUY' ? trade.qty : -trade.qty;
        const newPosition = position + signedQty;
        
        if (position > 0 && signedQty < 0) {
          // Closing long position
          const closeQty = Math.min(position, Math.abs(signedQty));
          const realized = closeQty * (trade.price_btc - avgCost);
          realizedBtc += realized;
        } else if (position < 0 && signedQty > 0) {
          // Closing short position
          const closeQty = Math.min(Math.abs(position), signedQty);
          const realized = closeQty * (avgCost - trade.price_btc);
          realizedBtc += realized;
        }
        
        // Update position and average cost
        if (newPosition > 0) {
          avgCost = (position * avgCost + Math.abs(signedQty) * trade.price_btc) / newPosition;
        } else if (newPosition < 0) {
          avgCost = trade.price_btc;
        }
        
        position = newPosition;
        feesBtc += trade.fee_btc;
      });

      byInstrument[instrument] = {
        realizedBtc,
        feesBtc,
        currentPosition: position,
        avgCost
      };
      
      totalRealizedBtc += realizedBtc;
      totalFeesBtc += feesBtc;
    });

    return {
      totalRealizedBtc,
      totalFeesBtc,
      byInstrument,
      totalRealizedUsd: totalRealizedBtc * mockPnLParams.index_usd
    };
  }, []);

  // Calculate unrealized P&L
  const unrealizedPnL = useMemo(() => {
    let totalUnrealizedBtc = 0;
    const byInstrument = {};

    Object.entries(realizedPnL.byInstrument).forEach(([instrument, data]) => {
      if (data.currentPosition !== 0) {
        const currentMark = mockCurrentMarks[instrument] || 0;
        const unrealizedBtc = data.currentPosition * (currentMark - data.avgCost);
        
        byInstrument[instrument] = {
          position: data.currentPosition,
          avgCost: data.avgCost,
          currentMark,
          unrealizedBtc
        };
        
        totalUnrealizedBtc += unrealizedBtc;
      }
    });

    return {
      totalUnrealizedBtc,
      byInstrument,
      totalUnrealizedUsd: totalUnrealizedBtc * mockPnLParams.index_usd
    };
  }, [realizedPnL]);

  // Calculate attribution (simplified)
  const attribution = useMemo(() => {
    // Simplified attribution - in real app, would use yesterday's close vs today's open
    const priceMove = 0.02; // 2% F move
    const volMove = 0.01; // 1% vol move
    const timeDecay = -0.001; // Daily theta
    
    return {
      priceMoveBtc: priceMove * 0.1, // Simplified
      volMoveBtc: volMove * 0.05, // Simplified
      timeDecayBtc: timeDecay,
      carryFeesBtc: -0.0001 // Simplified
    };
  }, []);

  const Stat = ({ label, value, unit = "", highlight = false, positive = null }) => {
    const colorClass = positive !== null ? 
      (positive ? 'text-green-600' : 'text-red-600') : 
      (highlight ? 'text-blue-700' : 'text-gray-900');
    
    return (
      <div className={`p-3 rounded-lg ${highlight ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`}>
        <div className="text-xs text-gray-500">{label}</div>
        <div className={`text-lg font-semibold ${colorClass}`}>{value}{unit}</div>
      </div>
    );
  };

  const formatNumber = (num, decimals = 4) => {
    if (Math.abs(num) < 0.0001) return num.toExponential(2);
    return num.toFixed(decimals);
  };

  return (
    <div className="space-y-6">
      {/* Top Metrics */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">P&L Summary</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Stat 
            label="Realized P&L (BTC)" 
            value={formatNumber(realizedPnL.totalRealizedBtc, 6)} 
            unit="" 
            positive={realizedPnL.totalRealizedBtc > 0}
          />
          <Stat 
            label="Realized P&L (USD)" 
            value={`$${formatNumber(realizedPnL.totalRealizedUsd, 2)}`} 
            unit="" 
            positive={realizedPnL.totalRealizedUsd > 0}
          />
          <Stat 
            label="Unrealized P&L (BTC)" 
            value={formatNumber(unrealizedPnL.totalUnrealizedBtc, 6)} 
            unit="" 
            positive={unrealizedPnL.totalUnrealizedBtc > 0}
          />
          <Stat 
            label="Unrealized P&L (USD)" 
            value={`$${formatNumber(unrealizedPnL.totalUnrealizedUsd, 2)}`} 
            unit="" 
            positive={unrealizedPnL.totalUnrealizedUsd > 0}
          />
        </div>
        
        <div className="mt-4 grid grid-cols-2 md:grid-cols-3 gap-4">
          <Stat 
            label="Total P&L (BTC)" 
            value={formatNumber(realizedPnL.totalRealizedBtc + unrealizedPnL.totalUnrealizedBtc, 6)} 
            unit="" 
            positive={(realizedPnL.totalRealizedBtc + unrealizedPnL.totalUnrealizedBtc) > 0}
            highlight
          />
          <Stat 
            label="Total P&L (USD)" 
            value={`$${formatNumber(realizedPnL.totalRealizedUsd + unrealizedPnL.totalUnrealizedUsd, 2)}`} 
            unit="" 
            positive={(realizedPnL.totalRealizedUsd + unrealizedPnL.totalUnrealizedUsd) > 0}
            highlight
          />
          <Stat 
            label="Total Fees (BTC)" 
            value={formatNumber(realizedPnL.totalFeesBtc, 6)} 
            unit="" 
            positive={false}
          />
        </div>
      </div>

      {/* Period Selection */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-semibold">P&L by Period</h3>
          <div className="flex space-x-2">
            <button
              className={`px-3 py-1 rounded-lg text-sm ${
                selectedPeriod === 'today' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
              }`}
              onClick={() => setSelectedPeriod('today')}
            >
              Today
            </button>
            <button
              className={`px-3 py-1 rounded-lg text-sm ${
                selectedPeriod === 'ytd' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
              }`}
              onClick={() => setSelectedPeriod('ytd')}
            >
              YTD
            </button>
          </div>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Stat label="Day P&L (BTC)" value={formatNumber(0.0025, 6)} unit="" positive={true} />
          <Stat label="Day P&L (USD)" value={`$${formatNumber(278.62, 2)}`} unit="" positive={true} />
          <Stat label="YTD P&L (BTC)" value={formatNumber(0.0156, 6)} unit="" positive={true} />
          <Stat label="YTD P&L (USD)" value={`$${formatNumber(1738.57, 2)}`} unit="" positive={true} />
        </div>
      </div>

      {/* Attribution */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Day P&L Attribution</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Stat 
            label="Price (F move)" 
            value={formatNumber(attribution.priceMoveBtc, 6)} 
            unit="" 
            positive={attribution.priceMoveBtc > 0}
          />
          <Stat 
            label="Vol (σ move)" 
            value={formatNumber(attribution.volMoveBtc, 6)} 
            unit="" 
            positive={attribution.volMoveBtc > 0}
          />
          <Stat 
            label="Time (θ)" 
            value={formatNumber(attribution.timeDecayBtc, 6)} 
            unit="" 
            positive={attribution.timeDecayBtc > 0}
          />
          <Stat 
            label="Carry/Fees" 
            value={formatNumber(attribution.carryFeesBtc, 6)} 
            unit="" 
            positive={attribution.carryFeesBtc > 0}
          />
        </div>
        
        <div className="mt-4 text-xs text-gray-500">
          Attribution uses yesterday's close model & F as baseline
        </div>
      </div>

      {/* Realized P&L Details */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Realized P&L by Instrument</h3>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Instrument</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Current Position</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Avg Cost (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Realized P&L (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Fees (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Net (BTC)</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Object.entries(realizedPnL.byInstrument).map(([instrument, data]) => (
                <tr key={instrument}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{instrument}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{data.currentPosition}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.avgCost, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.realizedBtc, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.feesBtc, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.realizedBtc - data.feesBtc, 6)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Unrealized P&L Details */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Unrealized P&L by Instrument</h3>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Instrument</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Position</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Avg Cost (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Current Mark (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unrealized P&L (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Unrealized P&L (USD)</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Object.entries(unrealizedPnL.byInstrument).map(([instrument, data]) => (
                <tr key={instrument}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{instrument}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{data.position}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.avgCost, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.currentMark, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(data.unrealizedBtc, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">${formatNumber(data.unrealizedBtc * mockPnLParams.index_usd, 2)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* P&L Parameters */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">P&L Parameters</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Mark Source</label>
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={markSource}
              onChange={(e) => setMarkSource(e.target.value)}
            >
              <option value="MODEL">MODEL</option>
              <option value="MID">MID</option>
              <option value="LAST">LAST</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Index USD</label>
            <div className="text-lg font-semibold">${mockPnLParams.index_usd.toLocaleString()}</div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">F (USD)</label>
            <div className="text-lg font-semibold">${mockPnLParams.F.toLocaleString()}</div>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Last Updated</label>
            <div className="text-sm text-gray-600">2024-01-16 15:30:00 UTC</div>
          </div>
        </div>
      </div>
    </div>
  );
}

---------- END src/screens/PnL.jsx ----------

---------- BEGIN src/screens/QuoteModel.jsx (bytes=13096) ----------
import React, { useState, useMemo } from 'react';

// Math helpers
function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
function erf(x) {
  const sign = x < 0 ? -1 : 1;
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const t = 1/(1+p*Math.abs(x));
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}
function N(x){ return 0.5 * (1 + erf(x/Math.SQRT2)); }
function n(x){ return Math.exp(-0.5*x*x)/Math.sqrt(2*Math.PI); }

// Black-76 pricing
function black76Price(F, K, T, sigma, isCall = true) {
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F/K) + 0.5*sigma*sigma*T)/sT;
  const d2 = d1 - sT;
  if(isCall){ return F * N(d1) - K * N(d2); }
  return K * N(-d2) - F * N(-d1);
}

function black76Greeks(F, K, T, sigma, isCall = true) {
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F/K) + 0.5*sigma*sigma*T)/sT;
  const d2 = d1 - sT;
  const pdf = n(d1);
  const vega  = F * pdf * Math.sqrt(Math.max(T,1e-12));
  const gamma = pdf / (F * sT);
  const delta = (isCall ? 1 : -1) * N((isCall?1:-1)*d1);
  return { delta, gamma, vega };
}

// SVI total variance function (from Vol Model)
function sviTotalVar(k, params) {
  const { a, b, rho, m, s } = params;
  const x = k - m;
  return a + b * (rho * x + Math.sqrt(x*x + s*s));
}

function sviImpliedVol(k, T, params) {
  const w = sviTotalVar(k, params);
  return Math.sqrt(Math.max(1e-12, w / Math.max(T, 1e-12)));
}

export default function QuoteModel() {
  // Core inputs
  const [F, setF] = useState(111447.00); // BTC futures price
  const [K, setK] = useState(111000.00); // Strike
  const [T, setT] = useState(0.50); // years to expiry
  const [isCall, setIsCall] = useState(true);
  const [indexPrice, setIndexPrice] = useState(111447.00); // BTC index

  // Quote model parameters
  const [baseBps, setBaseBps] = useState(8); // Base spread in vol bps
  const [wDelta, setWDelta] = useState(0.02); // Risk weight for delta
  const [wGamma, setWGamma] = useState(1000); // Risk weight for gamma
  const [wVega, setWVega] = useState(0.05); // Risk weight for vega
  const [maxDSigmaBps, setMaxDSigmaBps] = useState(300); // Cap on vol add
  const [minWidthBtc, setMinWidthBtc] = useState(0.0001); // Min width in BTC
  const [maxWidthBtc, setMaxWidthBtc] = useState(0.01); // Max width in BTC
  const [qty, setQty] = useState(1); // Contracts

  // SVI parameters (from Vol Model - would be shared state in real app)
  const sviParams = {
    a: 0.08,
    b: 0.45,
    rho: -0.25,
    m: 0.00,
    s: 0.15
  };

  // Compute quote mechanics
  const quoteData = useMemo(() => {
    // 1. Model vol from SVI
    const k = Math.log(K / F);
    const modelVol = sviImpliedVol(k, T, sviParams);
    
    // 2. Mid price in BTC
    const midBtc = black76Price(F, K, T, modelVol, isCall);
    
    // 3. Greeks in BTC terms
    const greeks = black76Greeks(F, K, T, modelVol, isCall);
    
    // 4. Risk add (vol bps)
    const deltaRisk = wDelta * Math.pow(greeks.delta * qty, 2);
    const gammaRisk = wGamma * Math.pow(greeks.gamma * qty, 2);
    const vegaRisk = wVega * Math.pow(greeks.vega * qty, 2);
    const dSigmaRisk = Math.min(maxDSigmaBps / 10000, deltaRisk + gammaRisk + vegaRisk);
    
    // 5. Total vol add (bps)
    const dSigmaTot = (baseBps / 10000) + dSigmaRisk;
    
    // 6. Width in BTC
    const vegaEff = Math.max(1e-8, Math.abs(greeks.vega) * Math.max(1, Math.abs(qty)));
    const widthBtc = Math.max(minWidthBtc, Math.min(maxWidthBtc, vegaEff * dSigmaTot));
    
    // 7. Bid/Ask in BTC
    const bidBtc = midBtc - 0.5 * widthBtc;
    const askBtc = midBtc + 0.5 * widthBtc;
    
    // 8. USD mirrors
    const midUsd = midBtc * indexPrice;
    const bidUsd = bidBtc * indexPrice;
    const askUsd = askBtc * indexPrice;
    
    return {
      modelVol,
      midBtc,
      bidBtc,
      askBtc,
      midUsd,
      bidUsd,
      askUsd,
      greeks,
      dSigmaTot: dSigmaTot * 10000, // Convert back to bps
      widthBtc,
      appliedCaps: {
        dSigmaCapped: dSigmaRisk < (deltaRisk + gammaRisk + vegaRisk),
        widthCapped: widthBtc === maxWidthBtc
      }
    };
  }, [F, K, T, isCall, baseBps, wDelta, wGamma, wVega, maxDSigmaBps, minWidthBtc, maxWidthBtc, qty, indexPrice, sviParams]);

  const Field = ({ label, children, help }) => (
    <div className="flex flex-col gap-1">
      <label className="text-sm font-medium text-gray-700">{label}</label>
      {children}
      {help && <div className="text-xs text-gray-500">{help}</div>}
    </div>
  );

  const NumberInput = ({ value, onChange, step = 0.01, min, max, precision = 4 }) => (
    <input
      type="number"
      className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
      value={value}
      step={step}
      min={min}
      max={max}
      onChange={(e) => onChange(parseFloat(e.target.value) || 0)}
    />
  );

  const Stat = ({ label, value, unit = "", highlight = false }) => (
    <div className={`p-3 rounded-lg ${highlight ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`}>
      <div className="text-xs text-gray-500">{label}</div>
      <div className={`text-lg font-semibold ${highlight ? 'text-blue-700' : ''}`}>{value}{unit}</div>
    </div>
  );

  return (
    <div className="space-y-6">
      {/* Inputs */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Quote Model Inputs</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Field label="Underlying F (USD)">
            <NumberInput value={F} onChange={setF} step={0.01} />
          </Field>
          <Field label="Strike K (USD)">
            <NumberInput value={K} onChange={setK} step={0.01} />
          </Field>
          <Field label="Expiry T (years)">
            <NumberInput value={T} onChange={setT} step={0.01} />
          </Field>
          <Field label="Type">
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={isCall ? "Call" : "Put"}
              onChange={(e) => setIsCall(e.target.value === "Call")}
            >
              <option>Call</option>
              <option>Put</option>
            </select>
          </Field>
        </div>

        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-4">
          <Field label="Base Spread (vol bps)">
            <NumberInput value={baseBps} onChange={setBaseBps} step={0.5} min={0} max={100} />
          </Field>
          <Field label="Qty (contracts)">
            <NumberInput value={qty} onChange={setQty} step={1} min={1} />
          </Field>
          <Field label="BTC Index (USD)">
            <NumberInput value={indexPrice} onChange={setIndexPrice} step={0.01} />
          </Field>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
        {/* Risk Weights */}
        <div className="bg-white p-4 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Risk Weights</h3>
          
          <div className="space-y-4">
            <Field label="wΔ (Delta weight)" help="Quadratic penalty on delta">
              <NumberInput value={wDelta} onChange={setWDelta} step={0.005} min={0} />
            </Field>
            <Field label="wΓ (Gamma weight)" help="Quadratic penalty on gamma">
              <NumberInput value={wGamma} onChange={setWGamma} step={10} min={0} />
            </Field>
            <Field label="wVega (Vega weight)" help="Quadratic penalty on vega">
              <NumberInput value={wVega} onChange={setWVega} step={0.005} min={0} />
            </Field>
          </div>

          <div className="mt-6 space-y-4">
            <h4 className="font-medium">Quote Caps</h4>
            <Field label="Max dSigma (bps)" help="Cap on vol add">
              <NumberInput value={maxDSigmaBps} onChange={setMaxDSigmaBps} step={10} min={0} max={1000} />
            </Field>
            <Field label="Min Width (BTC)" help="Minimum quote width">
              <NumberInput value={minWidthBtc} onChange={setMinWidthBtc} step={0.0001} min={0} />
            </Field>
            <Field label="Max Width (BTC)" help="Maximum quote width">
              <NumberInput value={maxWidthBtc} onChange={setMaxWidthBtc} step={0.001} min={0} />
            </Field>
          </div>
        </div>

        {/* Quote Outputs */}
        <div className="bg-white p-4 rounded-lg shadow border">
          <h3 className="text-lg font-semibold mb-4">Quote Outputs</h3>
          
          <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <Stat label="Model Vol" value={quoteData.modelVol.toFixed(4)} unit="" />
              <Stat label="dSigma (bps)" value={quoteData.dSigmaTot.toFixed(1)} unit="" />
            </div>
            
            <div className="grid grid-cols-2 gap-4">
              <Stat label="Mid (BTC)" value={quoteData.midBtc.toFixed(8)} unit="" highlight />
              <Stat label="Mid (USD)" value={`$${quoteData.midUsd.toFixed(2)}`} unit="" />
            </div>
            
            <div className="grid grid-cols-2 gap-4">
              <Stat label="Bid (BTC)" value={quoteData.bidBtc.toFixed(8)} unit="" />
              <Stat label="Ask (BTC)" value={quoteData.askBtc.toFixed(8)} unit="" />
            </div>
            
            <div className="grid grid-cols-2 gap-4">
              <Stat label="Bid (USD)" value={`$${quoteData.bidUsd.toFixed(2)}`} unit="" />
              <Stat label="Ask (USD)" value={`$${quoteData.askUsd.toFixed(2)}`} unit="" />
            </div>
            
            <div className="grid grid-cols-3 gap-4">
              <Stat label="Δ (BTC/BTC)" value={quoteData.greeks.delta.toFixed(4)} unit="" />
              <Stat label="Γ (per $)" value={quoteData.greeks.gamma.toExponential(2)} unit="" />
              <Stat label="Vega (BTC/vol-pt)" value={quoteData.greeks.vega.toFixed(6)} unit="" />
            </div>
            
            <div className="grid grid-cols-2 gap-4">
              <Stat label="Width (BTC)" value={quoteData.widthBtc.toFixed(8)} unit="" />
              <Stat label="Width (USD)" value={`$${(quoteData.widthBtc * indexPrice).toFixed(2)}`} unit="" />
            </div>
          </div>

          {/* Applied Caps */}
          <div className="mt-4 p-3 bg-yellow-50 border border-yellow-200 rounded-lg">
            <div className="text-sm font-medium text-yellow-800">Applied Caps:</div>
            <div className="text-xs text-yellow-700 mt-1">
              {quoteData.appliedCaps.dSigmaCapped && "• dSigma capped to max limit\n"}
              {quoteData.appliedCaps.widthCapped && "• Width capped to max limit\n"}
              {!quoteData.appliedCaps.dSigmaCapped && !quoteData.appliedCaps.widthCapped && "• No caps applied"}
            </div>
          </div>
        </div>
      </div>

      {/* Computation Steps */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Computation Steps</h3>
        
        <div className="space-y-2 text-sm">
          <div className="flex justify-between">
            <span>1. Model vol from SVI:</span>
            <span className="font-mono">{quoteData.modelVol.toFixed(4)}</span>
          </div>
          <div className="flex justify-between">
            <span>2. Mid (BTC):</span>
            <span className="font-mono">{quoteData.midBtc.toFixed(8)} BTC</span>
          </div>
          <div className="flex justify-between">
            <span>3. Greeks (Δ, Γ, Vega):</span>
            <span className="font-mono">
              {quoteData.greeks.delta.toFixed(4)}, {quoteData.greeks.gamma.toExponential(2)}, {quoteData.greeks.vega.toFixed(6)}
            </span>
          </div>
          <div className="flex justify-between">
            <span>4. Risk add (vol bps):</span>
            <span className="font-mono">{quoteData.dSigmaTot.toFixed(1)} bps</span>
          </div>
          <div className="flex justify-between">
            <span>5. Total vol add:</span>
            <span className="font-mono">{baseBps + quoteData.dSigmaTot.toFixed(1)} bps</span>
          </div>
          <div className="flex justify-between">
            <span>6. Width (BTC):</span>
            <span className="font-mono">{quoteData.widthBtc.toFixed(8)} BTC</span>
          </div>
          <div className="flex justify-between">
            <span>7. Bid/Ask (BTC):</span>
            <span className="font-mono">
              {quoteData.bidBtc.toFixed(8)} / {quoteData.askBtc.toFixed(8)}
            </span>
          </div>
          <div className="flex justify-between">
            <span>8. USD mirrors:</span>
            <span className="font-mono">
              ${quoteData.bidUsd.toFixed(2)} / ${quoteData.askUsd.toFixed(2)}
            </span>
          </div>
        </div>
      </div>
    </div>
  );
}

---------- END src/screens/QuoteModel.jsx ----------

---------- BEGIN src/screens/Risk.jsx (bytes=15692) ----------
import React, { useState, useMemo } from 'react';

// Mock data - in real app, this would come from trade DB
const mockPositions = [
  {
    instrument: "BTC-3OCT25-110000-C",
    side: "LONG",
    qty: 5,
    avg_price_btc: 0.0125,
    trade_ids: [1001, 1002, 1003]
  },
  {
    instrument: "BTC-3OCT25-112000-P",
    side: "SHORT",
    qty: 3,
    avg_price_btc: 0.0089,
    trade_ids: [1004, 1005]
  },
  {
    instrument: "BTC-3OCT25-111000-C",
    side: "LONG",
    qty: 2,
    avg_price_btc: 0.0156,
    trade_ids: [1006]
  }
];

const mockMarks = {
  "BTC-3OCT25-110000-C": { mark_iv: 0.3307, F: 111447, index_usd: 111447, T_years: 0.50 },
  "BTC-3OCT25-112000-P": { mark_iv: 0.3520, F: 111447, index_usd: 111447, T_years: 0.50 },
  "BTC-3OCT25-111000-C": { mark_iv: 0.3307, F: 111447, index_usd: 111447, T_years: 0.50 }
};

// Math helpers
function erf(x) {
  const sign = x < 0 ? -1 : 1;
  const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
  const t = 1/(1+p*Math.abs(x));
  const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
  return sign*y;
}
function N(x){ return 0.5 * (1 + erf(x/Math.SQRT2)); }
function n(x){ return Math.exp(-0.5*x*x)/Math.sqrt(2*Math.PI); }

// Black-76 pricing and greeks
function black76Price(F, K, T, sigma, isCall = true) {
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F/K) + 0.5*sigma*sigma*T)/sT;
  const d2 = d1 - sT;
  if(isCall){ return F * N(d1) - K * N(d2); }
  return K * N(-d2) - F * N(-d1);
}

function black76Greeks(F, K, T, sigma, isCall = true) {
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F/K) + 0.5*sigma*sigma*T)/sT;
  const d2 = d1 - sT;
  const pdf = n(d1);
  const vega  = F * pdf * Math.sqrt(Math.max(T,1e-12));
  const gamma = pdf / (F * sT);
  const delta = (isCall ? 1 : -1) * N((isCall?1:-1)*d1);
  const theta = -F * pdf * sigma / (2 * Math.sqrt(T)) - (isCall ? 1 : -1) * F * N((isCall?1:-1)*d1) * 0.01; // Simplified theta
  return { delta, gamma, vega, theta };
}

export default function Risk() {
  // Filters
  const [selectedExpiry, setSelectedExpiry] = useState('3OCT25');
  const [selectedBucket, setSelectedBucket] = useState('all');
  const [selectedType, setSelectedType] = useState('all');
  const [selectedSide, setSelectedSide] = useState('all');

  // Current market data
  const [F, setF] = useState(111447.00);
  const [indexPrice, setIndexPrice] = useState(111447.00);

  // Filter positions
  const filteredPositions = useMemo(() => {
    return mockPositions.filter(pos => {
      const expiry = pos.instrument.split('-')[1];
      const isCall = pos.instrument.includes('-C');
      const side = pos.side;
      
      return (selectedExpiry === 'all' || expiry === selectedExpiry) &&
             (selectedType === 'all' || (selectedType === 'call' && isCall) || (selectedType === 'put' && !isCall)) &&
             (selectedSide === 'all' || side.toLowerCase() === selectedSide);
    });
  }, [selectedExpiry, selectedType, selectedSide]);

  // Calculate greeks for each position
  const positionData = useMemo(() => {
    return filteredPositions.map(pos => {
      const mark = mockMarks[pos.instrument];
      if (!mark) return null;

      const strike = parseFloat(pos.instrument.split('-')[2]);
      const isCall = pos.instrument.includes('-C');
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      
      const greeks = black76Greeks(mark.F, strike, mark.T_years, mark.mark_iv, isCall);
      const price = black76Price(mark.F, strike, mark.T_years, mark.mark_iv, isCall);
      
      return {
        ...pos,
        strike,
        isCall,
        signedQty,
        greeks: {
          delta: greeks.delta * signedQty,
          gamma: greeks.gamma * signedQty,
          vega: greeks.vega * signedQty,
          theta: greeks.theta * signedQty
        },
        pv: price * signedQty,
        mark_iv: mark.mark_iv
      };
    }).filter(Boolean);
  }, [filteredPositions, F]);

  // Aggregate greeks by expiry
  const expiryTotals = useMemo(() => {
    const totals = {};
    positionData.forEach(pos => {
      const expiry = pos.instrument.split('-')[1];
      if (!totals[expiry]) {
        totals[expiry] = {
          qty: 0,
          delta: 0,
          gamma: 0,
          vega: 0,
          theta: 0,
          pv: 0
        };
      }
      totals[expiry].qty += pos.signedQty;
      totals[expiry].delta += pos.greeks.delta;
      totals[expiry].gamma += pos.greeks.gamma;
      totals[expiry].vega += pos.greeks.vega;
      totals[expiry].theta += pos.greeks.theta;
      totals[expiry].pv += pos.pv;
    });
    return totals;
  }, [positionData]);

  // Total portfolio greeks
  const portfolioTotals = useMemo(() => {
    return positionData.reduce((totals, pos) => ({
      qty: totals.qty + pos.signedQty,
      delta: totals.delta + pos.greeks.delta,
      gamma: totals.gamma + pos.greeks.gamma,
      vega: totals.vega + pos.greeks.vega,
      theta: totals.theta + pos.greeks.theta,
      pv: totals.pv + pos.pv
    }), { qty: 0, delta: 0, gamma: 0, vega: 0, theta: 0, pv: 0 });
  }, [positionData]);

  const Stat = ({ label, value, unit = "", highlight = false }) => (
    <div className={`p-3 rounded-lg ${highlight ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`}>
      <div className="text-xs text-gray-500">{label}</div>
      <div className={`text-lg font-semibold ${highlight ? 'text-blue-700' : ''}`}>{value}{unit}</div>
    </div>
  );

  const formatNumber = (num, decimals = 4) => {
    if (Math.abs(num) < 0.0001) return num.toExponential(2);
    return num.toFixed(decimals);
  };

  return (
    <div className="space-y-6">
      {/* Filters */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Risk Filters</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Expiry</label>
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={selectedExpiry}
              onChange={(e) => setSelectedExpiry(e.target.value)}
            >
              <option value="all">All</option>
              <option value="3OCT25">3OCT25</option>
              <option value="31OCT25">31OCT25</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Bucket</label>
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={selectedBucket}
              onChange={(e) => setSelectedBucket(e.target.value)}
            >
              <option value="all">All</option>
              <option value="0-7d">0-7d</option>
              <option value="7-30d">7-30d</option>
              <option value="30-90d">30-90d</option>
              <option value="90d+">90d+</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Type</label>
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={selectedType}
              onChange={(e) => setSelectedType(e.target.value)}
            >
              <option value="all">All</option>
              <option value="call">Call</option>
              <option value="put">Put</option>
            </select>
          </div>
          
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Side</label>
            <select 
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={selectedSide}
              onChange={(e) => setSelectedSide(e.target.value)}
            >
              <option value="all">All</option>
              <option value="long">Long</option>
              <option value="short">Short</option>
            </select>
          </div>
        </div>
      </div>

      {/* Portfolio Totals */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Portfolio Totals</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-6 gap-4">
          <Stat label="Net Qty" value={portfolioTotals.qty} unit=" contracts" />
          <Stat label="Δ (BTC)" value={formatNumber(portfolioTotals.delta)} unit="" highlight />
          <Stat label="Γ (per $)" value={formatNumber(portfolioTotals.gamma)} unit="" />
          <Stat label="Vega (BTC/vol-pt)" value={formatNumber(portfolioTotals.vega)} unit="" />
          <Stat label="Θ (BTC/day)" value={formatNumber(portfolioTotals.theta)} unit="" />
          <Stat label="PV (BTC)" value={formatNumber(portfolioTotals.pv, 6)} unit="" />
        </div>
        
        <div className="mt-4 grid grid-cols-2 gap-4">
          <Stat label="PV (USD)" value={`$${formatNumber(portfolioTotals.pv * indexPrice, 2)}`} unit="" />
          <Stat label="BTC Index" value={`$${indexPrice.toLocaleString()}`} unit="" />
        </div>
      </div>

      {/* By Expiry */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">By Expiry</h3>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Expiry</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Net Qty</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Δ (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Γ (per $)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Vega (BTC/vol-pt)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Θ (BTC/day)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">PV (BTC)</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {Object.entries(expiryTotals).map(([expiry, totals]) => (
                <tr key={expiry}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{expiry}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{totals.qty}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(totals.delta)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(totals.gamma)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(totals.vega)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(totals.theta)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(totals.pv, 6)}</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* By Strike */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">By Strike (within expiry)</h3>
        
        <div className="overflow-x-auto">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Instrument</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Side</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Qty</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Δ (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Γ (per $)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Vega (BTC/vol-pt)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Θ (BTC/day)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">PV (BTC)</th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Mark IV</th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {positionData.map((pos, index) => (
                <tr key={index}>
                  <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">{pos.instrument}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{pos.side}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{pos.signedQty}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(pos.greeks.delta)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(pos.greeks.gamma)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(pos.greeks.vega)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(pos.greeks.theta)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{formatNumber(pos.pv, 6)}</td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900">{(pos.mark_iv * 100).toFixed(2)}%</td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </div>

      {/* Hedge Panel */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Hedge Suggestions</h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="bg-blue-50 p-4 rounded-lg">
            <h4 className="font-medium text-blue-900 mb-2">Futures Hedge</h4>
            <div className="text-sm text-blue-700">
              <div>Suggested futures position: <strong>{formatNumber(-portfolioTotals.delta)} contracts</strong></div>
              <div className="text-xs text-blue-600 mt-1">
                Hedge ratio = -Δ (futures per option)
              </div>
            </div>
          </div>
          
          <div className="bg-green-50 p-4 rounded-lg">
            <h4 className="font-medium text-green-900 mb-2">Vega Hedge</h4>
            <div className="text-sm text-green-700">
              <div>Vega exposure: <strong>{formatNumber(portfolioTotals.vega)} BTC/vol-pt</strong></div>
              <div className="text-xs text-green-600 mt-1">
                Consider nearby calendar spreads for vega hedging
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

---------- END src/screens/Risk.jsx ----------

---------- BEGIN src/screens/TestSimulation.jsx (bytes=15591) ----------
import React, { useState, useMemo } from 'react';

// Mock current book data
const mockCurrentBook = {
  totalDelta: 0.25,
  totalGamma: 0.0001,
  totalVega: 0.05,
  totalTheta: -0.001,
  totalPv: 0.125
};

// Available instruments for simulation
const availableInstruments = [
  "BTC-3OCT25-110000-C",
  "BTC-3OCT25-111000-C", 
  "BTC-3OCT25-112000-C",
  "BTC-3OCT25-110000-P",
  "BTC-3OCT25-111000-P",
  "BTC-3OCT25-112000-P"
];

export default function TestSimulation() {
  // Simulation state
  const [simPositions, setSimPositions] = useState([]);
  const [scenarios, setScenarios] = useState({
    dF_usd: 0,
    dSigma_bps: 0,
    skew_bps_per_k: 0,
    dt_days: 0
  });
  const [compareMode, setCompareMode] = useState('current'); // 'current' | 'book+sim'
  const [scenarioId, setScenarioId] = useState('scenario_1');

  // Add simulated position
  const addSimPosition = () => {
    const newPosition = {
      id: Date.now(),
      instrument: availableInstruments[0],
      side: 'LONG',
      qty: 1
    };
    setSimPositions([...simPositions, newPosition]);
  };

  // Remove simulated position
  const removeSimPosition = (id) => {
    setSimPositions(simPositions.filter(pos => pos.id !== id));
  };

  // Update simulated position
  const updateSimPosition = (id, field, value) => {
    setSimPositions(simPositions.map(pos => 
      pos.id === id ? { ...pos, [field]: value } : pos
    ));
  };

  // Calculate simulation results
  const simulationResults = useMemo(() => {
    if (simPositions.length === 0) {
      return {
        delta: 0,
        gamma: 0,
        vega: 0,
        theta: 0,
        pv: 0
      };
    }

    // Simplified calculation - in real app, would use actual pricing
    const totalDelta = simPositions.reduce((sum, pos) => {
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      return sum + (signedQty * 0.5); // Simplified delta
    }, 0);

    const totalGamma = simPositions.reduce((sum, pos) => {
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      return sum + (signedQty * 0.0001); // Simplified gamma
    }, 0);

    const totalVega = simPositions.reduce((sum, pos) => {
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      return sum + (signedQty * 0.05); // Simplified vega
    }, 0);

    const totalTheta = simPositions.reduce((sum, pos) => {
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      return sum + (signedQty * -0.001); // Simplified theta
    }, 0);

    const totalPv = simPositions.reduce((sum, pos) => {
      const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
      return sum + (signedQty * 0.0125); // Simplified PV
    }, 0);

    return {
      delta: totalDelta,
      gamma: totalGamma,
      vega: totalVega,
      theta: totalTheta,
      pv: totalPv
    };
  }, [simPositions]);

  // Calculate scenario P&L
  const scenarioPnL = useMemo(() => {
    const { dF_usd, dSigma_bps, skew_bps_per_k, dt_days } = scenarios;
    
    // Simplified scenario P&L calculation
    const deltaPnL = mockCurrentBook.totalDelta * (dF_usd / 100000); // Simplified
    const gammaPnL = mockCurrentBook.totalGamma * Math.pow(dF_usd / 100000, 2) * 0.5;
    const vegaPnL = mockCurrentBook.totalVega * (dSigma_bps / 10000);
    const thetaPnL = mockCurrentBook.totalTheta * dt_days;
    
    const totalPnLBtc = deltaPnL + gammaPnL + vegaPnL + thetaPnL;
    const totalPnLUsd = totalPnLBtc * 111447; // BTC index price
    
    return {
      deltaPnL,
      gammaPnL,
      vegaPnL,
      thetaPnL,
      totalPnLBtc,
      totalPnLUsd
    };
  }, [scenarios]);

  // Compare results
  const compareResults = useMemo(() => {
    if (compareMode === 'current') {
      return {
        delta: mockCurrentBook.totalDelta,
        gamma: mockCurrentBook.totalGamma,
        vega: mockCurrentBook.totalVega,
        theta: mockCurrentBook.totalTheta,
        pv: mockCurrentBook.totalPv
      };
    } else {
      return {
        delta: mockCurrentBook.totalDelta + simulationResults.delta,
        gamma: mockCurrentBook.totalGamma + simulationResults.gamma,
        vega: mockCurrentBook.totalVega + simulationResults.vega,
        theta: mockCurrentBook.totalTheta + simulationResults.theta,
        pv: mockCurrentBook.totalPv + simulationResults.pv
      };
    }
  }, [compareMode, simulationResults]);

  const Stat = ({ label, value, unit = "", highlight = false, positive = null }) => {
    const colorClass = positive !== null ? 
      (positive ? 'text-green-600' : 'text-red-600') : 
      (highlight ? 'text-blue-700' : 'text-gray-900');
    
    return (
      <div className={`p-3 rounded-lg ${highlight ? 'bg-blue-50 border border-blue-200' : 'bg-gray-50'}`}>
        <div className="text-xs text-gray-500">{label}</div>
        <div className={`text-lg font-semibold ${colorClass}`}>{value}{unit}</div>
      </div>
    );
  };

  const formatNumber = (num, decimals = 4) => {
    if (Math.abs(num) < 0.0001) return num.toExponential(2);
    return num.toFixed(decimals);
  };

  return (
    <div className="space-y-6">
      {/* Simulation Controls */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Simulation Controls</h3>
        
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
          {/* Add Simulated Positions */}
          <div>
            <h4 className="font-medium mb-3">Add Simulated Positions</h4>
            <button
              onClick={addSimPosition}
              className="w-full bg-blue-600 text-white py-2 px-4 rounded-lg text-sm font-medium mb-4"
            >
              Add Position
            </button>
            
            <div className="space-y-2 max-h-64 overflow-y-auto">
              {simPositions.map((pos) => (
                <div key={pos.id} className="flex items-center space-x-2 p-2 bg-gray-50 rounded-lg">
                  <select
                    className="flex-1 rounded border border-gray-300 px-2 py-1 text-sm"
                    value={pos.instrument}
                    onChange={(e) => updateSimPosition(pos.id, 'instrument', e.target.value)}
                  >
                    {availableInstruments.map(inst => (
                      <option key={inst} value={inst}>{inst}</option>
                    ))}
                  </select>
                  
                  <select
                    className="rounded border border-gray-300 px-2 py-1 text-sm"
                    value={pos.side}
                    onChange={(e) => updateSimPosition(pos.id, 'side', e.target.value)}
                  >
                    <option value="LONG">LONG</option>
                    <option value="SHORT">SHORT</option>
                  </select>
                  
                  <input
                    type="number"
                    className="w-20 rounded border border-gray-300 px-2 py-1 text-sm"
                    value={pos.qty}
                    onChange={(e) => updateSimPosition(pos.id, 'qty', parseInt(e.target.value) || 0)}
                    min="1"
                  />
                  
                  <button
                    onClick={() => removeSimPosition(pos.id)}
                    className="text-red-600 hover:text-red-800 text-sm"
                  >
                    ×
                  </button>
                </div>
              ))}
            </div>
          </div>

          {/* Scenarios */}
          <div>
            <h4 className="font-medium mb-3">Scenario Parameters</h4>
            
            <div className="space-y-3">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">ΔF (USD)</label>
                <input
                  type="number"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
                  value={scenarios.dF_usd}
                  onChange={(e) => setScenarios({...scenarios, dF_usd: parseFloat(e.target.value) || 0})}
                  step="100"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Vol Shift (bps)</label>
                <input
                  type="number"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
                  value={scenarios.dSigma_bps}
                  onChange={(e) => setScenarios({...scenarios, dSigma_bps: parseFloat(e.target.value) || 0})}
                  step="10"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Skew (bps per k)</label>
                <input
                  type="number"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
                  value={scenarios.skew_bps_per_k}
                  onChange={(e) => setScenarios({...scenarios, skew_bps_per_k: parseFloat(e.target.value) || 0})}
                  step="1"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-1">Time Roll (days)</label>
                <input
                  type="number"
                  className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
                  value={scenarios.dt_days}
                  onChange={(e) => setScenarios({...scenarios, dt_days: parseFloat(e.target.value) || 0})}
                  step="0.1"
                />
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Compare Mode */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Compare Mode</h3>
        
        <div className="flex space-x-4 mb-4">
          <button
            className={`px-4 py-2 rounded-lg text-sm font-medium ${
              compareMode === 'current' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
            }`}
            onClick={() => setCompareMode('current')}
          >
            Current Book
          </button>
          <button
            className={`px-4 py-2 rounded-lg text-sm font-medium ${
              compareMode === 'book+sim' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700'
            }`}
            onClick={() => setCompareMode('book+sim')}
          >
            Book + Simulation
          </button>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
          <Stat label="Δ (BTC)" value={formatNumber(compareResults.delta)} unit="" />
          <Stat label="Γ (per $)" value={formatNumber(compareResults.gamma)} unit="" />
          <Stat label="Vega (BTC/vol-pt)" value={formatNumber(compareResults.vega)} unit="" />
          <Stat label="Θ (BTC/day)" value={formatNumber(compareResults.theta)} unit="" />
          <Stat label="PV (BTC)" value={formatNumber(compareResults.pv, 6)} unit="" />
        </div>
      </div>

      {/* Scenario P&L */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Scenario P&L</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <Stat 
            label="Δ P&L (F move)" 
            value={formatNumber(scenarioPnL.deltaPnL, 6)} 
            unit="" 
            positive={scenarioPnL.deltaPnL > 0}
          />
          <Stat 
            label="Γ P&L (F² move)" 
            value={formatNumber(scenarioPnL.gammaPnL, 6)} 
            unit="" 
            positive={scenarioPnL.gammaPnL > 0}
          />
          <Stat 
            label="Vega P&L (vol move)" 
            value={formatNumber(scenarioPnL.vegaPnL, 6)} 
            unit="" 
            positive={scenarioPnL.vegaPnL > 0}
          />
          <Stat 
            label="Θ P&L (time)" 
            value={formatNumber(scenarioPnL.thetaPnL, 6)} 
            unit="" 
            positive={scenarioPnL.thetaPnL > 0}
          />
        </div>
        
        <div className="mt-4 grid grid-cols-2 gap-4">
          <Stat 
            label="Total P&L (BTC)" 
            value={formatNumber(scenarioPnL.totalPnLBtc, 6)} 
            unit="" 
            positive={scenarioPnL.totalPnLBtc > 0}
            highlight
          />
          <Stat 
            label="Total P&L (USD)" 
            value={`$${formatNumber(scenarioPnL.totalPnLUsd, 2)}`} 
            unit="" 
            positive={scenarioPnL.totalPnLUsd > 0}
            highlight
          />
        </div>
      </div>

      {/* Simulation Results */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Simulation Results</h3>
        
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
          <Stat label="Sim Δ (BTC)" value={formatNumber(simulationResults.delta)} unit="" />
          <Stat label="Sim Γ (per $)" value={formatNumber(simulationResults.gamma)} unit="" />
          <Stat label="Sim Vega (BTC/vol-pt)" value={formatNumber(simulationResults.vega)} unit="" />
          <Stat label="Sim Θ (BTC/day)" value={formatNumber(simulationResults.theta)} unit="" />
          <Stat label="Sim PV (BTC)" value={formatNumber(simulationResults.pv, 6)} unit="" />
        </div>
      </div>

      {/* Scenario Management */}
      <div className="bg-white p-4 rounded-lg shadow border">
        <h3 className="text-lg font-semibold mb-4">Scenario Management</h3>
        
        <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-1">Scenario ID</label>
            <input
              type="text"
              className="w-full rounded-lg border border-gray-300 px-3 py-2 text-sm"
              value={scenarioId}
              onChange={(e) => setScenarioId(e.target.value)}
            />
          </div>
          
          <div className="flex items-end space-x-2">
            <button className="bg-green-600 text-white py-2 px-4 rounded-lg text-sm font-medium">
              Save Scenario
            </button>
            <button className="bg-gray-200 text-gray-700 py-2 px-4 rounded-lg text-sm font-medium">
              Recall Scenario
            </button>
          </div>
          
          <div className="text-sm text-gray-500">
            <div>Saved scenarios: 3</div>
            <div>Last saved: 2024-01-16 15:30:00</div>
          </div>
        </div>
      </div>

      {/* Sandbox Notice */}
      <div className="bg-yellow-50 border border-yellow-200 rounded-lg p-4">
        <div className="flex">
          <div className="flex-shrink-0">
            <svg className="h-5 w-5 text-yellow-400" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
          </div>
          <div className="ml-3">
            <h3 className="text-sm font-medium text-yellow-800">Sandbox Mode</h3>
            <div className="mt-1 text-sm text-yellow-700">
              This simulation does not affect your live book. All calculations are hypothetical and for testing purposes only.
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

---------- END src/screens/TestSimulation.jsx ----------

---------- BEGIN src/screens/VolModel.jsx (bytes=1096) ----------
import React, { useState } from "react";
import VolController from "../components/VolController";

// VolModel now uses the enhanced VolController component

export default function VolModel() {
  // Core state - using live data from your backend
  const F_usd = 109630; // Live BTC futures price from your backend
  const index_usd = 109630; // Live BTC index
  const expiryUtc = new Date("2025-10-03T08:00:00Z"); // 3OCT25 08:00 UTC
  const r = 0.00; // Risk-free rate (annualized decimal)
  
  // Live market data from your Deribit feed
  const market = [
    { K: 110000, price: 0.019 }, // BTC-3OCT25-110000-C
    { K: 122000, price: 0.0008 }, // BTC-3OCT25-122000-C
  ];

  // VolController state
  const [volState, setVolState] = useState(null);

  // The new VolController handles all the data computation internally
  // We just need to pass the live data to it

  return (
    <VolController
      F={F_usd}
      expiry={expiryUtc}
      r={r}
      market={market}
      onChange={setVolState}
      title="Deribit BTC Vol — Live Controller"
      liveConnected={true}
    />
  );
}
---------- END src/screens/VolModel.jsx ----------

---------- BEGIN src/types/index.ts (bytes=6243) ----------
// TypeScript interfaces for Deribit BTC Options Pricer

// ===================== Core Data Types =====================

export interface SviParams {
  a: number;      // Level parameter
  b: number;      // Volatility of volatility
  rho: number;     // Correlation parameter (-1 to 1)
  m: number;      // Mean reversion level
  s: number;      // Volatility of log-moneyness
}

export interface VolNudges {
  parallelBps: number;        // Parallel vol shift in bps
  skewBps: number;            // Skew adjustment in bps
  curvatureBps: number;       // Curvature adjustment in bps
}

export interface QuoteParams {
  baseBps: number;           // Base spread in vol bps
  wDelta: number;             // Risk weight for delta
  wGamma: number;             // Risk weight for gamma
  wVega: number;              // Risk weight for vega
  maxDSigmaBps: number;       // Cap on vol add
  minWidthBtc: number;        // Min width in BTC
  maxWidthBtc: number;         // Max width in BTC
}

// ===================== Position & Trade Data =====================

export interface Position {
  instrument: string;         // e.g., "BTC-3OCT25-110000-C"
  side: "LONG" | "SHORT";
  qty: number;                // contracts
  avg_price_btc: number;      // BTC/contract
  trade_ids: number[];        // Associated trade IDs
}

export interface Trade {
  trade_id: number;
  ts: string;                 // ISO timestamp
  instrument: string;
  side: "BUY" | "SELL";
  qty: number;                // contracts
  price_btc: number;          // BTC/contract
  fee_btc: number;
}

export interface Mark {
  instrument: string;
  mark_iv: number;           // Implied volatility
  F: number;                 // Futures price (USD)
  index_usd: number;         // BTC index price (USD)
  T_years: number;           // Time to expiry
}

// ===================== Risk & P&L =====================

export interface Greeks {
  delta: number;             // BTC per BTC
  gamma: number;             // per $1 move
  vega: number;              // BTC per vol-pt
  theta: number;             // BTC per day
}

export interface RiskMetrics {
  totalDelta: number;
  totalGamma: number;
  totalVega: number;
  totalTheta: number;
  totalPv: number;
}

export interface PnLBreakdown {
  realizedBtc: number;
  unrealizedBtc: number;
  feesBtc: number;
  realizedUsd: number;
  unrealizedUsd: number;
  totalBtc: number;
  totalUsd: number;
}

export interface PnLAttribution {
  priceMoveBtc: number;      // P&L from F moves
  volMoveBtc: number;         // P&L from vol moves
  timeDecayBtc: number;      // P&L from theta
  carryFeesBtc: number;      // P&L from carry/fees
}

// ===================== Simulation =====================

export interface SimPosition {
  scenario_id: string;
  instrument: string;
  side: "LONG" | "SHORT";
  qty: number;
}

export interface Scenario {
  scenario_id: string;
  dF_usd: number;            // F move in USD
  dSigma_bps: number;        // Vol shift in bps
  skew_bps_per_k: number;    // Skew adjustment
  dt_days: number;           // Time roll in days
}

export interface ScenarioResults {
  deltaPnL: number;
  gammaPnL: number;
  vegaPnL: number;
  thetaPnL: number;
  totalPnLBtc: number;
  totalPnLUsd: number;
}

// ===================== Quote Model =====================

export interface QuoteData {
  modelVol: number;          // SVI model volatility
  midBtc: number;            // Mid price in BTC
  bidBtc: number;            // Bid price in BTC
  askBtc: number;            // Ask price in BTC
  midUsd: number;            // Mid price in USD
  bidUsd: number;            // Bid price in USD
  askUsd: number;            // Ask price in USD
  greeks: Greeks;
  dSigmaTot: number;         // Total vol add in bps
  widthBtc: number;          // Quote width in BTC
  appliedCaps: {
    dSigmaCapped: boolean;
    widthCapped: boolean;
  };
}

// ===================== Vol Model =====================

export interface VolModelData {
  sviParams: SviParams;
  volNudges: VolNudges;
  atmStrike: number;
  autoRestrike: boolean;
  diagnostics: {
    minIV: number;
    maxIV: number;
    atmIV: number;
    slope: number;
  };
}

// ===================== Database Schema =====================

export interface DatabaseSchema {
  Positions: Position[];
  Trades: Trade[];
  Marks: Mark[];
  PnLParams: {
    mark_source: "MODEL" | "MID" | "LAST";
    index_usd: number;
    F: number;
  };
  SimPositions: SimPosition[];
  Scenarios: Scenario[];
}

// ===================== API Responses =====================

export interface RiskResponse {
  portfolioTotals: RiskMetrics;
  byExpiry: Record<string, RiskMetrics>;
  byStrike: Array<{
    instrument: string;
    side: string;
    qty: number;
    greeks: Greeks;
    pv: number;
    mark_iv: number;
  }>;
  hedgeSuggestions: {
    futuresHedge: number;
    vegaExposure: number;
  };
}

export interface PnLResponse {
  summary: PnLBreakdown;
  attribution: PnLAttribution;
  byInstrument: Record<string, {
    realizedBtc: number;
    unrealizedBtc: number;
    feesBtc: number;
    currentPosition: number;
    avgCost: number;
  }>;
  parameters: {
    mark_source: "MODEL" | "MID" | "LAST";
    index_usd: number;
    F: number;
    last_updated: string;
  };
}

// ===================== Utility Types =====================

export type InstrumentType = "BTC-3OCT25-110000-C" | "BTC-3OCT25-111000-C" | "BTC-3OCT25-112000-C" | 
                           "BTC-3OCT25-110000-P" | "BTC-3OCT25-111000-P" | "BTC-3OCT25-112000-P";

export type ExpiryType = "3OCT25" | "31OCT25" | "28NOV25";

export type SideType = "LONG" | "SHORT" | "BUY" | "SELL";

export type MarkSourceType = "MODEL" | "MID" | "LAST";

// ===================== Constants =====================

export const DERIBIT_CONVENTIONS = {
  SETTLEMENT_CURRENCY: "BTC",
  EXPIRY_TIME: "08:00 UTC",
  CONTRACT_SIZE: 1, // BTC per contract
  DISCOUNT_FACTOR: 1.0, // DF≈1 for futures options
} as const;

export const DEFAULT_SVI_PARAMS: SviParams = {
  a: 0.08,
  b: 0.45,
  rho: -0.25,
  m: 0.00,
  s: 0.15
};

export const DEFAULT_QUOTE_PARAMS: QuoteParams = {
  baseBps: 8,
  wDelta: 0.02,
  wGamma: 1000,
  wVega: 0.05,
  maxDSigmaBps: 300,
  minWidthBtc: 0.0001,
  maxWidthBtc: 0.01
};

---------- END src/types/index.ts ----------

---------- BEGIN src/utils/pricing.ts (bytes=9147) ----------
// Black-76 pricing functions for Deribit BTC Options

// Math helpers
function erf(x: number): number {
  const sign = x < 0 ? -1 : 1;
  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741, a4 = -1.453152027, a5 = 1.061405429, p = 0.3275911;
  const t = 1 / (1 + p * Math.abs(x));
  const y = 1 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
  return sign * y;
}

function N(x: number): number {
  return 0.5 * (1 + erf(x / Math.SQRT2));
}

function n(x: number): number {
  return Math.exp(-0.5 * x * x) / Math.sqrt(2 * Math.PI);
}

// ===================== Black-76 Pricing =====================

export interface Black76Params {
  F: number;        // Futures price (USD)
  K: number;        // Strike price (USD)
  T: number;        // Time to expiry (years)
  sigma: number;    // Implied volatility
  isCall: boolean;  // Call or Put
  df?: number;      // Discount factor (default 1.0 for futures)
}

export interface Black76Result {
  price: number;    // Option price in BTC
  delta: number;    // Delta in BTC per BTC
  gamma: number;    // Gamma per $1 move
  vega: number;     // Vega in BTC per vol-pt
  theta: number;    // Theta in BTC per day
  d1: number;       // d1 from Black-76
  d2: number;       // d2 from Black-76
}

/**
 * Black-76 option pricing for futures options
 * @param params Black-76 parameters
 * @returns Option price and Greeks in BTC
 */
export function black76Price(params: Black76Params): number {
  const { F, K, T, sigma, isCall, df = 1.0 } = params;
  
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F / K) + 0.5 * sigma * sigma * T) / sT;
  const d2 = d1 - sT;
  
  if (isCall) {
    return df * (F * N(d1) - K * N(d2));
  }
  return df * (K * N(-d2) - F * N(-d1));
}

/**
 * Black-76 Greeks calculation
 * @param params Black-76 parameters
 * @returns Greeks in BTC terms
 */
export function black76Greeks(params: Black76Params): Black76Result {
  const { F, K, T, sigma, isCall, df = 1.0 } = params;
  
  const sT = Math.max(1e-12, sigma * Math.sqrt(Math.max(T, 1e-12)));
  const d1 = (Math.log(F / K) + 0.5 * sigma * sigma * T) / sT;
  const d2 = d1 - sT;
  const pdf = n(d1);
  
  const vega = df * F * pdf * Math.sqrt(Math.max(T, 1e-12));
  const gamma = df * pdf / (F * sT);
  const delta = (isCall ? 1 : -1) * df * N((isCall ? 1 : -1) * d1);
  
  // Simplified theta calculation
  const theta = -df * F * pdf * sigma / (2 * Math.sqrt(T)) - 
                (isCall ? 1 : -1) * df * F * N((isCall ? 1 : -1) * d1) * 0.01;
  
  return {
    price: black76Price(params),
    delta,
    gamma,
    vega,
    theta,
    d1,
    d2
  };
}

// ===================== SVI Smile Model =====================

export interface SviParams {
  a: number;      // Level parameter
  b: number;      // Volatility of volatility
  rho: number;     // Correlation parameter
  m: number;      // Mean reversion level
  s: number;      // Volatility of log-moneyness
}

export interface VolNudges {
  parallelBps: number;        // Parallel vol shift in bps
  skewBps: number;            // Skew adjustment in bps
  curvatureBps: number;       // Curvature adjustment in bps
}

/**
 * SVI total variance function
 * @param k Log-moneyness (ln(K/F))
 * @param params SVI parameters
 * @returns Total variance
 */
export function sviTotalVariance(k: number, params: SviParams): number {
  const { a, b, rho, m, s } = params;
  const x = k - m;
  return a + b * (rho * x + Math.sqrt(x * x + s * s));
}

/**
 * SVI implied volatility
 * @param k Log-moneyness (ln(K/F))
 * @param T Time to expiry
 * @param params SVI parameters
 * @returns Implied volatility
 */
export function sviImpliedVolatility(k: number, T: number, params: SviParams): number {
  const w = sviTotalVariance(k, params);
  return Math.sqrt(Math.max(1e-12, w / Math.max(T, 1e-12)));
}

/**
 * Apply global vol nudges to SVI model
 * @param k Log-moneyness (ln(K/F))
 * @param T Time to expiry
 * @param sviParams SVI parameters
 * @param nudges Global vol nudges
 * @returns Adjusted implied volatility
 */
export function applyVolNudges(
  k: number, 
  T: number, 
  sviParams: SviParams, 
  nudges: VolNudges
): number {
  const baseIV = sviImpliedVolatility(k, T, sviParams);
  
  const parallelShift = nudges.parallelBps / 10000;
  const skewShift = (nudges.skewBps / 10000) * k;
  const curvatureShift = (nudges.curvatureBps / 10000) * k * k;
  
  return Math.max(0.001, baseIV + parallelShift + skewShift + curvatureShift);
}

// ===================== Quote Model =====================

export interface QuoteParams {
  baseBps: number;           // Base spread in vol bps
  wDelta: number;             // Risk weight for delta
  wGamma: number;             // Risk weight for gamma
  wVega: number;              // Risk weight for vega
  maxDSigmaBps: number;       // Cap on vol add
  minWidthBtc: number;        // Min width in BTC
  maxWidthBtc: number;         // Max width in BTC
}

export interface QuoteResult {
  modelVol: number;          // SVI model volatility
  midBtc: number;            // Mid price in BTC
  bidBtc: number;            // Bid price in BTC
  askBtc: number;            // Ask price in BTC
  midUsd: number;            // Mid price in USD
  bidUsd: number;            // Bid price in USD
  askUsd: number;            // Ask price in USD
  greeks: Black76Result;
  dSigmaTot: number;         // Total vol add in bps
  widthBtc: number;          // Quote width in BTC
  appliedCaps: {
    dSigmaCapped: boolean;
    widthCapped: boolean;
  };
}

/**
 * Calculate option quotes using SVI model and risk adjustments
 * @param F Futures price (USD)
 * @param K Strike price (USD)
 * @param T Time to expiry (years)
 * @param isCall Call or Put
 * @param sviParams SVI parameters
 * @param volNudges Global vol nudges
 * @param quoteParams Quote parameters
 * @param indexPrice BTC index price (USD)
 * @param qty Number of contracts
 * @returns Quote result
 */
export function calculateQuotes(
  F: number,
  K: number,
  T: number,
  isCall: boolean,
  sviParams: SviParams,
  volNudges: VolNudges,
  quoteParams: QuoteParams,
  indexPrice: number,
  qty: number = 1
): QuoteResult {
  // 1. Model vol from SVI
  const k = Math.log(K / F);
  const modelVol = applyVolNudges(k, T, sviParams, volNudges);
  
  // 2. Mid price in BTC
  const midBtc = black76Price({ F, K, T, sigma: modelVol, isCall });
  
  // 3. Greeks in BTC terms
  const greeks = black76Greeks({ F, K, T, sigma: modelVol, isCall });
  
  // 4. Risk add (vol bps)
  const deltaRisk = quoteParams.wDelta * Math.pow(greeks.delta * qty, 2);
  const gammaRisk = quoteParams.wGamma * Math.pow(greeks.gamma * qty, 2);
  const vegaRisk = quoteParams.wVega * Math.pow(greeks.vega * qty, 2);
  const dSigmaRisk = Math.min(quoteParams.maxDSigmaBps / 10000, deltaRisk + gammaRisk + vegaRisk);
  
  // 5. Total vol add (bps)
  const dSigmaTot = (quoteParams.baseBps / 10000) + dSigmaRisk;
  
  // 6. Width in BTC
  const vegaEff = Math.max(1e-8, Math.abs(greeks.vega) * Math.max(1, Math.abs(qty)));
  const widthBtc = Math.max(quoteParams.minWidthBtc, Math.min(quoteParams.maxWidthBtc, vegaEff * dSigmaTot));
  
  // 7. Bid/Ask in BTC
  const bidBtc = midBtc - 0.5 * widthBtc;
  const askBtc = midBtc + 0.5 * widthBtc;
  
  // 8. USD mirrors
  const midUsd = midBtc * indexPrice;
  const bidUsd = bidBtc * indexPrice;
  const askUsd = askBtc * indexPrice;
  
  return {
    modelVol,
    midBtc,
    bidBtc,
    askBtc,
    midUsd,
    bidUsd,
    askUsd,
    greeks,
    dSigmaTot: dSigmaTot * 10000, // Convert back to bps
    widthBtc,
    appliedCaps: {
      dSigmaCapped: dSigmaRisk < (deltaRisk + gammaRisk + vegaRisk),
      widthCapped: widthBtc === quoteParams.maxWidthBtc
    }
  };
}

// ===================== Risk Calculations =====================

/**
 * Calculate portfolio risk metrics
 * @param positions Array of positions
 * @param marks Current marks
 * @returns Risk metrics
 */
export function calculatePortfolioRisk(
  positions: Array<{
    instrument: string;
    side: "LONG" | "SHORT";
    qty: number;
  }>,
  marks: Record<string, {
    mark_iv: number;
    F: number;
    T_years: number;
  }>
): {
  totalDelta: number;
  totalGamma: number;
  totalVega: number;
  totalTheta: number;
  totalPv: number;
} {
  let totalDelta = 0;
  let totalGamma = 0;
  let totalVega = 0;
  let totalTheta = 0;
  let totalPv = 0;

  positions.forEach(pos => {
    const mark = marks[pos.instrument];
    if (!mark) return;

    const strike = parseFloat(pos.instrument.split('-')[2]);
    const isCall = pos.instrument.includes('-C');
    const signedQty = pos.side === 'LONG' ? pos.qty : -pos.qty;
    
    const greeks = black76Greeks({
      F: mark.F,
      K: strike,
      T: mark.T_years,
      sigma: mark.mark_iv,
      isCall
    });
    
    totalDelta += greeks.delta * signedQty;
    totalGamma += greeks.gamma * signedQty;
    totalVega += greeks.vega * signedQty;
    totalTheta += greeks.theta * signedQty;
    totalPv += greeks.price * signedQty;
  });

  return {
    totalDelta,
    totalGamma,
    totalVega,
    totalTheta,
    totalPv
  };
}

---------- END src/utils/pricing.ts ----------
